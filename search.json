[{"title":"DOM","url":"%2F2019%2F12%2F12%2FDOM%2F","content":"## HTML\nHypertext Markup Language），中文為「超文字標示語言」，是一種用來組織架構並呈現網頁內容的程式語言。網頁內容的組成，可能包含了段落、清單、圖片或表格...等。\n\n## JavaScript 操作 DOM 的一些方法\nDOM：文件物件模型(Document Object Model)， 瀏覽器幫 HTML 的元素節點轉換成 JavaScript 可以操作的物件。  \n#### 選取元素\n```\nlet element = document.querySelector('<element-name>');\n```\n#### 新增元素節點\n```\ndocument.createElement(\"div\");\n```\n\n#### 在某元素後面加入元素\n```\n.appendChild()\n```\n#### 移除該元素\n```\n.removeChild()\n```\n\n#### 改變元素裡面的文字內容\n```\n.innerText()\n```\n\n#### 改變元素文字及標籤內容\n```\n.innerHTML() \n```\n\n#### 新增元素節點樣式\n```\n.classList.add('樣式');\n```\n\n#### 刪除元素節點樣式\n```\n.classList.delete('樣式')\n```\n\n#### 監聽元素事件\n```\nelement.addEventLister('事件名稱', function(e){\n    // do something\n},<boolean>)\ntrue => 捕獲 ; false => 冒泡，不加參數的話，預設值是 false\n```\n\n#### e.g. click 事件(e.target 點擊到的元素)\n```\n<div id=\"test\"></div>  \n\n<script>\ndocument.getElementById(\"test\").addEventListener(\"click\", function( event ) {\n    // 在 “clicked div”顯示點擊次數\n    event.target.innerHTML = \"click count: \" + event.detail;\n  }, false);\n</script>\n```\n## DOM 事件傳遞機制\n#### 捕獲\n>根節點開始往下傳遞子節點然後到 target \n\n\n#### 冒泡\n>從 target 往上到子節點一路逆向傳回去根節點\n\n**DOM 事件傳遞的順序，先捕獲 -> 自身 -> 冒泡。**\n\n#### 取消事件傳遞 ```e.stopPropagation```\n*加在哪邊，事件傳遞就停在那，不向上(或下)級傳遞*\n\n```\nel.addEventListener('click', (e) => {\n  // e.eventPhase 回傳一個整數值以代表目前事件於事件流中的傳遞階段\t\n  console.log('el', e.eventPhase);\n  e.stopPropagation();\n}, true)\n```\n#### 取消預設行為 ```e.preventDefault()```\n*取消瀏覽器的預設行為*\n\n```\n// 超連結使用(不會新開分頁或是跳轉）\nel_link.addEventListener('click', (e) => {\n  e.preventDefault();\n}, false)\n// <form> 的 submit - 阻止送出表單\n// <input> 的 keypress 事件 - 阻止輸入按鍵\n```\n## 事件傳遞應用\n**事件代理(Delegation)**  \n利用 DOM 事件的冒泡特性，將子層元素的監聽事件綁定在父層元素上，好處有：  \n1.如果有很多子元素，就不用一一綁定監聽事件。 \n2.動態新增進來的子元素，因為也是會冒泡到上層，就不怕沒綁定到監聽。\n\n\n## 元素操作範例\n#### 印出 9*9  \n```\n(function() {\n    const chart = document.querySelector('#chart');  \n    for (let i = 2; i <= 9; i++) {        \n      const DIV = document.createElement('div'); // 新增 DIV 節點\n      DIV.classList.add('col-md-4');   // 新增 DIV 樣式\n      chart.appendChild(DIV);   // id=chart 的元素增加子節點 DIV\n      // chart.append  將字串插入到網頁元素\n      const UL = document.createElement('ul');\n      UL.classList.add('chart-list', 'list-unstyled', 'bg-light');\n      DIV.appendChild(UL);  \n      let str = `<li class=\"chart-num\">${ i }</li>`;// 2 ~ 9 // 組開頭數字 2~9 字串\n      //console.log('外層for', str);\n      for (let j = 1; j <= 9; j++) {    \n        str += `<li class=\"h4\">${ i } x ${ j } = ${ i*j }</li>`; // 2 x 1 ~ 9 x 9\n      //console.log('內層for', str);\n      }             \n      //console.log('結果', str);\n      UL.innerHTML = str;      // 將字串插入到網頁元素\n    }  \n  }());  //立即呼叫函式 IIFE\n```\n#### 印出正方形\n```\nfunction square(size){\n    const chart = document.querySelector('#chart1');\n    for (let i = 1; i <= size; i++) {  // 印出第i列\n      for (let j = 1; j <= size; j++) {  // 第i列有size個*\n        const sp = document.createElement('span');\n        sp.classList.add('col-md-4')\n        chart.appendChild(sp);  // 增加 span 元素\n        let str = `*`;\n        sp.innerHTML = str;     // 新增元素內容\n        }\n        const Br = document.createElement('br');\n        chart.appendChild(Br);   // 增加斷行元素\n    } \n};\n```\n#### 印出斜一邊的三角形\n```\nfunction sidetriangle(size) {\n  const chart = document.querySelector('#chart2');\n  for (let i = 1; i <= size; i++) {  // 印出第i列\n    for (let j = 1; j <= i; j++) {   // 第i列有i個*\n      const sp = document.createElement('span');\n        sp.classList.add('col-md-4')\n        chart.appendChild(sp);  // 增加 span 元素\n        let str = `*`;\n        sp.innerHTML = str;     // 新增元素內容\n    }\n      const Br = document.createElement('br');\n      chart.appendChild(Br);   // 增加斷行元素\n  }\n};\n```\n\n參考：  \n[MDN](https://developer.mozilla.org/zh-TW/docs/Web/API/Document_Object_Model)  \n[DOM 的事件傳遞機制：捕獲與冒泡](https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/)\nhttps://yakimhsu.com/project/project_w10_review_DOM&EventListener.html  \n","tags":["DOM"],"categories":["DOM"]},{"title":"Git 基本介紹","url":"%2F2019%2F12%2F11%2FGit%2F","content":"簡單記錄一下 Git 學習過程 \n## Git\n* Git 是一個分散式版本控制軟體，可藉由它產生一個*儲存庫( git Repository)*。\n* 可在自己本機電腦跟遠端伺服器儲存及管理檔案，並做同步處理。\n* 紀錄管理有使用 Git 的目錄內的檔案增刪、檔案內容的修改。\n* 有圖形化介面可以使用，例如：SourceTree。  \n\n## 終端機指令介紹\n在操作 Git 之前，先來介紹一下終端機的基本指令  \n#### ls \n>查看目錄中的檔案列表\n\n#### ls -la\n>列出隱藏文件\n\n#### cd ~\n>前往主目錄\n\n#### pwd \n>查看目前所在目錄位置\n\n#### mkdir test \n>建立 test 的子目錄\n\n#### cd test \n>切換到 test 目錄\n\n#### cd .. \n>回到上層目錄\n\n#### touch index.html \n>新增 html 檔,若目錄內已有檔案時,會修改檔案時間\n\n#### cp \n>複製文件\n\n#### mv\n>移動檔案\n\n#### rm index.html\n>刪除檔案\n\n#### rm -R \n>刪除資料夾與其內所有檔案\n\n## 安裝Git\n**到官方網站根據自己的作業系統下載**  \n[https://git-scm.com/downloads](https://git-scm.com/downloads)\n\n**或是透過 Homebrew 來下載**  \n[https://brew.sh/index_zh-tw.html](https://brew.sh/index_zh-tw.html)\n\n```\n$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n複製以上內容，到終端機視窗貼上並執行。\n安裝完後，再複製以下內容，\n\n```\n$ brew install git\n```\n到終端機視窗貼上並執行。\n\n## 使用者設定\n剛開始使用時 Git ，首先要設定名稱跟 e-mail 信箱  \n\n```\n$ git config --global user.name \"your_name\"\n$ git config --global user.email \"your_email\"\n```\n\n## Git 區塊\nGit 有三個檔案存放區塊  \n![block](./2019-12-12-Git/block.jpg)  \n\n如圖所示，分為  \n**工作目錄** (未 add )，初始狀態。  \n**暫存區** (已 add ，未 commit )  \n**儲存區** (已 commit )  \n\n## Git 指令(終端機)\n\n#### git init \"要板控的專案目錄\"\n>初始化專案，開始版控\n\n#### git add .要放入存放區的檔案 \n>(ex.  git add .gitignore )\n\n#### git add .   \n>當前目錄所新增及修改的檔案加到暫放區(若是在根目錄執行，大致上等於 git add -A)\n\n#### git add -A \n>整個專案目錄所有的修改都加入到暫放區\n\n#### git status\n>看暫放區狀態\n\n#### git commit -m \"提交訊息(註解)\"\n>加入註解後，將專案目錄儲存到儲存庫  \n\n#### git log —oneline\n>看訊息\n\n#### git blame index.html\n>查看檔案內容是誰修改(e.g. index.html)\n\n## Git 分支\n#### git branch '分支名稱'\n>新增分支 dog(分支可當成貼上標籤)\n\n#### git branch -d '分支名或id' \n>刪除分支，若參數為 -D ，則是強制刪除\n\n#### git branch \n>查看分支  名稱前有 * 的是 head 所在\n\n#### git branch -f master 版本號碼 \n>將 master 移至該版本號碼\n\n#### git checkout '分支名稱或版本id' \n>切換到該分支或該版本\n\n#### git checkout -b dog \n>建立 dog 分支並切換過去\n\n#### git merga '分支名稱' \n>合併該分支\n\n#### git rebase '分支名稱'(另一種合併方式 ) \n>改變 base (不會產生合併節點)\n\n#### git reset commit_id(變回該版本)  \n>回到某個版本，原本內容會回到工作目錄  \n--mixed  檔案丟回工作目錄  \n--soft   檔案丟回暫存區  \n--hard   直接刪掉\n\n#### git reflog \n>看 log\n\n#### git reset commit_id^ \n>回到該版本的前一個狀態 幾個 **^** 等於回前幾個\n\n#### git reset HEAD~2\n>回到 HEAD 的前2個狀態\n\n#### git tag 1.0.0 commit_id \n>貼上標籤\n\n#### git revert \n>撤消一個commit 同時建立一個新的\n\n## 遠端資料庫操作(e.g. GitHub)  \n*ps.先到 GitHub 新增一個儲存庫*\n\n#### git remote add origin \"遠端 git 網址\"\n>連接遠端儲存庫。origin 代表遠端節點，名稱可修改。\n\n#### git remote -v  \n>查看遠端 Git 的目的地  \n\n#### git push origin master  \n>把本地的 master 分支推送到 origin 這個遠端節點並在遠端形成一個 master 分支  \n\n#### git pull origin master  \n>到 origin 這個遠端節點, 抓 master 分支的內容,並在本地電腦建立一個 origin/master 分支,同時與本地的 master 分支進行合併\n\n#### git fetch origin master  \n>到 origin 這個遠端節點, 抓 master 分支的內容,並在本地電腦建立一個 origin/master 分支\n\n#### git clone \"遠端 Git 網址\"\n>把遠端 Git 網址的內容複製ㄧ份到本地端電腦\n\n## Git 情況處理\n### 1.遠端內容比本機上的新  \nGit push 時發生以下錯誤：\n>error: failed to push some refs to 'https://github.com/xxxx/xxx.git'  \nhint: Updates were rejected because the remote contains work that you do  \nhint: not have locally. This is usually caused by another repository pushing  \nhint: to the same ref. You may want to first integrate the remote changes  \nhint: (e.g., 'git pull ...') before pushing again.  \nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n  \n這段訊息的意思是線上版本的內容比你電腦裡這份還要新，所以 Git 不讓你推上去。可用  **git pull origin master —rebase** (內容抓下來之後請使用 Rebase 方式合併。)\n盡量不要用 **git push -f origin master** 會把自己的檔推上去蓋掉他人的,並以自己的為主。  \nps.多人的話,盡量開自己的分支來做\n### 2.不想在 Git 內放機密檔案\n\n$ touch .gitignore (建立Git 忽略檔案, 然後去編輯 gitignore. 已經存在的黨無效) \n\n內容可放  \nnom-debug.log  npm除錯紀錄  \nnode_modules 專案依賴關係  \n.DS_Store  OSX資料夾屬性    \n*.tmp 暫時性檔案  \n*~\n\n## 不想再用版控\n把 **.git** 目錄刪除就可以\n\n參考   \n[為你自己學 Git](https://gitbook.tw)  \n[Git: 如何從特定 commit 切新的分支？](https://cythilya.github.io/2019/12/03/git-detached-head-to-a-new-branch/)","tags":["Git"],"categories":["Git"]},{"title":"基本陣列操作","url":"%2F2019%2F12%2F10%2F%E5%9F%BA%E6%9C%AC%E9%99%A3%E5%88%97%E6%93%8D%E4%BD%9C%2F","content":"## 介紹一下陣列基本操作的幾個方法\n\n####  建立陣列\n  \n```javascript\nconst arr = [1,2,3,4,5];    \nconst arr = new Array(1, 2, 3, 4, 5);  \nconst arr = Array(1,2,3,4,5);\n```\n####  陣列長度 \n  \n```javascript \nconsole.log(arr.length);  // 5\n```\n####  設定長度  \n  \n```javascript\nconst arr = new Array(5);\n```\n####  空陣列\n  \n```javascript  \nconst arr = [];\n```\n####  讀取其中一個元素，索引從零開始，對應第一個元素  \n  \n```javascript\nconsole.log(arr[0]);  // 1\n```\n####  設定陣列長度可以操作陣列內元素，長度若為零。則輸入空陣列\n  \n```javascript\narr.length = 0;\nconsole.log(arr);  // []\n```\n####  Array.from() 可建立一個新的 Array 實體  \n  \n1.從字串\n  \n```javascript\nArray.from('Hi');  // [\"h\", \"i\"]\n```\n\n2.從集合：集合會將集合內重複的元素剔除，可作分類使用\n  \n```javascript\nvar s = new Set(['hi', 1, 1, 2]); \nArray.from(s);\nconsole.log(s);  // {\"hi\", 1, 2}  \n```\n  \n### 迭代(讀取每一個值，然後用同樣的方式處理每一個值)\n  \n#### for 迴圈取陣列元素\n  \n```javascript\nconst arr = [1,2,3,4,5];\nfor (let i = 0; i < arr.length; i++) {\nconsole.log(arr[i]); // 依序輸出 1 2 3 4 5 \n}\n// 另一種寫法\nlet arr = [1, 2, 3, 4, 5];\nfor (let index in arr) { \n    console.log(arr[index]); 依序輸出 1 2 3 4 5\n}\n```\n#### foreach：將陣列內每個元素，都傳入並執行指定函式一次。\n\n```javascript\n// 取陣列中大於 3 的數字\nconst arr = [1, 2, 3, 4, 5];\nlet arr1 = [];\narr.forEach((value) => {\nif (value > 3){\n  arr1.push(value);\n}\n});\nconsole.log(arr3);    // [4,5]\n```\n## 方法\n\n#### push()：新增元素 \n  \n```javascript\nconst arr = [1,2,3,4,5]  \narr.push(6); // [1, 2, 3, 4, 5, 6]\n```\n#### pop()：取出陣列最後一個元素並從陣列移除 \n  \n```javascript\nconst arr = [1,2,3,4,5];\nlet el = arr.pop(); // el = 5\nconsole.log(arr); //  [1,2,3,4]\n```\n#### concat()：合併兩個陣列，並把新的陣列返回\n\n```javascript\nvar a1 = [1, 2];\nvar a2 = a1.concat(['a', 'b']);\nconsole.log(a2); // 1,2,a,b\n```\n#### join()：把所有的陣列元素合併成字串\n\n```javascript\nvar a = ['Hello', 'world'];\nconsole.log(a.join('-')); // \"Hello-world\"\nconsole.log(a.join('')); // \"Helloworld\"\n```\n#### reverse()：反轉陣列元素的順序至適當的位置\n\n```javascript\nconst arr = [1,2,3,4,5];\narr.reverse();\nconsole.log(arr);  // [5, 4, 3, 2, 1]\n```\n#### ps.反轉字串應用\n\n```javascript\nconst str = 'Hello';\n// split 將字串以指定的分隔符號來分割 \nstr1 = str.split('').reverse().join('');\nconsole.log(str1);     // olleH \n```\n#### shift()：取回陣列的第一個元素並移除\n\n```javascript\nconst arr = [1,2,3,4,5];\nlet a = arr.shift();\nconsole.log(a)    // 1\nconsole.log(arr); // [2, 3, 4, 5]\n```\n#### unshift()：在陣列的開頭處加入一個以上的元素\n\n```javascript\nconst arr = [1,2,3,4,5];\narr.unshift(6)    \nconsole.log(arr); // [6, 1, 2, 3, 4, 5]\n```\n#### slice(start_index, upto_index)：回傳部分陣列\n\n```javascript\nconst arr = [1,2,3,4,5];\narr.slice(1,4)  // arr[1] 到 arr[3] 之間的元素\nconsole.log(arr); // [2, 3, 4]\n```\n#### splice(start, deleteCount, item1, ... )：刪除既有元素／或加入新元素來改變一個陣列的內容\nstart：開始位置\ndeleteCount：刪除幾個元素(0 就是不刪除)\nitem1：要加入的元素\n\n```javascript\nconst arr = [1,2,3,4,5];\nlet removed = arr.splice(1, 0, 3)\nconsole.log(removed);  // []\nconsole.log(arr);      // [1, 3, 2, 3, 4, 5]\n\nlet removed2 = arr.splice(1, 2, 3)\nconsole.log(removed2); // [3, 2]\nconsole.log(arr);      // [1, 3, 3, 4, 5]\n```\n\n#### sort()：排序陣列的元素，預設的排序順序是根據字串的 Unicode 編碼位置\n\n```javascript\nconst arr = ['bob', 'alice', 'jack'];\narr.sort();  \nconsole.log(arr); // [\"alice\", \"bob\", \"jack\"]\n```\n\n#### ps.也可以用函式來決定如何排序(陣列數字排列要用這種方式)\n\n```javascript\nconst arra = [2,6,1,8,10,32];\n// 數字排列小到大\n  arra.sort(function(a, b){\n  return a - b;\n  });\nconsole.log(arra);     // [1, 2, 6, 8, 10, 32]\n// 數字排列大到小\n  arra.sort(function(a, b){\n  return b - a;\n  });\nconsole.log(arra);     //  [32, 10, 8, 6, 2, 1]\n```\n#### ps.陣列數字找大小：用展開運算子將陣列展開成個別值就可以用函式快速找出\n\n```javascript\n// 陣列數字找大小\nconst arra = [2,6,1,8,10,32];\nlet max = Math.max(...arra);\nlet min = Math.min(...arra);\nconsole.log(max, min);   // 32, 1\n```\n#### indexOf()：尋找陣列中是否有符合的元素，回傳 -1，表示沒有，回傳正整數表示在那個位置\n\n```javascript\nconst arr = [1,2,3,4,5];\nconsole.log(arr.indexOf(3));  // 2\n```\n#### ps.jQuery 用法\n\n```javascript\nconst arr = [1,2,3,4,5];\nconsole.log($.inArray(2, arr));  // 1\n```\n#### includes：陣列中尋找指定元素，回傳 true(找到)或 false(沒找到)\n\n```javascript\nconst arr = [1,2,3,4,5];\nconsole.log(arr.includes(2));  // true\n```\n#### filter()：回傳符合條件的元素，得到一個新陣列\n\n```javascript\nconst arr = [1,2,3,4,5];\nlet arr1 = arr.filter((value) => {\n  return value > 3;\n  });\nconsole.log(arr1);   // [4,5]\n```\n#### indexOf 與 $.map 使用，尋找是否有符合的物件\n\n```javascript\nconst people = [\n  { name: 'Peter', age: 10 },\n  { name: 'John', age: 3 },\n  { name: 'Nina', age: 15 }\n];\n//find object in list\nlet result = $.map(people, function(item, index) {\n  return item.name\n}).indexOf('Nina');\nconsole.log(result); //2\n```\n\n#### map()：原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合成為一個新陣列，常用對陣列元素做加工\n\n```javascript\nconst arr = ['a', 'b', 'c'];\nlet arr1 = arr.map((value) => {\n    return value.toUpperCase() ;\n  });\nconsole.log(arr1);   // [\"A\", \"B\", \"C\"]\n```\n#### every()：檢查陣列是否全部符合條件，僅會回傳一個值 true or false\n\n```javascript\nconst arr = [1,2,3,4,5];\nlet arr1 = arr.every((value) => {\n  return value >= 1;\n  });\nconsole.log(arr1);   // true\n```\n#### some()：檢查陣列元素其中是否有符合條件，僅會回傳一個值 true or false\n\n```javascript\nconst arr = [1,2,3,4,5];\nlet arr1 = arr.some((value) => {\n  return value === 3;\n  });\nconsole.log(arr1);   // true\n```\n\n#### reduce()：陣列變成個別值，傳入函式內處理。數值加總是常見做法\n\n```javascript\nconst arr = [1,2,3,4,5];\n// 處理每個元素後等待回傳結果，第一次處理時代入初始值 0\nlet result = arr.reduce((prev, value) => {\n// 與之前的數值加總，回傳後代入下一輪的處理\n  return prev + value;\n  }, 0);  // 初始值為零\nconsole.log(result);   // 15\n```\n#### ps.陣列扁平化，將複雜的陣列變成一維\n\n```javascript\nconst myArr = [\n    [ 1, 2 ],\n    [ 3, 4, 5 ],\n    [ 6, 7, 8 ]\n];\n// 將所有元素都與之前代入的陣列相接起來，第一次處理時代入初始值空陣列\nlet newArr = myArr.reduce(function(arr, element) {\n    // ex: [ 1, 2 ].concat([ 3, 4, 5 ])\n    return arr.concat(element);\n}, []);\nconsole.log(newArr); // [ 1, 2, 3, 4, 5, 6, 7, 8 ]\n\n// 1.將空陣列與 [ 1, 2 ] 相接起來後回傳\n// 2.將被代入的 [ 1, 2 ] 與 [ 3, 4, 5 ] 相接起來後回傳\n// 3.將被代入的 [ 1, 2, 3, 4, 5 ] 與 [ 6, 7, 8 ] 相接起來後回傳\n```\n#### ps.對陣列的內容進行統計\n\n```javascript\nconst myArr = [\n    'C/C++',\n    'JavaScript',\n    'Ruby',\n    'Java',\n    'Objective-C',\n    'JavaScript',\n    'PHP'\n];\n\n// 計算出每種語言出現過幾次\nlet langStatistics = myArr.reduce(function(langs, langName) {\n    // hasOwnProperty() 回傳物件是否有該屬性的布林值。\n    if (langs.hasOwnProperty(langName)) { \n        langs[langName]++\n    } else {\n        langs[langName] = 1;\n    }\n    \n    return langs;\n}, {});\nconsole.log(langStatistics);\n// { 'C/C++': 1, 'JavaScript': 2, 'Ruby': 1, 'Java': 1, 'Objective-C': 1, 'PHP': 1 }\n```\n#### ps. Object 的形式的處理\n\n```javascript\nconst data = {\n    'Fred': 1,\n    'Leon': 2,\n    'Wesley': 3,\n    'Chuck': 4,\n    'Denny': 5\n};\n\n// 使用 Object.keys() 取得包含所有 key 的陣列\nlet result = Object.keys(data).reduce(function(prev, name) {\n    // 利用 key 取得原始物件中的值，然後加總\n    return data[name] + prev;\n}, 0);\n\nconsole.log(result); // 15\n\n// Object.keys()：回傳一個由指定物件所有可列舉之屬性(key)組成的陣列\nObject.keys(data) // [\"Fred\", \"Leon\", \"Wesley\", \"Chuck\", \"Denny\"]\ndata[Fred] // 1\n\n```\n\n#### ps. map() 和 reduce() 結合使用\n\n```javascript\nconst arr = [1,2,3,4,5,6,7,8,9,10];\nlet result = arr.map((value) => {\n  if (value > 5) {\n    return 5;\n  }\n    return value;\n })\n.reduce((prev, value) => {\n  return prev + value;\n  }, 0);  // 初始值為零\nconsole.log(result);   // 40\n```\n\n\n\n\n參考資料  \nhttps://www.hexschool.com/2017/09/01/2017-09-01-javascript-for/\nhttp://fred-zone.blogspot.com/2017/01/javascript-mapreduce.html\nhttps://cythilya.github.io/2017/05/08/javascript-find-item-in-an-array/\nhttps://developer.mozilla.org/zh-TW/","tags":["array"],"categories":["JavaScript"]},{"title":"CSS偽類與偽元素","url":"%2F2019%2F06%2F05%2FCSS%2F","content":"### 偽元素 (pseudo element) 和偽類 (pseudo class) 差在哪\n\n有時候 CSS 裡會出現單冒號 : 跟雙冒號 :: 的符號，\n單冒號開頭的是偽類 (pseudo class) ，\n雙冒號開頭的是偽元素 (pseudo element) 。\n\n一般常見的偽類有:\n1. 動態：:link、:hover、:active、:focus、:visited\n1. 元素狀態：:disabled、:enabled、:checked\n1. 結構：:root、:nth-child、:nth-last-child、:nth-of-type、:nth-last-of-type、:first-child、:last-child、:first-of-type、:last-of-type、:only-child、:only-of-type、:empty\n\n偽元素有:\n1. ::first-line：選取第一行\n1. ::first-letter：選取第一個字\n1. ::before：從選取元素的前面加入字串\n1. ::after：從選取元素的後面加入字串\n1. ::selection：選取文字反白後\n\n\n參考來源：\n[oxxostudioCSS 偽類 child 和 of-type](https://www.oxxostudio.tw/articles/201405/css-selector.html)","tags":["CSS"],"categories":["CSS"]},{"title":"Markdown語法","url":"%2F2019%2F05%2F29%2FMarkdown%E8%AA%9E%E6%B3%95%2F","content":"*Markdown*\n\nMarkdown 是一種輕量級標記式語言它有純文字標記的特性，讓編寫的可讀性提升不少。目前已有不少網站都使用 Markdown 來撰寫文件或是在網站上發表文章。\n\n現在來介紹幾個常用的語法:\n\n### 粗體\n\n語法\n`***bold***`\n顯示畫面\n***bold***\n\n### 標題字\n語法\n`# This is an tag`\n顯示畫面\n# This is an tag\n\n### 列表\n\n語法\n{% asset_img 1.png %}\n顯示畫面\n* item 1\n* item 2\n   * item 2a\n   * item 2b\n\n### 編號列表\n\n語法\n{% asset_img 2.png %}\n顯示畫面\n1. Item 1\n1. Item 2\n1. Item 3\n   1. Item 3a\n   1. Item 3b\n\n### CheckBox\n\n括號中的 x 就代表此項目是有勾選的，它並不會主動紀錄勾選過的內容，所以使用時要注意確認。\n\n`- [x] This is a complete item`\n`- [  ] This is an incomplete item`\n\n顯示畫面\n- [x] This is a complete item\n- [ ] This is an incomplete item\n\n\n### 區塊\n\n區塊分為小區塊跟大區塊，通常用於一段相關內容的撰寫，一小段文字或是註釋可用小區塊來表示，內容較多又不想跟一般段落內容混在一起的話，則會用大區塊來表示。\n小區塊語法：\n```\n`Format one word or one line`\n```\n大區塊語法：\n```\n    code (4 spaces indent)\n```\n顯示畫面：\n\n`Format one word or one line`\n\n    code (4 spaces indent)\n\n### 程式碼\n\n只要使用三個反引號加上語言簡稱就可以了。\n高亮程式碼顯示語法\n    \n````js\nvar n=1;\nvar b=2,c=3;\neval('a'+n+'=b*c');\n````\n    \n### 圖片\n\n插入圖片語法\n`![GITHUB](_圖片網址 \"圖片名稱\"_)`\n```\n{% asset_img Steve.jpg This is an image %}\n```\n![GITHUB](_圖片網址 \"圖片名稱\"_)\n{% asset_img Steve.jpg This is an image %}\n\n### 階層式區塊\n#### 階層式區塊在表現結構或功能關係上是相當好用的呈現形式\n語法：\n\n\\> Quote one sentences\n\\>>Quote two sentences\n\\>>Quote two sentences\n\\>>>Quote three sentences\n\n顯示結果：\n> Quote one sentences\n>>Quote two sentences\n>>Quote two sentences\n>>>Quote three sentences\n\n### Images\n\n![GitHub Logo](/images/logo.png)\nFormat: ![Alt Text](url)\n\n### Links\n\n語法\n`http://github.com - automatic!`\n`[GitHub](http://github.com)`\n\n顯示\nhttp://github.com - automatic!\n[GitHub](http://github.com)\n\n### Inline code\n\nI think you should use an\n`<addr>` element here instead.\n\n### Tables\n\n語法\n\nFirst Header | Second Header\n-----------------| ---------------------\nContent from cell 1 | Content from cell 2\nContent in the first column | Content in the second column\n\n顯示\n\nFirst Header | Second Header\n----------------- | ---------------------\nContent from cell 1 | Content from cell 2\nContent in the first column | Content in the second column\n\n\n\n參考來源：\n[Markdown - 易編易讀，優雅的寫文吧！ - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天](https://ithelp.ithome.com.tw/articles/10203758)\n[Mastering Markdown · GitHub Guides](https://guides.github.com/features/mastering-markdown/)\n[Markdown文件](https://markdown.tw/#autoescape)\n\n","tags":["Markdown"],"categories":["Markdown"]},{"title":"JavaScript eval()的用法","url":"%2F2019%2F05%2F29%2FJavaScript%20eval%2F","content":"eval() 是個滿好用的函式，用途也多種，常常會使用到。\n\neval 是 evaluates 。例如：\n```js\nvar n=1;\nvar b=2,c=3;\neval('a'+n+'=b*c');\n```\n\n上面結果會變成 a1=b*c ，就是變數 a1 的結果為 6。\n\n由以上可知，eval() 是把一組字串，當作指令來執行，並得出結果。\n實作時，在訂單處理上應用較廣，例如以下是份簡單訂單：\n\n數量 | 單價 | 小計\n-------|--------|------\nQ1  |  P1  |  T1\nQ2  |  P2  | T2\nQ3  |  P3  | T3\n\n用編號來進行不同筆數訂單欄位命名，而不是每個欄位獨立命名，顯示，在輸入數量及單價後，小計要能自動計算。\n\n假設這份表單名為 order，所以：\n\ndocument.order.T1.value=document.order.Q1.value\\*document.order.P1.value;\ndocument.order.T2.value=document.order.Q2.value\\*document.order.P2.value;\ndocument.order.T3.value=document.order.Q3.value\\*document.order.P3.value;\n\n你是不是會想用 for 來跑迴圈？可是，T1、;Q1 這些欄位名稱一直在變，怎麼跑迴圈呢？這時，eval() 就派上用場了，eval() 把「唸的內容」當結果執行，這個例子怎麼唸呢？\n\n「第一個 T 的值等於第一個 Q 的值乘以第一個 P 的值」，換成 \n\n```js\neval()：\nvar form=document.order;\nfor (var i=1;i<=3;i++){\n    eval('form.T'+i+'value=form.Q'+i+'value(form.P'+i+'value');\n}\n```\n把 eval() 裡的字串，i 的值分別用 1,2,3 套入，結果和前面寫一大串三行的效果一模一樣。\n\n參考來源：\n[icodding愛程式: JavaScript 的 eval() 用法介紹](http://icodding.blogspot.com/2015/12/javascript-eval.html)","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Hello World","url":"%2F2019%2F05%2F26%2Fhello-world%2F","content":"{% asset_img Steve.jpg This is an image %}\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]