[{"title":"webpack 介紹","url":"%2F2020%2F01%2F16%2Fwebpack-base%2F","content":"\n# webpack\n\nwebpack 在處理整個專案時，它會在內部建立一個依賴的關係圖，\n裡面記錄著每個頁面所需要用到的模組，並將每個模組綑綁成一個或多個來使用。簡單來說就是可以幫我們打包所有用到的 JavaScript 、SASS ... 等檔案，編譯後讓瀏覽器可讀取。另一個工具 gulp 跟 webpack 的差異在一個是協助自動化，另外一個是協助前端打包的。\ngulp 比較偏向命令式的編寫設定，也就是說所有的編譯動作的邏輯都要自己編寫，webpack 就偏向設定。\n\n## 安裝\n\n首先需要用 npm 安裝 webpack 與 webpack-dev-server, 如果你第一次裝，可以用 -g 安裝，以便在任何地方都可以使用該指令：\n\nwebpack //打包工具  \nwebpack-dev-server //即時產生一個 server 看執行結果  \n\n`npm install -g webpack webpack-dev-server`  \n\n\n接著安裝指令包 \n\n`npm install webpack-cli -g`\n\n## 專案使用\n\n1.建立專案資料夾 \n\n2.建立 NPM (參照 NPM 文件，記得移動到專案資料夾的目錄)\n\n `npm init`\n \n 按照資訊設定，產生 package.json 內容會像以下\n \n ```\n {\n  \"name\": \"my-project\",\n  \"version\": \"1.0.0\",\n  \"description\": \"this is my project\",\n  \"main\": \"app.js\",\n  \"repository\": {\n    \"type\": \"git\"\n    \"url\": \"http://github.com/npm/npm.git\"\n  },\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n }\n ```\n\n若想快速設定可用 `npm init -y`。設定結束後，會產生  package.json(設定紀錄檔)。\n \n scripts 屬性可以自訂指令名稱及執行指令，設定完後，輸入\n `npm run 指令名稱` 就可以執行了。\n \n建議可在 package.json 加入以下  webpack-dev-server   scripts\n \n\n```\n\"scripts\": {\n    \"dev\": \"webpack-dev-server --devtool eval --progress --colors --content-base build\"\n  },\n```\n\n--devtool eval: 將把 source 加到我的 code  \n--progress 與 --colors： 反應現今程序執行狀況  \n--content-base build： 將 build 裡的 index.html 作為啟始頁\n \n安裝 webpack 套件在專案資料夾裡：  \n`npm install webpack webpack-cli --save-dev`\n  \n3.用 NPM 安裝要使用的套件。安裝後的套件資訊，也會記錄在package.json 內。 \n \n紀錄的訊息會像是：\n \n開發的時候會用到的套件\n \n```   \n\"devDependencies\": {\n \"webpack\": \"^4.18.0\"\n \"babel-eslint\": \"^10.0.1\",\n \"eslint\": \"^5.16.0\",\n}, \n```\n\n上線發佈後依然需要用到的套件\n\n```\n\"dependencies\": {\n \"axios\": \"^0.19.0\",\n \"bootstrap\": \"^4.3.1\",\n \"jquery\": \"^3.4.1\",\n},\n```\n   \npackage.json 可以手動加入也可自動加入。  \n要自動加入的指令是 `--save-dev` ，在套件安裝時加上。  \n \ne.g.     \n`npm install webpack webpack-cli --save-dev` \n  \n \n4.建立 webpack.config.js 檔案，用來當作 webpack 的設定檔，檔名也不能亂取。  \n   \n檔案內容：\n\n\n## 使用 loader\n告訴 webpack，該如何處理匯入的檔案(編譯打包)，通常是 Javascript 但 webpack 不限於處理 Javascript，其他像是 Sass，圖片等也可處理，只要提供可處理的 loader。loader 的設定會寫在 module 的 rules 中。\n\n\n```\nmodule.exports = {\n    //如果有一個以上的檔案需要打包，可以傳陣列給entry\n    entry: ['./index.js', './app.jsx'],\n    output: {\n        filename: 'bundle.js',\n        path: path.resolve(__dirname, './'),\n    },\n    //將loader的設定寫在module的rules屬性中\n    module: {\n        //rules的值是一個陣列可以存放多個loader物件\n        rules: [\n            { test: /.jsx$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-react'] } } }\n        ]\n    }\n};\n```\n\nloader 物件屬性  \n>test：指定編譯檔案的副檔名為何，用正規表達式來尋找結尾處為.jsx的檔案。  \n\n>exclude：指定不編譯的路徑。\n  \n>use：指定用來編譯符合副檔名條件的loader，這個物件裡面還有兩個屬性：\n>>loader：指定進行編譯的套件  \n>>option：指定 loader 套件中的 presets 是什麼\n\n### 其他 loader 對應：  \n\n#### CSS\n\nCSS：style-loader、css-loader  \nSASS：sass-loader、node-sass\n\n安裝：\n`npm install --save-dev autoprefixer css-loader node-sass postcss-loader precss sass-loader style-loader`\n\n設定\n\n```\n// webpack.config.js\n\nmodule: {\n  rules: [\n    {\n      test: /\\.scss$/,\n      use: ['style-loader', 'css-loader', 'sass-loader']\n    }\n  ]\n}\n```\n\n使用\n\n```\n// ./src/index.js\nimport './styles/style.scss'\n```\n\n#### pic\nfile-loader、url-loader  \n\n\n`npm install --save-dev url-loader`\n\n設定\n\n```\n// webpack.config.js\n\nmodule:{\n  rules:[\n    // url loader (for image)\n    {\n      test: /\\.(jpe?g|png|gif|svg)$/,\n      use: [\n        {\n          loader: 'url-loader',\n          options: {\n            limit: 40000  /* 小於 40kB 的圖片轉成 base64 */\n          }\n        }\n      ]\n    }\n  ], \n  [\n  // file-loader\n      {\n        test: /\\.(woff|woff2|eot|ttf|otf)$/,\n        use: [\n          'file-loader'\n        ]\n      }\n   ]\n}\n```\n\n使用\n\n```\n// ./src/image-viewer.js\nimport midImgUrl from './../assets/mid.jpeg'\nimport minImgUrl from './../assets/min.jpeg'\n\n// midImg 會是被壓縮過的檔案名稱\nconst midImg = document.createElement('img')\nmidImg.src = midImgUrl\ndocument.body.appendChild(midImg)\n\n// minImg 是被注入在 bundle.js 中，可以直接使用\nconst minImg = document.createElement('img')\nminImg.src = minImgUrl\ndocument.body.appendChild(minImg)\n\nexport {midImg, minImg}\n```\n\n#### ES6 轉譯 ES5\nbabel-loader、babel-core、babel-preset-env\n\n`npm install --save-dev @babel/core @babel/preset-env @babel/preset-react babel-loader`\n\n設定\n\n```\n// webpack.config.js\n\nmodule: {\n  rules: [\n    // babel-loader\n    {\n      test: /\\.js$/,\n      exclude: /(node_modules|bower_components)/,\n      use: {\n        loader: 'babel-loader',\n        options: {\n          presets: [\n            [\n              '@babel/preset-env',\n              {\n                useBuiltIns: 'entry',\n                // targets: \"> 0.25%, not dead\"\n                targets: {\n                  chrome: '69'\n                }\n              }\n            ]\n          ] // End of presets\n        } // End of options\n      }\n    } // End of Babel\n  ];\n}\n```\n\n\n## 開啟本機伺服器\n\n在 webpack.config.js 中增加 devserver 的一些設定，例如要開啟的 port，如果沒有特別設定的話，port 的預設值為 8080，以下為了區隔所以設定 9000\n\n```\nconst path = require('path');\nmodule.exports = {\n    entry: ['./index.js', './app.jsx'],\n    output: {\n        filename: 'bundle.js',\n        path: path.resolve(__dirname, './'),\n    },\n    //將loader的設定寫在module的rules屬性中\n    module: {\n        //rules的值是一個陣列可以存放多個loader物件\n        rules: [\n            { test: /.jsx$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-react', '@babel/preset-env'] } } },\n            { test: /.js$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } }\n        ]\n    },\n    //增加一個給devserver的設定\n    devServer: {\n        //指定開啟port為9000\n        port: 9000\n    }\n};\n```\n\n## Plugin\n\n透過 `clean-webpack-plugin` 可以每次打包前都清除特定資料夾。\n\n安裝\n\n`$ npm install clean-webpack-plugin --save-dev`\n\n```\n// webpack.config.js\n\nconst path = require('path')\nconst CleanWebpackPlugin = require('clean-webpack-plugin')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new CleanWebpackPlugin(['dist']),\n    // ...\n  ]\n}\n```\n\n## 指令(命令提示字元下 or 終端機輸入) \n\n### 看版本\n\n`webpack -v`\n\n### 打包\n\n`webpack -p`\n\nor\n\n`npm run start`\n\n### 開啟本機伺服器\n\n`webpack-dev-server`\n\n執行完後，打開瀏覽器輸入 http://localhost:9000 ，關閉 `webpack-dev-server` 開啟的 port，在命令提示字元的畫面上輸入 Ctrl+C。\n \n參考：  \nhttps://webpack.js.org/concepts/#entry  \nhttps://ithelp.ithome.com.tw/articles/10200329  \nhttps://ithelp.ithome.com.tw/articles/10200459?sc=pt  \n[Webpack 學習筆記（Webpack Note）](https://pjchender.github.io/2018/05/17/webpack-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88webpack-note%EF%BC%89/)","tags":["webpack"],"categories":["webpack"]},{"title":"jQuery 簡單介紹","url":"%2F2020%2F01%2F16%2FjQuery-base%2F","content":"\n# jQuery 簡單介紹\n\nJavaScript 的 Library，jQuery 主要是用在 DOM 文件操作，包含快速選取元素(Element)與執行事件，例如隱藏元素、顯示元素等等。此外 jQuery 的核心程式還加強了非同步傳輸(AJAX)以及事件(Event)的功能。\n\n## 使用 jQuery\n\njQuery 用 `$(selector).action()` 格式，指派元素到指定的事件。詳細來說， `$(selector)` 會呼叫 jQuery 選取 selector 元素，並指派它到稱作 `.action()` 事件。回傳值是 Array。可以直接用 for 或是 foreach 迴圈去處理。\n\ne.g.\n\n`$(\"div\").addClass(\"special\");`  \n\n範例是將先前所選取到的 `<div>` 元素都加上一個名為 \"special\" 的 class。\n\n記號 `$` 是被當成 jQuery 的縮寫。等同，\n\n`jQuery(\"div\").addClass(\"special\");`\n\n另一個例子\n\n```\n$(document).ready(function(){  \n   // 等所有的 HTML 都載入，且 DOM 都以建構完成執行 { } 內容，將所有 function();\n   // 放入裡面是常見做法\n  alert(\"Hello World!\");         \n  $(\"#blackBox\").hide();\n});\n```\n\n上面這段 jQuery 程式碼，會執行與這段原生 JavaScript 程式碼相同的事情：\n\n```\nwindow.onload = function() {\n  alert( \"Hello World!\" );\n  document.getElementById(\"blackBox\").style.display = \"none\";\n};\n```\n### 選取元素\n\n#### 選取所有 `<div>` 元素\n\n`$(\"div\")`\n\n#### 選取 id 為 menu 的元素\n\n`$(\"#menu\")`\n\n#### 選取 class 為 content 的元素\n\n`$(\".content\")`\n \n#### 選取 id 為 body 的 `<div>`\n\n`$(\"div#body\")`\n\n#### 選取 class 為 content 的 `<div>` 所包住的所有內層的 `<p>`\n\n`$(\"div.content p\")`\n\n#### 取得第index個子節點: eq(index)\n\n`$('ul').children.eq(3).text();`  //取得第三個子節點\n\n#### 利用屬性內容找節點\n\n`$(\"input[name='A']\");` //找出 name 屬性為 'A' 的 input\n\n### 操作元素\n\n#### 讀取和修改一個元素的HTML內容: html()\n若是多個元素，只能讀取第一個元素的內容\n\n讀取 `<p>` 元素的內容\n\n`$(\"p\").html();`\n\n修改 `<p>` 元素的內容\n\n`$(\"p\").html(\"Hello <b>world</b>!\");`\n\n#### 讀取和修改一個元素的純文本內容: text()\n\n讀取 Element 的文本內容\n\n`$(\"Element\").text();`\n\n修改 Element 的文本內容，Element 的 content 是 `Hello <b>world</b>!` 是文字格式，不是標籤元素\n\n`$(\"Element\").text(\"Hello <b>world</b>!\");`\n\n\n#### 讀取和修改一個表單元素的 value 值: val()\n若是多個元素，只能讀取第一個元素的內容。要使用 for 或 each 來讀取多個。\n\n讀取  \n\n```\n//  讀取每一個被 checked 的值\n$('input:checkbox[name=size]:checked').each(function()\n  {\n   alert($(this).val());\n  });\n```\n\t\t\t\t        \n修改\n\n`$(\"Element\").val(value);`\n\n#### 元素節點末端加入純文字或 HTML 語法(增加元素): append\n\n```\n// 選取所有有 target 屬性的 `<a>`，並且在其節點下加入一段文字。\n$(\"a[target]\").append(\"(Opens in New Window)\");\n```\n\n#### 元素節點前端加上純文字或 HTML 語法(增加元素): prepend()\n\n`$(div).prepend(\"first\");`\n\n#### 修改 css 屬性: css\n\n`.css('border','3px solid red')`\n\nor\n\n```\n$(\"#body\").css({  \n  border: \"1px solid green\",  \n  height: \"40px\"  \n});  \n```\n\n#### class的新增: addClass()\n\n`$(\"#test\").addClass(\"aaa\");`\n\n#### class的移除: removeClass()\n\n`$(\"#test\").removeClass(\"aaa\");`\n\n移除多個\n\n`$(\"#test\").removeClass(\"aaa bbb\");`\n\n### 事件\n\n事件寫法有兩種 \n\n`$(selector).click(function(){})`\n\nor\n\n`$(selector).on('click', function(){})`\n\nor\n\n// 動態綁定\n`$(selector).on('click', selector, function(){\n})`\n\nps. 補充有說明兩種的不同\n\n#### 點選元素: click\n\n```\n//當 user 點選 id 為 open 的連結時，顯示 id 為 menu 的區塊，並回傳 false 避免瀏覽器真的換頁。\n$(\"a#open\").click(function() {  \n  $(\"#menu\").show();  \n  return false;  \n});\n\nhtml\n\n<style type=\"text/css\">  \n  #menu {display: none}  \n</style>  \n<a id=\"open\" href=\"#\">menu</a>  \n<ul id=\"menu\">  \n  <li><a href=\"#1\">a</a></li>  \n  <li><a href=\"#2\">b</a></li>  \n  <li><a href=\"#3\">c</a></li>  \n</ul>    \n```\n\n#### 失焦並且內容改變: change()\n\n``\n\n#### 聚焦: focus()\n\n```\n$(\"input\").focus(function(){\n  $(\"input\").css(\"background-color\",\"#FFFFCC\");\n});\n```\n\n#### 失焦(滑鼠游標移開): blur()\n\n```\n$(\"input\").blur(function(){\n  $(\"input\").css(\"background-color\",\"#D6D6FF\");\n});\n```\n\n#### 加上鍵值: keyup()\n\n```\n('#target').keyup(function(event) {\nif (event.keyCode == '13') {\n  event.preventDefault();\n  ...\n  }\n  ...\n})  \n```\n\n#### 表單送出: submit\n\n```\n//在網頁上的表單送出時加入一個判斷，如果 username 這個欄位是空值的話，就顯示 help 這個區塊內的文字。\n$(\"form\").submit(function() {  \n  if ($(\"input#username\").val() == \"\")  \n    $(\"span.help\").show();  \n});\n\nhtml\n\n<style type=\"text/css\">  \n  .help {display: none}  \n</style>  \n<form>  \n  <label for=\"username\">請輸入姓名</label>  \n  <input type=\"text\" id=\"username\" name=\"username\" />  \n  <span class=\"help\">此欄位為必填</span>  \n</form>  \n  \n```\n\n#### 布幕動態效果: slideDown\n\n```\n$(\"#menu\").slideDown(\"fast\");\n\nhtml\n\n<style type=\"text/css\">  \n  #menu {display: none}  \n</style>  \n<ul id=\"menu\">  \n  <li><a href=\"#1\">a</a></li>  \n  <li><a href=\"#2\">b</a></li>  \n  <li><a href=\"#3\">c</a></li>  \n</ul>  \n```\n\n#### animate 函數\n\n```\n//將所有的 <div> 漸變為寬 300px、文字與邊界寬 20px\n$(\"div\").animate({  \n    width: '300px',  \n    padding: '20px'  \n  }, 'slow');  \n\nHTML\n\n<div style=\"width: 100px; border: solid 1px red;\">  \n  Hello world!  \n</div>  \n```\n\n#### 顯示: show()\n\n`$('.target').show(); //顯示target`\n\n#### 隱藏: hide()\n\n```\n/*所有的 <div> 以 0.5 秒的動態效果隱藏後，再以 0.5 秒的動態效果顯示。hide() 的第二個參數就是一個 callback 函數，其中 $(this) 是原本程式所處理的各個元素。*/\n$(\"div\").hide(500, function(){  \n  // $(this) 是每一個別的 <div>  \n  $(this).show(500);  \n});  \n\nHTML\n\n<div style=\"width: 100px; border: solid 1px red;\">  \n  Hello world!  \n</div>  \n<div style=\"width: 100px; border: solid 1px red;\">  \n  jsGears.com!  \n</div>  \n```\n\n#### 切換: toggle()\n\ntoggle() 方法用於綁定兩個或多個事件處理器函式，以響應被選元素的輪流的 click 事件。該方法也可用於切換被選元素的 hide() 與 show() 方法。\n\n```\n// 切換背景色\n$(\"p\").toggle(\n  function(){\n  $(\"body\").css(\"background-color\",\"green\");},\n  function(){\n  $(\"body\").css(\"background-color\",\"red\");},\n  function(){\n  $(\"body\").css(\"background-color\",\"yellow\");}\n);\n```\n\n```\n// 按下 Hello 元素第一次會文字會是綠，第二次會是藍色\n$('#mydiv').toggle(\n\tfunction(){\n\t  $(this).css({\"color\": \"green\"});\n\t},\n\tfunction(){\n\t  $(this).css({\"color\": \"blue\"});\n\t},\n);\n\nhtml \n\n<div id=\"mydiv\">Hello</div>\n```\n\n### Ajax\n\n#### ajax\n\n```\n$.ajax({\ntype: \"GET\", //指定method\n url: 'ajax/test.html',\n success: function(data) {\n  $('.result').html(data);\n  alert('Load was performed.');\n  }\n});\n```\n\n#### 取得 HTML: load()\n\n`$(\"#htmDoc\").load(\"test.html\");`\n\n#### 取得 XML 格式的資料\n\n```\n$.get(\"test.xml\",function(xml){\nvar text = $(\"title\",xml).text();\n$(\"#xmlDoc\").html(text);\n});\n```\n#### 取得 TXT 格式的資料\n\n```\n$.get(\"test.txt\",function(txt){\nalert(txt);\n});\n```\n\n#### 取得 JSON 格式的資料: getJSON()\n\n```\n\n$.getJSON(\"test.json\", function(data){  \n  for (var idx in data)  \n    $(\"#menu\").append(\"<li>\" + data[idx] + \"</li>\");  \n});  \n\nHTML\n\n<ul id=\"menu\">  \n  <li>a</li>  \n</ul>  \n\ntest.json\n\n[  \n  \"Hello world!\",   \n  \"jsGears.com!\"  \n]  \n```\n\n### 連續使用函數\n\n如果想將所有的 `<div>` 隱藏，並修改文字顏色，再用布幕動態效果顯示出來的話，可用下方程式碼處理：\n\n```\n$(\"div\").hide();  \n$(\"div\").css(\"color\", \"green\");  \n$(\"div\").slideDown();  \n```\n\n上方三行程式碼可簡化成  \n\n`$(\"div\").hide().css(\"color\", \"blue\").slideDown();`\n\n另一個範例：\n\n選取第三個 `<li>` 加上 5px 的紅色邊框，並在 `<li>` 裡面加上文字 A\n`$('li:nth-child(3)').css('border','5px solid red').append('A');`\n\n### jQuery plugin 應用\n\n1. 下載 jQuery 的 js 和要使用的 plugin\n\n2. 打開 HTML 檔，在 `<header>` 加上 `<link>`，分別為套件的 `*.css` 與自己的 `*.css` 檔\n\n e.g. \n\n `<link rel=\"stylesheet\" href=\"css/flexslider.css\" type=\"text/css\" media=\"screen\" />`\n\n 在 body 加上官網上給的使用語法\n\n 在 `</body>` 之前 加上 `jquery.min.js`、套件的`*.js`檔與套件使用的 js 語法。\n\n e.g.\n\n `<script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"></script>`\n\n依照套件的教學及範例，基本上就可以使用了。\n\n## document ready 事件\n\n有時，在網頁下載完成後，要立即執行一些程式的話。可以用 window.onload 來處理，或是直接在 `<body>` 標籤上加入 onload 的事件處理函式。 jQuery 提供了 .ready() 來處理這類情況。\n\ne.g. \n\n```\n// 網頁下載完成後立即執行 alert()\n$(document).ready(function() {  \n  alert('Hello');  \n});\n```\n\njQuery 的 document ready 事件是模擬 W3C DOM 標準的 DOMContentLoaded 事件，DOMContentLoaded 和 window.onlad 的差異在於前者是在 DOM 文件下載完成後觸發，而後者是文件和所有文件內的元件，包含圖檔等等全部下載完成後才會觸發。因此通常 window.onload 的發生時間要比 DOMContentLoaded 晚一點。  \n\n而 DOMContentLoaded 和 window.onload 的另一個差異在於 window.onload 並沒有辦法多次指定不同的函數來執行，最後指定的那個函數會複寫掉先前的。但 jQuery 的 document ready 函數並不會有覆寫的情況發生。\n\n\ndocument ready 函數也有更精簡的寫法，如下：\n\n```\n$(document).ready(function() {  \n  alert('Hello');  \n});\n```\n\n可改寫成\n\n```\n$(function() {  \n  alert('Hello');  \n}); \n```\n\n## 別名\n\njQuery 本身提供一個函式來避免 `$()` 的衝突，使用 jQuery 函式前，加上 `jQuery.noConflict();`\n\n\n```\njQuery.noConflict();\n$(document).ready(function() {  \n  alert('Hello');  \n});\n```\n或是另外設定名稱\n\n```\nconst $j = jQuery.noConflict();\n$j(document).ready(function() {  \n  alert('Hello');  \n});\n```\n\n## 補充\n\n### .click(function()) 及.on('clcik',function())，這兩者間到底有什麼不一樣？\n\n```\n <ul>\n    <li><span>click me</span></li>\n    <li><span>click me</span></li>\n    <li><span>click me</span></li>\n </ul>\n```\n\n***.click(function())  \n若是使用`$('li span').click(function(){alert('hi')});`的話，它只對於你現在 HTML 上所指定的全部元素進行事件綁定，\n如果你在後來透過 jQuery 或其他方式所增加的元素都不會出現在這個事件所綁定的範圍裡，所以 .click 是沒有辦法幫助你做到動態的事件綁定。***  \n\n***.on  \n基本上 .click 能做到的事情，透過.on('click')的方式一樣都能做到，但是 .on() 能做到動態事件綁定，以上述的例子而言，我們可能會寫 `$('li span').on('click',function(){alert('hi')});`\n這時你會發現，在動態事件這種方式會跟上述的.click事件處理方式一樣沒反應，那到底 .on() 要怎麼做到動態事件綁定？.on()方法有提供第二個參數「childSelector」\n` $('li').on('click','span',function(){alert('hi')});` childSelector 的原理就是事件冒泡 event bubbling ，在你點擊子元素 span 時，子元素 span 一樣是在父元素 li 裡面，所以你樣是有點擊到父元素 li，而事件的傳遞會從子元素先發生接著向父元素傳遞，但是實際上我們這邊事件一樣是綁定在父元素 li 上，所以它會再去而找到相對應的子元素，來進行事件處理。這兩者間最大的差異，大概就在動態事件處理上，當然還有像是一些小差異像是***    \n\n***.on() 所佔用的記憶體會比.click還少  \n.on() 為Namespaced Events，可以做到事件命名的管理。***  \n\n***一般來說，如果不會用到 append ... 等這些插入元件控制用的語法。使用第三個程式寫法就行了，不需要用到 on 處理。在某些情況下，on 最好還是少用。不得已非要用到的情況才去使用它會比較好。***\n\n***\n\n### blur 事件會觸發兩次\n\n***jQuery 解決使用 blur 事件時，會觸發兩次的問題 (好像用 focus 事件也會)。因為在綁定 onblur 事件的時候都會被觸發兩次，原因不明.....網路上有找到解法，但好像不是用 on 來綁，是用一般的 blur(無法動態綁定)，若是 dom 都是動態產生的，這個沒法用。***\n\n***可用此方式試試***\n\ne.g.\n\n***`$('#gradeUpdate').blur()`***\n\n***改成這樣就可以了***\n\n***`$('#gradeUpdate')[0].blur()`***\n\n參考：  \nhttps://jquery.com/    \nhttps://www.j2h.tw/bbs/bbs16/511.html  \nhttps://developer.mozilla.org/zh-TW/docs/Glossary/jQuery  \nhttps://ithelp.ithome.com.tw/articles/10197512  \nhttp://greenkm.blogspot.com/2016/03/jquery_8.html  \nhttps://jjnnykimo.pixnet.net/blog/post/21585448  \nhttps://felixx.pixnet.net/blog/post/36966403\nhttp://shioulo.eu5.org/node/256  \nhttps://sweeteason.pixnet.net/blog/post/42677633-jquery-%E8%A7%A3%E6%B1%BA%E4%BD%BF%E7%94%A8-blur-%E4%BA%8B%E4%BB%B6%E6%99%82%EF%BC%8C%E6%9C%83%E8%A7%B8%E7%99%BC%E5%85%A9%E6%AC%A1%E7%9A%84%E5%95%8F  \nhttp://skaih.logdown.com/posts/712464-jquery-click-on-the-where-different  \nhttps://ithelp.ithome.com.tw/questions/10191601  \nhttps://www.w3cplus.com/blog/134.html","tags":["jQuery"],"categories":["jQuery"]},{"title":"Sass 基本介紹","url":"%2F2020%2F01%2F16%2FSass-base%2F","content":"\n## Sass\nSass(Syntactically Awesome StyleSheets) 是種 CSS 的擴充，經過編譯(compiled) 成 CSS 檔，讓瀏覽器可讀取。解決了專案 CSS 遇到的重複、可維護性差等問題。bootstrap 也有使用 Sass。\n\n\n## 格式寫法\n{% asset_img Sass.png This is an image %}  \n\n### SCSS\n用大括號跟分號來區分段落，多數人使用，與 CSS 語法相近。\n\ne.g.\n\n```\n<ul class=menu> \n<li><a href='#'>1234</a></li>\n\n.menu {\n  li {\n    font-size: 30px;\n    a {\n    color: red; \n     }\n  }  \n}\n\ncompiler:\n\n.menu li {\n  font-size: 30px;\n}\n.menu li a {\n  color: red;\n}\n```\n\n### SASS\n使用排縮跟斷行來區分。\n\ne.g.\n\n```\n<ul class=menu> \n<li><a href='#'>1234</a></li>\n\n.menu\n  li \n    font-size: 30px\n    a\n    color: red    \n```\n\n## Sass 轉成 CSS 方式(透過編譯)\n\n編譯順序是從上到下\n\n### 軟體編譯\n1. https://sass-lang.com/install 安裝 Sass  \n\n2. Prepros：免再安裝其它軟體即可編譯 Jade/SASS  \n1.下載：https://prepros.io  \n2.安裝好之後就拖曳網站資料夾(根目錄)到 prepros 拖曳後產生兩個欄位，左邊是網站資料夾，右邊是 檔案清單、Log、FTP、軟體設置，最重要的就是 Log，他會顯示SASS紀錄，當SASS無法轉成CSS時，他會有紀錄，方便看程式是否哪邊有問題?  \n3.而且他會在資料夾產生一個 prepros-6.config，如後續沒有要用到 SASS，網站完成後可以刪掉，如果要再用 SASS 輸出成 CSS 要再重新拖曳檔案到 prepros 讓他讀取該資料夾繼續編譯 SASS。  \n4.新增 Scss 和 css 資料夾：開始寫 SCSS 之前，先在網站資料夾新增 Scss 和 CSS 資料夾，SCSS檔案存在同名資料夾，SCSS 檔案儲存時，電腦桌面會出現編譯成功的小視窗，CSS 資料夾會出現一個 CSS的檔案。\n\n### 打包：gulp / webpack\n \n### 編輯器內建插件編譯\nVSCode 套件：Live Sass compiler \n\n1. 在 vscode 安裝  Live Sass compiler 插件。\n2. 產生專案資料夾，在專案資料夾內新增 Scss 資料夾。新增一個 all.scss 文件。程式視窗下方，會啟用 Live Sass compiler 程式。有 Watch Sass 字樣。寫完 Scss 後，點擊  Watch Sass 字樣，會產生 all.css 跟 all.css.map 至預設的資料夾內，且每一次儲存檔案都會自動編譯一次。想要停止即時編譯的狀態，點擊視窗下方的「Watching…」即可停止。\n\n預設的情況編譯產生的 CSS 將會被放置在與 SCSS 檔案同層的資料夾內，要指定 CSS 輸出路徑或輸出形式，可依照以下的步驟來設定。\n\n#### 指定輸出CSS的路徑\n於檔案總管內另外新增一層名為 css 的資料夾，接著進入 VSCode 的喜好設定 -> 設定，可直接將以下的程式碼複製並貼到區塊存檔：\n\n```\n\"liveSassCompile.settings.formats\":[\n    {\n\"savePath\": \"/css\"\n    }\n  ]\n```\n\nLiveSassCompile.settings.formats：可用於調整 Live Sass Compiler 外掛相關的屬性設定。  \nsavePath：輸出後的 CSS 檔存放資料夾。\n\n#### 更改輸出樣式\nLive Sass Compiler 支援以下四種輸出樣式：  \n1. expanded(預設)  \n2. compact  \n3. compressed (去除檔案所有空格及縮排) // 常見\n4. nested    \n將以下的程式碼貼入設定檔，並存檔。\n\n```\n{\n    \"liveSassCompile.settings.formats\":[\n        {\n            \"format\": \"compressed\",\n            \"savePath\": \"/css\"\n        }\n    ]\n}\n```\n## Sass 使用\n\n### 巢狀(nesting)\n透過巢狀式的結構也可以清楚的知道元素上下層的關聯性。\n\ne.g.\n\n```\n.box{\n  width: 100%;\n  margin: 0 auto;\n  .title{\n    padding: 10px;\n    p{\n      color: rgba(255, 0, 0, 1);;\n    }\n  }\n}\n```\n編譯成 CSS 就會變成\n\n```\n.box{\n  width: 100%;\n  margin: 0 auto;\n}\n.box .title{\n  padding: 10px;\n}\n.box .title p{\n  color: rgba(255, 0, 0, 1);;\n}\n```\n\n還有一個方便的功能是使用 & 符號來代替父層(上層)\n\n```\n.box{\n  color: rgba(0, 0, 0, 1);\n  &:hover{\n      color: red;\n  }\n}\n```\n編譯後\n\n```\n.box{\n  color: rgba(0, 0, 0, 1);\n}\n.box:hover{\n  color: rgba(255, 0, 0, 1);\n}\n```\n\n\n### 變數(Variable)\n`$` 來表示變數，變數可以用來儲存值，方便重複利用。時常需要設定的 CSS 可設為變數。  \n\n$變數名: 樣式;\n\ne.g.\n\n```\n$box-shadow: 10px 10px 5px rgba(0, 0, 0, 1);\n\n.box{\n  box-shadow: $box-shadow;\n}\n```\n\n變數也能拿來做運算，格式有\n>數字：10、1px、3em   \n>字串：’test’、\"../images/big/\"  \n>顏色：red、#000000、rgba(255,255,255,0.9)  \n>布林：true、false  \n>空值：null  \n\n```\n$num:5px;\n.container{\n  margin:$num*2 $num;\n}\n```\n\n集合變數\n\n```\n$themes: (\n   //key, value\n   'primary': blue;\n   'danger': red;\n   'secondary': orange;\n);\n\n.box-primary {\n   background-color: map-get($themes, 'primary');  \n}\n```\n\n## 混合(mixin)\n函式可以使用在重複多行的樣式上面，像是 CSS 的一些新屬性就可能需要加上瀏覽器前綴，這個部分就可以透過函式來完成，要特別注意的是：  \n`@mixin`需要配合 `@include` 來使用  \n`@mixin`來設定要使用的樣式、`@include`則是套用樣式\n\n```\n@mixin css3-border-radius() { \n  -ms-border-radius: 5px;\n  -moz-border-radius: 5px; \n  -webkit-border-radius: 5px; \n  -o-border-radius: 5px; \n  border-radius: 5px; \n}\n.box {\n@include css3-border-radius();\n}\n```\n編譯後\n\n```\n.box {\n  -ms-border-radius: 5px;\n  -moz-border-radius: 5px;\n  -webkit-border-radius: 5px;\n  -o-border-radius: 5px;\n  border-radius: 5px;\n}\n```\n\n函式也可以搭配參數使用讓使用上更加靈活。\n\n```\n@mixin css3-border-radius($i) { \n  -ms-border-radius: $i;\n  -moz-border-radius: $i; \n  -webkit-border-radius: $i; \n  -o-border-radius: $i; \n  border-radius: $i; \n}\n.box {\n@include css3-border-radius(3px);\n}\n```\n\n### 導入(import)\n在檔案中加入其他SCSS或CSS檔案，最後編譯時會一併編譯。假如我想在某個SCSS檔案裡面匯入 head、main、footer 等 SCSS 的檔案就可以使用下面這段程式碼\n\n`@import \"head.scss\";`  \n`@import \"main.scss\";`    \n`@import \"footer.scss\";`    \n\n### 繼承(Extend)\n`@extend` 主要是用在合併相同程式碼，假如有很多段相同的程式碼就可以使用 `@extend` 進行合併，只要加上站位符號 `%` 就能讓被繼承的 CSS 類消失。\n\n\n```\n%box {\n  border: 1px solid rgba(0, 0, 0, 1);\n  padding: 10px;\n  color: rgba(0, 0, 0, 1);\n}\n\n.success {\n  @extend %box;\n  border-color: rbga(0, 128, 0, 1);\n}\n\n.danger {\n  @extend %box;\n  border-color: rgba(255, 0, 0, 1);\n}\n```\n\n\n編譯後\n\n```\n.success, .danger{\n  border: 1px solid black;\n  padding: 10px;\n  color: black;\n}\n\n.success{\n  border-color: rgba(0, 128, 0, 1);\n}\n\n.danger{\n  border-color: rgba(255, 0, 0, 1);\n}\n```\n### 函式(Functions)\nSCSS 中也有 `@function` 可以使用，像是 `@if`、`@for`，可以查看內建函式的清單\n\n```\n.box {\n     background-color: $i;\n   }\n}\n\n@for $i from 1 through 5 {     // 包含 5 有 1-5\n   .box-#($i) {\n     background-color: $i;\n   }\n}\n```\n\n#### @for\n\n`@for $i from 1 to 5{}`  \n`@for $i from 1 through 5{}`\n\n先用 `@for` 啟用此功能，再來用 `$` 設立一個變數i(可自訂但通常慣用 i )，再來 from 1 to 5 的意思是，`$i` 這個變數，從 1 開始逐步替換到 4(不包含 5 )，若要需要包含 5，用 through，所以就會寫成 `@for $i from 1 through 5{}`，這樣才 `$i` 才是從 1逐步的替換到 5，然後在 `@for` 最後面的大括弧內寫上要替換的對象(選擇器)以及條件(語法)，如下：\n\n```\n@for $i from 1 through 5{\n  .box#{$i}{\n    background:darken(red,$i*5%);\n  }\n}\n```\n\n假設這個簡單的案例是有五個 `.box`，從 `.box1` ~ `.box5`，然後分別用 darken 來加深他們的 background 顏色，首先先在 `.box` 後面緊接著 `#{$i}`，讓他變成 `.box#{$i}`，變數 `$i`一定要先用 `{}` 包起來，然後在前面再加一個 `#` 字，這樣 `.box` 就會被逐步的迭代成  `.box1`、`.box2`到 `.box5` 了。\n\n一個簡單的 `@for` 就可以一次給五個 class 效果，接著看後面的 background，我們給它的值是利用 darken 功能，再來後面接條件 `(red,$i*5%)`，寫成`background:darken(red,$i*5%);`，利用 `@for` 的迭代功能，就可以把 background 分別改成 `darken(red,$5%、10%、15%、20%、25%);`。\n\n#### @each\n\n迭代變數內容\n\ne.g.\n\n```\n$list: (orange, purple, melon);\n\n@each $item in $list {\n.#{$item} {\n  background: $item;\n  }\n}\n```\n\n```\n@each $key, $value in $themes {\n   .box-#($key) {\n    background-color: $value;\n  }\n}\n```\n\n### 註解(Comment)\n只要在程式碼開頭加上兩條斜線 `//` 就可以加入註解。\n\n### @mixin 整理 CSS 應用\n\n將 CSS 功能寫成 @mixin 再 @include 到使用該功能的標籤元素。\n\ne.g.\n\n#### 圖片取代文字\n\n```\n@mixin hide-text{\n   text-indent: 110%;\n   white-space: nowrap;\n   overflow:hidden;    \n}\n```\n#### 用 CSS 畫各方向的三角形\n\n##### 用 CSS 畫圓\n\n```\n@mixin circle($size,$bgcolor) {\n   border-radiu: 50%;\n   height: $size;\n   width: $size;\n   font-size: $size/3;\n   background: $bgcolor;\n}\n\n.box {\n  @include circle(30px,#fff)\n}\n```\n\n#### @mixin + import 應用\n\n##### CSS 分類、整合\n \n_variable.SCSS  //變數整理  \n_reset.SCSS     //樣式清空，bootstrap 用 normalize.css(會保有瀏覽器預設樣式)    \n_mixin.SCSS     CSS 功能  \n_main.SCSS        \n\n合成  all.scss (內容 @import 上述 .SCSS 檔)\n\n```\n@import \"variable\";\n@import \"normalize\";\n@import \"mixin\";  //or  @import \"mixin/mixin\";\n// 主要CSS\n@import \"main\";\n```\n\n#### @mixin + RWD\n響應式處理 @media RWD @mixin + content \n\n```\n@mixin desktop-below{\n   @media (max-width: 1023px){\n      @content\n  }\n}\n\n@mixin pad{\n   @media (max-width: 768px){\n      @content\n  }\n}\n\n.header {\n  width: 500px;\n  @include pad{\n     width: 13px;       // pad{content 內容)}    \n     font-size: 20px; \n   };\n}\n\n\n@mixin mobile{\n   @media (max-width: 568px){\n      @content\n  }\n}\n\n.header {\n  width: 500px;\n  @include pad{\n     width: 13px;       // pad{content 內容)}    \n     font-size: 20px; \n   };\n  @include mobile{\n     font-size: 8px;\n   };\n}\n```\n\n## SASS 設計模式簡單介紹\n\n### SMACSS\n\n結構分類：Base、Layout、Module、State、Theme。  \n命名規則：id 與 class 受限制地使用、名稱使用 dash 分隔。\n結構的分類存在模糊界線。\n\n\n### OOCSS\n\nObject Oriented CSS，範例是 Bootstrap。\n\n1. 結構(header)與樣式(header-shadow)分離\n\n```\nhtml\n\n<div class=\"header header-shadow\"></div>\n\ncss\n.header {\n width: 200px;\n height: 100px;\n}\n.header-shadow {\n  box-shadow: 10px 10px 10px #000;\n}\n```\n\n```\n<button class=\"pure-button pure-button-primary\">btn</button> \n```\n\n2. 容器與內容分離\n\n{% asset_img SASS2.png This is an image %}  \n\n### BEM\n\n由 Yandex 團隊提出來命名 Class 名稱的設計模式，\nBEM 的意思是區塊(Block)、元素(Element)、修飾符(Modifier)。\n以元件觀念進行開發，具有重用性。\n\n```\n<ul class=\"menu\">\n    <li class=\"item active\"><a href=\"#\"></a></li>\n    <li class=\"item\"><a href=\"#\"></a></li>\n</ul>\n```\n\n變成\n\n```\n<div class=\"product\">\n    <div class=\"menu\">\n        <li class=\"menu__item menu__item--active\"><a href=\"#\"></a></li>\n        <li class=\"menu__item\"><a href=\"#\"></a></li>\n    </div>\n</div>\n```\n\n`.block{}` //區塊 (Block)  \n`.block__element{}` //元素(Element)  \n`.block--modifier{}` //修飾符(Modifier)  \n\n#### 區塊 (Block)  \n我們在設計網站時，一定會設計幾個區塊(Block)出來，如下圖表頭裡面有 LOGO 、選單、搜尋框、登入視窗等等，這樣才能方便移動整個區塊到對應位置，這時候我們就會用 class 命名他們區塊對應的語意，例如`.menu`、`.logo`、`.search`、`.auth`。 \n\n{% asset_img Sass3.png This is an image %}  \n\n#### 元素 (Element)\n再來我們深入 menu 的區塊，你可以看到下圖選單內有四個元素，如果這些元素設定是會綁定在這個區塊上時，就可以在區塊的 class 後面加上雙下底線 `__` 來辨識他是該區塊底下的元素，class 就會設計為 `.menu__item{}`。  \nPS：除了HTML tag外，如果是一個 CSS 組件也可把它視為元素 (Element) 。\n\n{% asset_img Sass4.png This is an image %}  \n\n#### 修飾符（Modifier）\n修飾符（Modifier）的觀念和 SMACSS 的 State Rules 很相似。當區塊或元素因為狀態而改變時，就在後面加上雙中線--來辨識它是修飾符，像是下圖選單的部份，當被點選時為了要讓使用者了解該元素有被點選，所以就會用 javascript 動態加入 class 為 `.menu__item--active`，所以如果我們要判斷這個 class 是屬於元素還是修飾符的設定，就只要看 class 最後面是雙中線 `--` 還是雙下底線 `__` 就知道他是屬於哪一種了。\n\n{% asset_img Sass5.png This is an image %}  \n\n#### BEM + Sass\n\n```\n.list{}\n.list__title{}\n.list__img{}\n.list__img—changebg{}\n\n.list {\n   &__title {\n  }\n   &__img {\n      height: 50px;\n      &—changing {\n\n     }\n  }\n```\n\n## CSS 命名\n\n`.bookList { }` 比較好懂  \n`.bookList-title { }`  //bookList 下的 title\n`.bookList_title { }`  //跟 `.bookList-title {}` 一樣，保持一致就好。\n\n拋棄語意命名方式，改以工具性質來命名。容易重複利用  \n`.list{}`  \n`.list_title{}`  \n顏色，不要直接用顏色來命名  \n`.textcolor {color: green;}`  \n利用格線系統來命名  \n`.col_3 {}`\n\n\n\n***ps.    \nSass的檔名如果在最前面加上 `_` 就不會被轉譯工具輸出成CSS檔案(例如：_base.scss)，可用時單純匯入、整合 Sass 檔***\n\n***reset.css    \nhttps://meyerweb.com/eric/tools/css/reset/\nCSS 前掛上這一段「Reset CSS」的語法，樣式會全部清空，處理各大瀏覽器的差異。用 @import 來引用 reset.css。***\n    \n***normalize.css 會保有瀏覽器預設樣式。***\n\n\n\n\n\n\n參考：  \nhttps://blog.techbridge.cc/2017/06/30/sass-scss-tutorial-introduction/  \nhttps://ithelp.ithome.com.tw/articles/10132821  \nhttps://ithelp.ithome.com.tw/articles/10203396?sc=iThelpR\nhttps://medium.com/@enshenghuang/%E4%BD%BF%E7%94%A8vscode%E5%A4%96%E6%8E%9B%E8%87%AA%E5%8B%95%E7%B7%A8%E8%AD%AFsass-scss-9ff768d23b48  \nhttps://www.hexschool.com/courses/sass.html  \nhttps://cythilya.github.io/2018/06/05/css-methodologies/  \nhttps://cythilya.github.io/2018/05/22/bem/","tags":["css"],"categories":["css"]},{"title":"HTML 基本介紹","url":"%2F2020%2F01%2F15%2FHTML-base%2F","content":"\n## HTML 基本介紹\n##### 超文本標記語言（英語：HyperText Markup Language，簡稱：HTML）是一種用於建立網頁的標準標記語言。HTML是一種基礎技術，常與CSS、JavaScript一起被眾多網站用於設計網頁、網頁應用程式以及行動應用程式的使用者介面[3]。網頁瀏覽器可以讀取HTML檔案，並將其彩現成視覺化網頁。HTML描述了一個網站的結構語意隨著線索的呈現，使之成為一種標記語言而非程式語言。目前已經到了 5.0 版。\n\n## 標籤元素\n使用標籤元素來呈現網頁內容，通常為 \"區塊級\" 或是 \"行內\"。瀏覽器預設以在元素前後換行(另起一行)的方式，表現區塊級元素。視覺上會呈現為一排縱向堆疊的方塊。行內元素是與鄰近元素保持在同一行。  \n\n元素組成可以加入屬性及屬性值，可以同時有多種屬性及值，每個標籤都可以有 id 及 class 屬性。\n \nid=\"名稱\"：識別單一元素用，可利用 id 來跟特定元素互動，名稱不能相同。  \nclass=\"名稱\"：識別同類別元素，可利用 class 來跟同類別元素互動，多元素可以同一個 class 類別。\n\n屬性也可以自訂，使用方式為 `date-*` 。\n\ne.g.\n\n`data-timezone=\"Europe/London\"`  \n\n利用 `getAttribute` 方法可取出值。\n\n`let timezone = tz.getAttribute('data-timezone');`\n\n## 標籤種類\n\n### 網頁頁面資訊\n\n#### 版本宣告(HTML5)  \n\n`<!DOCTPYE html>`\n\n#### 網頁語系  \n\n`<html lang=\"en\">`\n\n#### 網頁資訊    \n\n`<head></head>` 裡面通常包含 `<meta>`\n\n`<meta>` 提供網頁內容資訊給瀏覽器或搜尋引擎通常有以下屬性：  \n\n用來寫網頁的簡短描述  \n\n`name=\"description\" content=\"網頁簡短描述\"`   \n\n放置網頁關鍵字    \n\n`name=\"keywords\" content=\"網頁關鍵字\"`  \n\n內容種類及編碼\n\n`<meta http-equiv=\"Content-Type\" content=\"text/html\"; charset=\"uft-8″>`  \n\n使用語言\n\n`<meta http-equiv=\"Content-Language\" content=\"zh-TW\">`  \n\n自動更新時間\n\n`<meta http-equiv=\"Refresh\" content=\"time\">`\n\n避免瀏覽器儲存快取  \n\n`<meta http-equiv=\"pragma\" content=\"no cache\">`  \n\n#### 瀏覽器頂端或該頁面標題列  \n\n`<title></title>`  \n\n#### 連結外部資源  \n\n`<link>`  \nps. 一般有 rel、type、href 屬性。\n>rel=\"stylesheet\"：連結樣式。  \n>type=\"text/css\"：連接類型。(不一定要加上)  \n>href=\"URL\"：連結位置。\n>crossorigin＝\"anonymous\"：屬性是否使用CORS(不一定要加)，anonymous：發起跨域請求，但不發送認證訊息。  \n\n\ne.g.\n\n```\n<link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\">\n```\n\n#### script 外部引用  \n\n`<script src=\"/path/to/your.js\"></script>`  \nps. 另外可加上 async 、 defer 屬性(必須搭配 src)。\n>async：下載後會先執行，但執行此 js 同時也繼續載入頁面及執行其他 js。  \n>defer：要整個頁面都下載及分析完成後才會執行，非常類似於把 js 放在頁尾的情況。  \n> integrity: 驗證完整性。\n\ne.g.\n\n```\n<script defer src=\"https://use.fontawesome.com/releases/v5.0.8/js/solid.js\" integrity=\"sha384-+Ga2s7YBbhOD6nie0DzrZpJes+b2K1xkpKxTFFcx59QmVPaSA8c7pycsNaFwUK6l\" crossorigin=\"anonymous\"></script>\n```\n\n### 網頁內容標籤\n\n#### body 標籤包含的元素會顯示在瀏覽器視窗，標籤組成有分成語意及無語意，來描述頁面資料及結構，視覺效果用 CSS 處理。\n\n`<body></body>`\n\n#### div 區塊標籤，可當做無語意的 `<header>`、`<article>`，無明顯含義的區塊或為了排版目的\n\n`<div></div>`  \n\n#### span 行內標籤，可當做無語意的 `<strong>`、`<em>`。將文字與元素群組組在行內中。\n\n`<span></span>`\n\n#### 樣式標籤，使用 css 樣式(內部宣告用)。\n\n`<style type=\"text/css\"></style>`\n\n### 語意標籤\n用來排版及了解網頁區塊的設計目的，語意標籤和 `<div>`、`<span>` 在排版上具有完全一樣的特性，雖可用 `<div>`、`<span>` 來快速排版，但最好用以下語意標籤來替代。使用 HTML5 語意化標籤的優點有可以快速抓到網頁架構和每個區塊的位置，對於 SEO 優化有幫助。\n\n#### HTML5 語意標籤(大多是區塊標籤)\n`<header>`：網頁的標頭，通常放置網站標題。  \n`<nav>`：網頁的選單、導覽。  \n`<main>`：網頁的主要內容。  \n`<aside>`：網頁的側欄、附加內容。  \n`<article>`：一篇文章內容。  \n`<section>`：自訂的區塊，例如數篇摘要組成的空間。  \n`<footer>`：網頁的頁尾，通常放置聯絡方式、著作權宣告等等。  \n`<mark>`：強調一小塊內容。  \n`<time>`：顯示日期時間。  //不是區塊  \n`<mark>`：如黃色螢光筆的方式畫出重點，強調內容。 //不是區塊   \n`<details>`：描述文章的細節。  //不是區塊  \n`<figure>`、`<figcaption>`：`<figure>`用於圖像，`<figcaption>`用於圖像標題。  \n`<hgroup>`：當內容有主標題及次標題等多個標題的狀況下使用。  \n`<cite>`：引用其他文獻或作品(例如書籍、歌曲、電影、繪畫、雕塑等）的標題。  ps.也可當做屬性用   //不是區塊  \n\n{% asset_img HTML5.png This is an image %}\n\ne.g.\n\n首先是使用 `<div>` 可能的網頁結構，除了基本元素之外，主內容展示一篇文章和側欄，頁尾則顯示網頁最後更新的時間：\n\n```\n<div class=\"header\"></div>\n<div class=\"nav\"></div>\n<div class=\"main\">\n    <div class=\"article\"></div>\n    <div class=\"aside\"></div>\n</div>\n<div class=\"footer\">\n    Updated on <span class=\"time\"></span>\n</div>\n```\n\n接著改用語意標籤，語意標籤和 `<div>`、`<span>` 一樣，沒有預設樣式。\n\n```\n<header></header>\n<nav></nav>\n<main>\n    <article></article>\n    <aside></aside>\n</main>\n<footer>\n    Updated on <time></time>\n</footer>\n```\n\n#### 空白：  \n原始碼可用空白字元來排版，因為瀏覽器有空白壓縮功能，\n兩個或以上的空白字元，瀏覽器畫面上只會顯示一個空白，\n原始碼內的斷行也視為單一空白字元。\n\n#### 標題  //區塊標籤\n\n`<h1></h1>` ~ `<h6></h6>`\n \n#### 段落  //區塊標籤\n\n`<p></p>`\n\n#### 粗體\n\n`<b></b> `\n\n#### 斜體\n\n`<i></i>`\n\n#### 上標\n\n`<sup></sup>`\n\n#### 下標\n\n`<sub></sub>`\n\n#### 斷行\n\n`<br>`\n\n#### 水平線  //區塊標籤\n   \n`<hr>`\n\n#### 加強，通常標記為重要\n\n`<strong></strong>`\n\n#### 斜體，強調元素內容\n\n`<em></em>`\n\n#### 編號清單  //區塊標籤  \n\n\n```\n<ol>      \n  <li>a</li>\n  <li>a</li>\n</ol>\n```\n\n#### 項目清單  //區塊標籤\n\n```\n<ul>\n  <li>a</li>\n  <li>a</li>\n</ul>\n```\n\n#### 定義清單   //區塊標籤\n\n```\n<dl>     \n  <dt>a</dt>     //被定義名詞\n  <dd>bb</dd>    // 定義\n</ul>\n```\n\n#### 巢狀清單\n\n```\n<ul>           \n  <li>a</li>\n       <ul>      \n         <li>cc</li>\n         <li>dd</li>\n        </ul>\n  <li>a</li>\n</ul>\n```\n\n#### 將內容縮排，通常作為引述   區塊標籤\n\n`<blockquote></blockquote>`\n\n#### 引號\n\n`<q></q>`\n\nps.`<blockquote>`及`<q>`通常會加上 cite=\"url\" 屬性標明來源。\n\n#### 縮寫及縮略字\n\n`<abbr></abbr>`\n\nps. 可加上 title 屬性來註記全名\n\n#### email or 地址    //區塊標籤\n\n`<address></address>`\n\n#### 插入字，會加上底線\n\n`<ins></ins>`\n\n#### 刪節線，元素內容會加上刪節線\n\n`<del></del>`\n\n#### 元素內容加上刪節線，標示不正確但不刪除的內容\n\n`<s></s>`\n\n#### 畫 canvas     //區塊標籤\n\n`<canvas></canvas>`\n\n#### 置中，標籤內元素會置中\n\n`<center></center>`\n\n#### 顯示標籤內資料的原始格式\n\n`<pre></pre>`\n\n#### 旁註標記\n\n```\n<ruby>\n 漢 <rt> ㄏㄢˋ </rt>  漢 字的上面會標示 ㄏㄢˋ\n 漢 <rr> ㄏㄢˋ </rr>  漢 字的旁邊會標示 ㄏㄢˋ\n</ruby>\n```\n\n#### 插入圖片\n\n`<img src=\"圖片位置\" alt=\"沒有圖片時的替代文字\" title=\"圖片資訊\">`\n\nHTML5 用法  可放置一張以上的圖\n\n```\n<figure>  \n<img src=\"圖片位置\" alt=\"沒有圖片時的替代文字\" > \n<br>\n<figcaption>圖片說明</figcaption>\n</figure>\n```\n\n#### 超連結\n\n`<a href=\"url\" target=\"_blank\">連結名稱</a>`\n\nps.\n>href：可用絕對或相對路徑  \n>target=\"_blank\"：連結另開新視窗  \n>href=\"#id：連結到同網頁的某個部份    \n>href=\"url#id\"：連結到另一個網頁的某個部份  \n>href=\"mailto:aa@example.org\"：Email 連結\n\n\n***絕對路徑  \n/img/logo.png 根目錄下的圖片  \npage.html 同層目錄中的 html 檔***  \n\n***相對路徑  (通常用在自己的網站中)  \n./css/all.css  同層目錄中的 css 資料夾裡的 css 檔  \n../img/logo.png 上層目錄中的 img 資料夾裡的圖檔***\n\n#### 音訊\n\n`<audio src=\"url\"></audio>`\n\n屬性：\n>control 提供撥放控制鈕  \n>preload=\"none or auto or metadata\" 頁面載入時是否載入視訊  \n>control 提供撥放控制鈕  \n>autoplay 自動播放  \n>loop 結束後從頭播放  \n\n\n多重音訊 HTML5\n\n```\n<audio>\n<source src=\"檔案路徑\" type=\"視訊格式\" >\n<source src=\"檔案路徑\" type=\"視訊格式\" >\n</audio>\n```\n\n#### 播放視訊(HTML5) //區塊標籤\n\n`<video src=\"url\"></video>`  \n***ps.video 標籤的屬性不需要值，屬性存在選項就會開啟，如果不存在選項就關閉。***\n\n屬性：  \n>src=\"檔案路徑\"  \n>height=\"200\"  \n>width=\"100\"  \n>preload=\"none or auto or metadata\" 頁面載入時是否載入視訊  \n>control 提供撥放控制鈕  \n>autoplay 自動播放  \n>loop 結束後從頭播放  \n>poster=\"圖片位置\" 視訊下載時或播放前所顯示的影像  \n\n放數個視訊\n\n```\n<video>\n<source src=\"檔案路徑\" type=\"視訊格式\" code=\"編碼\" >\n<source src=\"檔案路徑\" type=\"視訊格式\" code=\"編碼\" >\n<source src=\"檔案路徑\" type=\"視訊格式\" code=\"編碼\" >\n</video>\n```\n\n#### 表格：不要用來排版，只要顯示資料就好。用 CSS 處理排版。  \n\n```\n<table>\n  <thead>  <!--表頭-->\n    <tr>   <!--列的起始  row - - -  column(行,欄)  | | |  -->\n      <th>Month</th>   <!--表格標題-->\n      <th>Savings</th>\n    </tr>\n  </thead>\n  <tbody>  <!--內容-->\n    <tr>\n      <td>January</td>    <!--表格內容-->\n      <td>$100</td>\n    </tr>\n    <tr>\n      <td>February</td>\n      <td>$80</td>\n    </tr>\n  </tbody>\n  <tfoot>  <!--註腳-->\n    <tr>\n      <td>Sum</td>\n      <td>$180</td>\n    </tr>\n  </tfoot>\n</table>\n\n<td colspan=\"2\">$180</td>  資料超過一欄 (跨欄)\n<td rowspan=\"2\">$180</td>  資料超過一列 (跨列)\n```\n\n#### 表單\n\n`<form action=\"按下後接收送出資訊的url\" method=\"get or post\" id=\"a\"></from>`\n\n***get：搜尋框 or 只想從伺服器取得資料(普通資料)。  \npost：上傳檔案 or 表單很長 or 有敏感資料(密碼) or 資料加到資料庫或從資料庫刪除。***\n\n***name 跟 value 屬性欄位的值有些會傳給伺服器\n任何文字輸入欄位可以使用 placeholder 屬性，placeholder=\"顯示在欄位內的文字\"***\n\ne.g.\n\n```\n<form action=\"按下後接收送出資訊的url\" method=\"get or post\" id=\"a\">\n <p>username 文字輸入\n <input type=\"text\" name=\"username\" maxlength=\"限制字元數\"> \n </p>\n  <!--多行文字輸入欄位標籤-->\n <textarea name=\"Content\"></textarea>\n  <!--密碼輸入-->\n <input type=\"password\" name=\"username\" maxlength=\"限制字元數\">\n  <!--單選-->\n <input type=\"radio\" name=\"username\" value=\"傳到伺服器的值，每個單選鈕都不應相同\" checked=\"checked(預先選好)\">\n  <!--勾選(可取消)-->\n <input type=\"checkbox\" name=\"username\" value=\"傳到伺服器的值，每個單選鈕都不應相同\" checked=\"checked(預先選好)\">\n <!--下拉式選單 (若都沒 selected 屬性的話，會顯示第一個選項)-->\n <select name=\"Location\" size=\"3\" multiple=\"multiple(可多選)\">\n   <option value=\"Taipei\" selected=\"selected(預先選好)\">台北</option>\n   <option value=\"Taoyuan\">桃園</option>\n </select>\n   <!--檔案輸入 (method 必須使用 post)-->\n   <input type=\"file\" name=\"username\">\n   <!--送出按鈕 (name 跟 value 欄位可用可不用)-->\n   <input type=\"submit\" name=\"username\" value=\"顯示按鈕文字\">\n   影像按鈕\n   <input type=\"image\" src=\"url\">\n</from>\n\n\n<input type=\"hidden\" name=\"\" value=\"\"> 隱藏控制項，用隱藏欄位來記錄資訊\n```\n\nps.表單驗證  \nHTML5 有驗證功能，加入 required 屬性(不需要值)，由瀏覽器來做。)，HTML5 才有(不支援 HTML5 的瀏覽器會當作文字框)。  \n\n日期輸入  \n`<input type=\"date\" name=\"date\">`  \nEMAIL 輸入  \n`<input type=\"email\" name=\"email\">`  \nURL 輸入  \n`<input type=\"url\" name=\"website\">`  \n搜尋輸入  \n`<input type=\"search\" name=\"search\">`\n\n\n#### label 協助使用者在點選到該標籤時，可以透過 for 的屬性值，去連動具有相同 id 屬性值的標籤。或是直接將 `<input>` 元素包圍起來。\n\n`<label for=\"某id值\"></label>`  \n\ne.g.\n\n```\n<label><input type=\"radio\" name=\"booktype\" value=\"1\" id=\"booktype1\" checked ></label>\n<input type=\"radio\" name=\"booktype\" value=\"2\" id=\"booktype2\" checked >\n<label for=\"booktype1\">html 書</label>\n```\n\n#### 按鈕(可添加圖片)\n\n`<button type=\"button\"><img src=\"url\" alt=\"\"></button>` \n\n#### iframe 顯示別的 url 的網頁內容在本身網頁的某區塊上\n\n`<iframe src=\"url\" height=\"20\" width=\"10\"></iframe>`\n\n\n#### 註解\n\n`<!---->`\n\n\n#### 符號顯示\n\n`&lt;` <   \n`&gt;` >  \n`&amp;` &  \n`&copy;` 版權符號  \n`&reg;`  註冊商標  \n`&nbsp;` 空白 //在畫面上出現多個空白\n\n#### 補充\n\n使用編輯器小技巧(emmet)：  \n\n+ 若檔案為 *.HTML 的話，在開啟檔案後，打 `!` ，可產生出以下標籤。\n\n```\n\b\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    \n</body>\n</html>\n```\n\n+ 打 lorem300，可以產生 300個假字。\n\n+ 使用 `標籤名稱.class名稱*數量>要包覆的標籤1+要包覆的標籤2` 方式，按下 enter，可以快速產生標籤。\n\ne.g.\n\n`div.test*2>p+img`\n\n產生\n\n```\n<div class=\"test\">\n    <p></p>\n    <img src=\"\" alt=\"\">\n</div>\n<div class=\"test\">\n    <p></p>\n    <img src=\"\" alt=\"\">\n</div>\n```\n\n\n### 簡單網頁範例：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n <head>\n     <!-- meta 網頁資訊給瀏覽器讀取 -->\n     <meta charset=\"UTF-8\">\n     <meta name=\"viewport\">\n     <meta http-equiv=\"X-UA-compatible\" content=\"ie=edge\">\n     <title>Document</title>\n     <link rel=\"stylesheet\" href=\"style.css\">\n     <!-- CSS -->\n     <style>\n       h1{color:red}\n     </style>\n </head>\n <body>\n     <!-- 錨點寫法 -->\n     <!-- emmet寫法 ul>li*3>a{標題} enter後會產生以下標籤\n     <ul>\n         <li><a href=\"\">標題</a></li>\n         <li><a href=\"\">標題</a></li>\n         <li><a href=\"\">標題</a></li>\n     </ul> -->\n    <ul>\n        <li><a href=\"#title1\">標題1</a></li> \n        <li><a href=\"#title2\">標題2</a></li>\n        <li><a href=\"#title3\">標題3</a></li>\n        <!-- 標題4錨點定位在page.html的 id=title3 -->\n        <li><a href=\"page.html#title3\">標題4</a></li>\n    </ul> \n    <!-- 標題1 id_name=title1 -->\n    <h1 id=\"title1\">標題一</h1>\n    <!-- vscode 內打 lorem 會產生一段假文 -->\n    <p>lorem</p>\n    <!-- 從上到下讀取到此的網頁程式碼後執行js資料夾的all.js 然後再接著執行下面的程式碼-->\n    <script src=\"js/all.js\"></script>\n    <h1>js後的標題</h1>\n    <p>123</p>\n</body>    \n</html>\n```\n\n參考：  \nhttps://zh.wikipedia.org/wiki/HTML  \nhttp://cychiang719.blogspot.com/2008/08/html.html  \nhttp://n.sfs.tw/content/index/10323  \nhttps://ithelp.ithome.com.tw/articles/10160131  \nhttp://www.dlps.tc.edu.tw/html_teach/","tags":["HTML"],"categories":["HTML"]},{"title":"記錄一下 AJAX 操作的幾個方法","url":"%2F2019%2F12%2F15%2FAJAX-base%2F","content":"## AJAX\n###(Asynchronous JavaScript and XML)的縮寫\n**間單來說是與伺服器進行非同步通訊，可用來自伺服器的資料更新網頁元素，綜合了多項技術的瀏覽器端網頁開發技術。可以增進使用者的操作體驗。**\n\n**以下介紹幾種使用方法：**\n\n## JavaScript XHR\n**透過 XMLHttpRequest(XHR) 物件作為實作。\n它能夠在 client 端對 server 端送出 http request，使用的資料格式是 XML(這也變成時代眼淚，現今大多使用 JSON，它的格式像是 JS 中的物件)，用 XMLHttpRequest() 取到的結果會是字串，要額外透過 JSON.parse() 轉成 JSON 才可以使用。**  \n\n*Ps.目前較少用，難以閱讀及撰寫，我們大多都會使用框架來處理這段，如 jQuery, Axio...*\n\n程式碼大概長這樣：\n\n```\nfunction reqOnload () {\n  // 資料轉成 JSON 格式\n  const data = JSON.parse(this.responseText);\n  console.log(data)\n}\nfunction reqError (err) {\n  console.log('錯誤', err)\n}\n\n// 宣告一個 XHR 的物件\nvar Req = new XMLHttpRequest(); \n// 定義連線方式 true: 非同步 , false: 同步\nReq.open('get', 'https://randomuser.me/api/', true);\n// 送出請求\nReq.send();\n// 如果成功就執行 reqOnload()\nReq.onload = reqOnload; \n// 失敗就 reqError()\nReq.onerror = reqError;\n\n//POST(Form)\n\nvar xhr = new XMLHttpRequest();\nxhr.open('post', 'http://xxx', true);\nxhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\nxhr.send('name=Bob&password=123456');\n\n//POST(JSON)\n\nvar account = {\n    name: 'Bob',\n    password:'123456'\n}\nvar xhr = new XMLHttpRequest();\nxhr.open('post', 'https://xxx', true);\nxhr.setRequestHeader('Content-type', 'application/json');\nvar data = JSON.stringify(account);\nxhr.send(data);\n```\nXMLHttpRequest 有各種狀態碼(readyState)，能夠知道當前進行到什麼狀態。  \n>0 : 已經產生 XMLHttpRequest，但還沒連結到要取得的網址。  \n1 : 用了 open() ，但還沒傳送資料過去  \n2 : 用了 send()  \n3 : loading 資料  \n4 : 撈回資料了，數據已接收完全  \n\n## jQuery \n\n```\n$.ajax({\n    url: \"http://xxx\",\n    // 傳送至Server的資料，必須為物件格式\n    data : { \n      datafromtestFile : $(\"#input\").val(),                            \n    },\n    type: \"GET\",\n    // 傳回 JSON\n    dataType: 'json',\n    // 成功時執行函式\n    success: function(data) {\n    // 取得的遠端資料\n    console.log(data);\n  },\n    error: function(error) {\n    console.log(\"error:\", error);\n  }\n});\n``` \n\n## Fetch\n**ES6 原生方法 ，是搭配 Promise(Promise 的基本用法)來執行請求網站和請求後獲取 Response 的處理。then 作為下一步，catch 作為錯誤回應 (404, 500…)。回傳的為 ReadableStream 物件，需要使用不同資料類型使用對應方法，才能正確取得資料物件。**\n\n```\nfetch('http://abc.com/', {method: 'GET'})\n.then((response) => {\n    // 這裡會得到一個 ReadableStream 的物件\n    console.log(response);\n    // 可以透過 blob(), json(), text() 轉成可用的資訊\n    return response.json(); \n  }).then((jsonData) => {\n    console.log(jsonData);\n  }).catch((err) => {\n    console.log('錯誤:', err);\n});\n```\ntext()：改為 response.text()，取得的資料格式將會是純字串。    \nblob()：將資料轉為 blob 物件，像是圖片就可以做這樣的轉換(指的是圖片檔案本身)。  \n\n範例：\n\n```\n// unsplash 上的圖片\nlet url = 'https://images.unsplash.com/photo-1513313778780-9ae4807465f0?auto=format&fit=crop&w=634&q=80'\nfetch(url)\n  .then((response) => {\n    return response.blob();\n  })\n  .then((imageBlob) => {\n    let img = document.createElement('IMG')\n    document.querySelector('.newImg').appendChild(img);\n    // 將 blog 物件轉為 url\n    img.src = URL.createObjectURL(imageBlob);\n  })\n\n```\n\n用 Fetch 做 post 時，需做一些調整。將 body 所送出的資料轉純字串後才能送出。\n\n```\nlet url = 'https://hexschool-tutorial.herokuapp.com/api/signup';\nfetch(url, {\n  method: 'POST',\n  // headers 加入 json 格式\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  // body 將 json 轉字串送出\n  body: JSON.stringify({\n    email: 'lovef1232e@hexschool.com',\n    password: '12345678'\n  })\n}).then((response) => {\n    return response.json(); \n  }).then((jsonData) => {\n    console.log(jsonData);\n  }).catch((err) => {\n    console.log('錯誤:', err);\n})\n```\n\n使用 Fetch 需要注意，只要是伺服器有正確回應，不管是什麼狀態碼，就算是 404 也會將 response 傳入 then 之後的 function 繼續執行，而不會進到 catch。\n\n此時可以透過 response 中的 ok 來判斷狀態碼是否正常，如果是 true 則表示狀態碼在於 200~299 之間。\n\n所以可以多加個判斷\n\n```\nfetch('http://abc.com/', {method: 'get'})\n.then((response) => {\n\t if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n    // 這裡會得到一個 ReadableStream 的物件\n    console.log(response);\n    // 可以透過 blob(), json(), text() 轉成可用的資訊\n    return response.json(); \n  }).then((jsonData) => {\n    console.log(jsonData);\n  }).catch((err) => {\n    console.log('錯誤:', err);\n});\n```\n\n## axios\n**依賴 ES6 Promise，若不支援請使用 Polyfill  \n支援 Promise API  \n可取消請求 (Promise 無法)  \n自動轉換 JSON  \naxios 實體建立，可統一套用 Config、管理 API**  \n\n### 安裝\n`$ npm install axios`\n\n\n```\n// GET\naxios.get('http://user/12345')\n.then(res =>{\n    console.log(res);\n}).catch(err => {\n    console.log(err);\n})\n\n// POST\naxios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n        firstName: 'Fred',\n        lastName: 'Flintstone'\n    }\n})\n.then(function (response) {\n    console.log(response);\n})\n.catch(function (error) {\n    console.log(error);\n})\n.finally(() => { /* 不論失敗成功皆會執行 */ \n});\n```\n\n管理 API 方式\n\n開新檔 api.js\n\n```\nimport axios from 'axios';\n\n// User相關的 api\nconst userRequest = axios.create({\n  baseURL: 'https://api/user/'\n});\n// 文章相關的 api\nconst articleRequest = axios.create({\n  baseURL: 'https://api/article/'\n});\n// 搜尋相關的 api\nconst searchRequest = axios.create({\n  baseURL: 'https://api/search/'\n});\n\n// User 相關的 api\nexport const apiUserLogin = data => userRequest.post('/signIn', data);\nexport const apiUserLogout = data => userRequest.post('/signOut', data);\nexport const apiUserSignUp = data => userRequest.post('/signUp', data);\n\n// 文章相關的 api\nexport const apiArticleItem = () => articleRequest.get('/ArticleItem');\nexport const apiArticleMsg = data => articleRequest.post('/ArticleMsg', data);\nexport const apiArticleLink = data => articleRequest.post('/ArticleLink', data);\n\n// 搜尋相關的 api\nexport const apiSearch = data => searchRequest.get(`/Search?searchdata=${data}`);\nexport const apiSearchType = () => searchRequest.get(`/SearchType`);\n```\n\n如果需要用到的話，就 import\n\n```\n// import api.js\nimport { apiUserLogin, apiUserLogout, apiUserSignUp } from \"api.js\"; \n\n// 使用 Login\napiUserLogin({\n    email: \"mike@gmail.com\",\n    password: \"123456789\"\n})\n.then(res=> {\n    console.log(res);\n})\n.catch(err=> {\n    console.log(err);\n})\n```\n\n參考：  \n[axios 默認值 & 建立實體 & 錯誤偵測](https://ithelp.ithome.com.tw/articles/10212121)  \n[鐵人賽：ES6 原生 Fetch 遠端資料方法](https://wcc723.github.io/javascript/2017/12/28/javascript-fetch/)  \n[使用Axios你的API都怎麼管理？](https://medium.com/i-am-mike/使用axios時你的api都怎麼管理-557d88365619?)  \n[Day21 AJAX(1): 科普 & XHR](https://ithelp.ithome.com.tw/articles/10203820?sc=iThelpR)  \n[Day22 AJAX(2): Fetch](https://ithelp.ithome.com.tw/articles/10204214)  \n[axios 基本使用 & Config](https://ithelp.ithome.com.tw/articles/10212120)  \n[使用 fetch 來進行 Ajax 呼叫](https://skychang.github.io/2015/11/02/JavaScript-Use_Javascript_Fetch/)  \n[axios小筆記：一些特殊用法](https://yuugou727.github.io/blog/2018/03/04/axios/)","tags":["AJAX"],"categories":["AJAX"]},{"title":"Bootstrap 簡單介紹","url":"%2F2019%2F12%2F14%2Fbootstrap-base%2F","content":"## Bootstrap\n### 前端框架，含HTML、CSS及JS等內容的框架，可以快速開發出一個網頁版型(包含響應式網頁)。\n\n### 簡單介紹一下樣式寫法：  \n#### 文字  \n\n##### 對齊  \n\n`text-justify`、`text-center`   \n\n##### 置右   \n\n`text-right`   \n\n##### 字體   \n\n`font-weight-bold`  \n\n##### 大小寫  \n\n`text-capitalize`   \n\n#### 文字顏色  \n\n##### 綠  \n\n`class=\"text-success\"`\n\n#### 去除文字類別效果\n\n`class=\"text-decoration-none\"`\n\n#### 背景色\n\n`bg-primary`\n\n#### 背景梯度(Background gradient)顏色漸層  \n`bg-gradient-warning`\n\n#### 邊界\n\n##### 四邊都有  \n\n`border`  \n\n##### 只有上邊界  \n\n`border-top`  \n\n##### 沒有邊界  \n\n`border-0`  \n\n##### 除上邊界沒有其他三邊有  \n\n`border-top-0`\n\n#### 邊界顏色\n\n`class=\"border border-primary\"`\n\n#### 邊界角度(Border-radius)   \n\n##### 四周都圓角  \n\n`class=\"rounded\"`  \n\n##### 圓形  \n\n`rounded-circle`  \n\n##### 無圓角  \n\n`rounded-0`  \n\n##### 上方圓角    \n\n`rounded-top`\n\n#### 清除浮動(Clearfix)  \n\n`class=\"clearfix\"`\n\n#### display 屬性設定\n\n`class=\"d-block\"`   // display: block\n\n`class=\"d-inline\"`  // display: inline\n\n```\n<div class=\"bg-danger m-5 p-2 text-light d-inline\">d-inline</div>\n<div class=\"bg-warning m-5 p-2 text-secondary d-inline\">d-inline</div>\n<span class=\"bg-danger m-5 p-2 text-light d-block\">text-danger</span>\n<span class=\"bg-warning m-5 p-2 text-secondary d-block\">text-secondary</span>\n```\n\n{% asset_img bootstrap2.png This is an image %}\n\n\n#### 隱藏元素也不佔空間\n\n`class=\"d-none\"`\n\n#### 顯示陰影\n\n`class=\"shadow\"`\n\n#### Close icon  x   \n\n`<button type=\"button\" class=\"close\" arialabel=\"Close\">`\n\n詳細樣式、元件、模板請參考網站  https://getbootstrap.com/docs/4.0/utilities\n\n## 網格系統\n### Bootstrap 的 Grid System。規則如下：\n\n#### 結構依序為如下：container -> row -> column\n*所有的「row」都要放在「container」之下，「col-\\*」(column) 要放在「row」之下。column 為最小單位的方格，且有間格將彼此格開。由「row」校正 colume 左右多出來的左右 padding。基本上一個 row 放置 12 個 column，若有一個 row 超過 12 個 column，則會斷行放置多出來的 column。*\n\nContainer 提供方式來置中你的內容，當你的容器寬度是固定的使用 `.container` 如果想要滿版則使用 `.container-fluid`。\n\n#### Column命名規則：  \nphone (576px~767px) = .col-xs-\\*  // 預設斷點  * 為數字 1~12  \nSmall grid (≧768px) = .col-sm-\\*  // 平板   \nMedium grid (≧992px) = .col-md-\\*  // 電腦   \nLarge grid (≧1200px) = .col-lg-\\*  // 電腦(大型)  \n.col-md-offset-\\*  // 位移  \n\nps. 調整不同視圖下的欄寬度，在 Bootstrap 4 中 .col-xs-\\* 已消失，取而代之的 .col-* 在語意上代表的差別是「從最小設備到最大設備都相同的網格」。 \n\n**只要在 row 中，直接加入 col 後，就會自動將 row 的 div 等分，比方要作三等份，以前需寫 col-md-4 ，但現在只要 col 重覆三次，無需再特別註明裝罝與數量，還可以混用，將 col 後再加數量。**\n\n範例一\n\n```\n<div class=\"container\">\n <div class=\"row\">\n    <div class=\"col\">a</div>\n    <div class=\"col-6\">b</div>\n    <div class=\"col\">c</div>\n </div>\n</div>\n```\n\n範例二\n\n```\n<div class=\"wrap\"> or <div class=\"container\">\n\t<div class=\"row\">\n\t    <div class=\"col-sm-8\">col-sm-8</div>\n\t    <div class=\"col-sm-4\">col-sm-4</div>\n\t</div>\n\t<div class=\"row\">\n\t    <div class=\"col-sm\">col-sm</div>\n\t    <div class=\"col-sm\">col-sm</div>\n\t    <div class=\"col-sm\">col-sm</div>\n\t</div>\n</div>\n```\n#### 螢幕尺寸大小上調整不同寬度\n同一 column 加上多的 class 來調整版面：\n\n```\n<div class=\"row\">\n  <div class=\"col-sm-4 col-md-8\">.col-sm-4 .col-md-8</div>\n  <div class=\"col-sm-8 col-md-4\">.col-sm-8 .col-md-4</div>\n</div>\n<!-- 當螢幕尺寸為 md 以上時會有 8:4 來顯示 \n     當螢幕尺寸為 sm 時會以 4:8 來顯示\n     當螢幕尺寸小於 sm 時會換行顯示 -->\n```\n\n#### 隨著內容變動寬度\n使用 col-{breakpoint}-auto 同時搭配上 **水平對齊** 可以讓 column 的寬度隨著內容而改變。\n\n#### 間距拿掉\n\n.row 加入:\n>`no-gutters`\n\ne.g.  \n`<div class=\"row no-gutters\">`\n\n#### 垂直對齊\n\n.row 或 .col 加入: \n>`align-items-start`  // 列或欄垂直的置頂\n`align-items-center`   // 列或欄垂直的置中\n`align-items-end`      // 列或欄垂直的置底  \n\n#### 水平對齊\n\n.row 加入:  \n>`justify-content-start`  // 置左  \n`justify-content-center` // 置中  \n`justify-content-end`    // 置右  \n`justify-content-around` // 是讓該列內的欄平均排列在該列  \n`justify-content-between` // 是讓列類的欄靠邊排列在該列\n\n#### Spacing\n指元素的 margin 跟 padding 。\n\nm：margin  \np：padding  \nt：top  \nr：right  \nb：bottom  \nl：left  \nx：-right和-left  \ny：-top 和 -bottom  \n\nm：margin  \nmt：margin-top  \nmr：margin-right  \nmb：margin-bottom  \nml：margin-left  \nmx：margin-right 和 margin-left  \nmy：margin-top 和 margin-bottom  \n\np：padding  \npt：padding-top  \npr：padding-right  \npb：padding-bottom  \npl：padding-left  \npx：padding-right 和 padding-left  \npy：padding-top 和 padding-bottom\n\n***Bootstrap 4 裡 Spacing 基本的單位就是 1rem。\n1rem = 16px，結合上述的代碼。就是代表要多少的內距或外距。***\n\n0：0 * 1rem = 0px  \n1：0.25 * 1rem = 4px  \n2：0.5 * 1rem = 8px  \n3：1 * 1rem = 16px  \n4：1.5 * 1rem = 24px  \n5：3 * 1rem = 48px  \nauto: margin 設定為 auto\n\ne.g.\n\nmb-3 = margin-bottom：16px  \npt-4 = padding-top：24px  \nm-1 = margin：4px;  \n\n## 使用 flexbox\n`class=\"d-flex flex-column\"`\n\nflex-column：直排上到下排列內元素  \nflex-row：橫排左至右排列內元素\n\n## 表單\n`class=\"form-control\"`\n\n## 卡片(Cards)\n\nCards 是 Bootstrap 4 的新組件，使用 Flexbox 建構，有瀑布流樣式(Masonry-like)可供使用。卡片可支援各種內容，包括圖像、文字內容、清單、連結等。 \n \n*ps. 瀑布流樣式(Masonry-like): 將卡片包在 `.card-columns` 中，就會讓卡片呈現瀑布式排列。*\n    \n## 範例\n\n套用 Bootstrap 4 的 class\n\n```\nHTML\n\n<div class=\"box2 bg-danger m-5\"></div>\n\nCSS\n\n.box2{\n width: 100px;\n height: 100px;\n}\n```\n長寬各 100px 的 #dc3545 色正方型，然後四邊各有 48px 的外距。\n\n{% asset_img bootstrap.png This is an image %}\n\n\n\n\n參考：  \nhttps://medium.com/@weilihmen/bootstrap-初學介紹-靜態篇-f20500235b33  \nhttps://bootstrap.hexschool.com  \nhttps://getbootstrap.com  \nhttps://cythilya.github.io/2015/04/07/bootstrap-grid-system/  \nhttps://5xruby.tw/posts/bootstrap-4/\nhttps://ithelp.ithome.com.tw/articles/10228808?sc=iThomeR  \nhttps://pjchender.blogspot.com/2017/06/bootstrap4-grid-system.html","tags":["Bootstrap"],"categories":["Bootstrap"]},{"title":"RWD 基本知識","url":"%2F2019%2F12%2F13%2FRWD-base%2F","content":"# 響應式網頁(RWD)\n### Responsive web design，縮寫為 RWD。是一種設計方式，利用操控 CSS 的方法來改變網頁樣式，網頁內容就可以自由的縮放、移動，好因應各種不同瀏覽器解析度，讓使用者在瀏覽網頁時都可以有最好的瀏覽體驗。  \n### 在 HTML 上沒有甚麼不同，其實也只有在 `<head>` 標籤裡加上 Viewport Meta Tag。\n\n`<meta name=\"viewport\" content=\"\">`\n\ncontent 的值有\n>Width    // 寬度  \nWidth-device-width  // 寬度為裝置的寬度  \nInitial-scale   // 文檔的初始比例(單位是 %)    \nMaximum-scale   // 設定縮放大小\n\n\n```\n// 指定螢幕寬度為裝置寬度，畫面載入初始縮放比例 100%\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" >\n// 以下設定可以防止使用者做畫面縮放，將畫面鎖在縮放比例 100%\n<meta name=”viewport” content=”width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n```\n\n### 主要是在 CSS 的撰寫，以下進行簡單的介紹：\n#### 撰寫方式是用 media query \n>`@media` 來定義套用的媒體類型和特性。\n>>媒體類型（Media Type）：可用的類型包含 all (default), print, screen 和 speech。  \n媒體特性（Media Feature）：常用的類型包含 width, height, aspect-ratio, orientation, resolution，這些類型常常需要給定一個區間，像是 min, max, min-width, max-width, min-aspect-ratio, max-aspect-ratio。  \n\n#### 定義媒體類型及同時定義媒體類型和媒體特性\n\n```\n// 定義媒體類型\n@media screen, print {\n  /* Styles for screen and print devices */\n}\n\n// 同時定義媒體類型和媒體特性，中間需用 and 連接\n@media screen and (max-width: 650px) {\n  body {\n    background: rebeccapurple;\n  }\n}\n```\n\n#### 或是直接寫特性\n\n```\n// max-width 以電腦瀏覽比較為主通常用 max-width 開始寫\n// 當解析度小於768px\n@media (max-width: 768px) {\n body{\n  background: yellow;\n  color:black;\n } \n}\n// 當解析度小於375px\n@media(max-width: 375px){\n body{\n  background: blue;\n  color:white;\n }\n\n// min-width 以行動瀏覽為主的網頁通常會用 min-width 開始寫\n// 當解析度大於376px\n@media(min-width:376px){\n body{\n  background: yellow;\n  color:black;\n }\n}\n// 當解析度大於769px\n@media(min-width:769px){\n body{\n  background: green;\n  color:yellow;\n }\n\n```\n\n## 簡單範例\n\n```\n//HTML\n\n<meta name=”viewport” content=”width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n\n<body>\n <h1>請縮放螢幕使網頁內容產生變化</h1>\n <p>test</p>\n</body>\n\n//CSS\n\nbody{\n background: green;\n color:yellow;\n}\n@media (max-width: 768px) {\n body{\n  background: yellow;\n  color:black;\n } \n}\n@media(max-width: 375px){\n body{\n  background: blue;\n  color:white;\n }\n}\n```\n\n## 寫 RWD 時注意的事\n\n#### 子元素寬度設定盡量使用 `%` ，避免縮放網頁時產生出 X 軸。\n\n\n```\n// 限定網頁最大寬度，避免產生 X 軸\n.wrap {\n max-width: 1024px;\n margin: 0 auto;\n}\n// 子元素寬度單位用 % \n.box1{\n width: 100%;\n height: 200px;\n background: green;\n}\n.box2{\n width: 35%;\n height: 100px;\n background: pink;\n float:left;\n}\n```\n\n## 瀏覽器尺寸範例：\n\n```\n@media screen and (min-width:1024px){\n  /*STYLES*/\n}\n\n@media screen and (min-width: 1200px) {\n    // 如果使用者之視窗寬度 >= 1200px，將會再載入這裡的 CSS。\n}\n\n@media screen and (min-width: 768px) and (max-width: 979px) {\n    // 如果使用者之視窗寬度介於 768px ~ 979px，將會再載入這裡的 CSS。\n}\n\n@media screen and (max-width: 767px) {\n    // 如果使用者之視窗寬度 <= 768px，將會再載入這裡的 CSS。\n}\n\n@media screen and (max-device-width: 480px) {\n    // 如果使用者之裝置寬度 <= 480px，將會再載入這裡的 CSS。\n}\n\n瀏覽器直立或橫放\n\n@media screen and (orientation:portrait){\n  // 直立時套用\n}\n\n@media screen and (orientation:landscape){\n  // 橫放時套用\n}\n\nretina 顯示器\n我們可以透過 min-resolution: 192dpi 和 -webkit-min-device-pixel-ratio: 2 來定義 retina 顯示器：\n\n// 120dpi - 720px,\n// 192dpi - 1200px\n@media screen and\n  (min-resolution: 192dpi),\n  (-webkit-min-device-pixel-ratio: 2) {\n    /* ... */\n}\n\n@media screen and\n  (min-resolution: 120dpi) and\n  (min-width: 720px) {\n  // ...\n}\n\n```\n\n參考：  \n[[CSS] Media Query](https://pjchender.github.io/2018/06/09/css-media-query/)  \n[響應式網頁(RWD)環境與 Media Query](https://ithelp.ithome.com.tw/articles/10218043?sc=rss.iron)  \n[使用 Bootstrap 建立一個 RWD Template（Twitter Bootstrap in Responsive Web Design）](https://cythilya.github.io/2015/02/27/bootstrap-rwd-template/)","tags":["RWD"],"categories":["RWD"]},{"title":"CSS 基本介紹","url":"%2F2019%2F12%2F13%2F2019-12-13-css-base%2F","content":"#CSS 基本介紹\n## CSS是什麼\n* 樣式：將規則與 HTML 元素連結，來規定特定元素應呈現的樣子。\n* 有範圍性，不用下重複設定在多個標籤元素上。直接在最外圍的標籤上設定，例如 body、header。\n* 盡量不要用 id 來設計樣式。\n* 不要習慣寫死高度，利用 max-width、margin、padding 來做出空間。\n* Bootstrap 格線設計好用。\n\n\n## 加入到 HTML 三種方式\n1.外部載入 CSS 檔案  \n這是一個比較常用的方式，通常會將所有的 CSS 檔案集中寫在一起，然後另存為一個附檔名為 css 的檔案，然後在 HTML 文件中的    head 標籤內添加一個 link 標籤並且在 href 屬性內，指向到該 CSS 檔案的存放位置。  \n\n`<link rel=\"stylesheet\" href=\"css/all.css\"/>`\n\n\n2.將 CSS 內容寫在 style 標籤裡，並放在 head 標籤裡。  \n\n```\n<style>\n   .red{\n     color: red;\n   }\n</style>\n```\n\n\n3.或是將 CSS 內容單獨的寫在每一個指定的網頁標籤\n\n`<p style=”color:green”></p>`\n\n## 規則包含兩個部分：選取器(選取元素)和宣告\n    \n`p { color: red; }`\n選取器      宣告\n      \n`\nh1, h2, h3  { \n   color: red;\n    }\n`\n>選取多元素\n\n`* { }`                        \n>選取頁面上所有的元素\n\n`#introduction {}`\n>選取 id=\"introduction\" 的元素\n    \n`.introduction {}`\n>選取屬性 class=\"introduction\" 的元素\n\n`p.a {}`\n>選取 class 屬性值為 a 的 `<p>` 元素\n\n`li>a {}`\n>選取 `<li>` 元素內的 `<a>` 元素，但排除頁面上其他的 `<a>` 元素  \n    \n`p a {}`\n>選取任何在 `<p>` 元素之內的 `<a>` 元素，即使兩者之間還有堆疊其他元素 \n\n\n## 階層規範(若兩個規則同時套用到同一個元素上)\n* 後來先贏：以最後一個的規則為主\n* 指定程度：若一個選取器較其他的更具指定性，以較具指定性的為主\n\n```\nh1 比 * 更具指定性\np b 比 p 更具指定性\np#intro 比 p 更具指定性\n```\n* 重要：可在任何屬性值後面加上 !important ，來表示此規則比套用到相同元素的其他規定更重要。 \n\n```\np b {\n   color: blue !important;\n   }\n```\n## 繼承\n\n父元素的某些屬性會套用到大部分的子元素上。或在屬性中使用 inherit 值來強迫許多屬性從父元素來繼承屬性值。\n\n```\nbody {\n       font-family: Arial ;\n       color: #665544;\n       padding: 10px;\n         }\n.page  {\n       border: 1px solid #665544;\n       background-color: #efefef;\n       padding: inherit;\n         }\n```\n\n`<body>` 元素的 font-family 或 color 屬性會繼承給子元素 class=\"page\" 的 元素，從套用到 `<body>` 元素的 CSS 規則中繼承了內距尺寸。\n\n# 屬性種類\n## 顏色\n#### color: DarkCyan;\n>前景色\n  \n三種表示方式：  \n1.`color: DarkCyan; // name`\n2.`color: #ee3e80;     // hex`\n3.`color: rgb(100,100,90);  // rgb`\n\n#### background-color: white;\n>背景\n\n#### opacity: 0,5;  \n#### background-color: rgba(100,100,90,0.5);\n>不透明度(CSS3 值介於 0.0 到 1.0 or rgba 表示)\n\n#### background-image: url(位置);\n>元素背景影像\n\n## 文字\n#### font-family: Arial, Helvetica, Georgia \n>指定字型\n\n#### font-size: 12px; \n>字體大小\n\n表示方式：  \n1.`font-size: 12px;`\n2.`font-size: 200%;  // 瀏覽器預設文字大小是 16px `\n3.`font-size: 1.3em;  // ㄧ個 em 等於 m 字母的寬度`\n\n#### font-weight: normal or bold;\n>粗體\n\n#### font-style: normal or italic or oblique; \n>斜體\n\n#### text-transform: uppercase(大) or lowercase(小) or capitalize(每個字的第一個字變大寫);\n>大小寫 \n\n#### text-decoration: none or underline(底線) or overline(文字上方加線) or line-through(刪節線) or blink(動態閃爍);\n>底線和刪節線\n\n#### line-height: 1.5em;\n>行距\n\n#### direction: 靠左 'ltr' 及靠右 'rtl';\n>設定文字的方向\n\n#### text-align: left or right or center or justify; (段落除了最後一行外，每一行都應該佔據容器方框的整個寬度)\n>對齊\n\n#### text-shadow: 1px 2px #111111;(左右多遠,上下多遠,模糊量) \n>陰影(CSS3)\n\n## 盒子模型(box model)\n由四個部分組合：margin(外距)、border(邊框)、padding(內距)、content(內容)。它控制著頁面各元素的寬與高，比如當我們設定了一個元素的寬高時，所設定的數值還要再加上 padding 和 border，最後才會是這個元素的實際尺寸。如果一個區塊層級的元素位在另一個區塊層級元素內，那麼外面的方框就被稱為 **容器** 元素或 **父** 元素。\n  \n{% asset_img boxmodel.jpg This is an image %}\n\n#### width: 200px;\n>元素寬度：  \n單位有：px, em, %，css 3 多了 vw(可視視窗高) vh(可視視窗寬)。\n\n#### min-width max-width  \n>限制寬度\n\n#### height: 200px;\n>元素高度：  \n同上。\n\n#### min-height max-height  \n>限制高度  \n\nps.  \n**使用px：網頁上設定一個 100px\\*100px 的正方形，當我們縮放螢幕的時候，這個元素並不會隨著變動寬高。  \n使用 %：\n使用 % 的時候，如果我們的元素內並沒有任何內容，即使設定為 100%，是不會顯示出任何東西。  \n使用vh、vw：使用上和百分比很像，當填入 30vh 和 30vw 時，意思就是這個元素要占整個螢幕可視範圍的30%，很重要的是，這個區塊範圍會隨著瀏覽器的縮放而改變。設計 RWD 時，圖片大小可利用此單位。**\n\n#### margin: auto(瀏覽器自行設定) or %(與邊界元素有關) or px or em;\n>外距(兩個相連元素之間的間距)。  \n>>設定方式：  \n1.margin:上 右 下 左;  // 填入數值  \n2.margin:上下 左右;  \n3.margin:上 左右 下;  \n4.margin:四邊同値;  \n獨立設定：  \nmargin-top：與上方元素的距離  \nmargin-right：與右方元素的距離  \nmargin-bottom：與下方元素的距離  \nmargin-left：與左方元素的距離  \n\n#### padding: 同上，margin 改成 padding 即可。\n>內距(邊框跟內容之間的空間)，加入可提高閱讀性。  \n>>設定方式跟獨立設定同上。  \n\n#### border: 10px solid #000; //四邊(大小 樣式 顏色)\n>邊框\n>>設定方式：  \n1.border-width: 2px 1px 1px 2px; // 對應 上 右 下 左  \n2.border-style: solid 單實線  dotted 方格點 dashed 短線 double 兩條實線 groove 刻入頁面  ridge 突出頁面 inset 嵌入頁面 hidden/none 無邊框  \n3.border-color: red red red red; // 對應 上 右 下 左  \n4.border-image: url(\"圖片位置\") 11 11 11 11 stretch;   stretch 延伸影像 repeat 重複影像 round 重複影像\n5.border-radius: 5px, 10px, px, 10px;  // 圓角  \n若 border-radius 設定跟方框高度一樣，就可以做出圓形。                                                                                                                                                                  \n獨立設定：同 padding。  \n\n若要準確控制版面不破版，原本所設定的尺寸還需要再扣掉 border/padding，但是這樣每次設尺寸都要做計算，這時可以使用 `box-sizing` 此屬性，方便我們在設定 width、height 上更直觀。\n\n#### box-sizing: content-box or border-box or inherit;\n>content-box：預設值，元素實際寬高＝所設定的數值＋border＋padding。  \n>border-box：元素實際寬高＝所設定的數值(已包含border和padding)。  \n>inherit：繼承至父層的 broder-sizing 設定値。   \n\n \n```\n{\n width: 300px; // 設定寬度\n height: 100px; // 設定高度\n border: 1px solid black;  //設定框線樣式\n background-color: pink;  //設定背景\n margin:20px;       //設定外距\n padding:20px;      //設定內距\n box-sizing: border-box;  //設定border及padding值包含在長寬內\n}\n```\n\n#### display: inline 區塊轉為行內元素，與鄰近元素保持在同一行 block 行內元素轉為區塊，另起一行 inlien-block;  區塊元素像行內元素一樣流動，但保持區塊元素其他特性 none; 隱藏元素，頁面上看不到\n>更改行內/區塊狀態，將行內元素轉成區塊元素。\n\n#### visibility: hidden 隱藏 \n>隱藏元素，不顯示內容，但將原有位置空下(產生空白)。若不要有空白，用 display 屬性。\n\n## 位置\n#### position: top right bottom left(長度、百分比、或是 auto) static 預設 absolute 絕對 relative 相對 fixed \n>元素在網頁上的定位。\n\n**ps.  \nabsolute(絕對): 放在瀏覽器內的某個位置 (依 top、bottom、left、和 right 的值而定)。當使用者將網頁往下拉時，元素也會跟著改變位置。ps: 網頁的四個邊界開始起算。  \nrelative(相對): 元素擺在相對於另一個元素的任何地方。要定位的元素加上 `position:absolute` 還有(top,left,right,bottom)及對應的值，並且在他的父元素加上 `position:relative`，那個元素就可在在它的父元素範圍內任意定位。  \nfixed: 這代表元素會被放在瀏覽器內的某個位置 (依 top、bottom、left、和 right 的值而定)。當使用者將網頁往下拉時，元素的位置不會改變。** \n\n#### z-index: auto 預設值 數字 inherit 繼承自父層順序\n>用來決定元素重疊的順序，當兩個元素有重疊的情況時。z-index 值比較大個元素會被放在上面。\n\n\n#### float: left、right、none;\n>定義 box 的浮動，常見是將文字繞著一個圖案顯現或區塊排版。最後記得要使用清除浮動，避免跑版。\n\n#### clear: left、right、both、none;\n>清除用來抵銷 float 屬性的作用\n\n#### 某元素置中\n```\n{\n  margin: 0 auto;  // 元素置中\n  width: 200px;\n  text-align: center;  // 內容也置中\n}\n```\n#### overflow: auto 自動使用捲軸 visible 直接超出範圍，不使用捲軸 hidden 隱藏 scroll 捲軸 inherit 繼承自父元素\n>當 content 超出 box 時的處理。  \n\n## 游標樣式\n#### cursor: auto or crosshair pointer help wait url(\"位置\");\n\n# 元素定位處理(排版)還有其他方便的作法，例如 Flex、Grid ...\n## Flex\n#### Flex 中分為外容器與內元件  \n\n{% asset_img flexa.png This is an image %}\n\n\n### flex 外容器屬性  \n#### display: flex | inlien-flex;  \n>一開始就要宣告為 flex 才開始用  \n\n{% asset_img flex1.png This is an image %}\n  \n\n#### flex-direction: row | row-reverse | column | column-reverse\n>決定內元件排序方向，改變主軸線方向 — or |，預設狀態：\n\n{% asset_img flexb.jpg This is an image %}\n  \n\n>>row; //水平由軸線左至右排    \nrow-reverse  //水平由軸線右至左排  \ncolumn  //垂直由軸線上至下排  \ncolumn-reverse  //垂直由軸線下至上排  \n\n{% asset_img flex2.jpg This is an image %}\n\n\n#### flex-wrap: nowrap | wrap | wrap-reverse\n>超出範圍時是否換行動的屬性\n>>nowrap;   //不換行  \nwrap;   //換行  \nwrap-reverse;   //換行時反轉\n\n{% asset_img flex3.png This is an image %}\n\n\n#### flex-flow: \n>`flex-direction` 與 `flex-wrap` 的縮寫，在其前後帶上相對應的值即可 `flex-flow: row nowrap`;\n\n#### justify-content: flex-start; ...\n>內元件的元素主軸對齊(間隔)，看是 `flex-direction` 是 row or column\n>>flex-start;   //靠左對齊  \nflex-end;   //靠右對齊  \ncenter;   //水平置中對齊  \nspace-between;  //平均分配內元件，分開對齊(左右不留空)  \nspace-around;   //平均分配內元件，分開對齊(左右留空)  \n\n以 `flex-direction: row` 為例：\n\n{% asset_img flex4.jpg This is an image %}\n\n\n#### align-items: stretch; ...\n>相對於上面的屬性，交錯軸對齊設定   |\n>>flex-start;   //靠軸線上端對齊  \nflex-end;    //靠軸線下端對齊  \ncenter;   //置軸線中心對齊  \nstretch;  //預設值，延伸內元件全部撐開至 Flexbox 高度  \nbaseline; //以所有內元件的基線作為對齊標準(左右留空)\n\n{% asset_img flex5.jpg This is an image %}\n\n\n#### align-content: flex-start; ...\n>align-items 的多行版本，排列方式多一些\n>>flex-start;   //靠軸線上端對齊  \nflex-end;    //靠軸線下端對齊  \ncenter;   //置軸線中心對齊  \nstretch;  //預設值，延伸內元件全部撐開至 Flexbox 的高度  \nspace-between; //平均分配內元件，分開對齊(上下不留空)  \nspace-around;  //平均分配內元件，分開對齊(上下留空)  \n\n{% asset_img flex6.jpg This is an image %}\n\n \n### flex 內元件屬性  \n#### flex-grow: 數字;\n>元件的伸展性，預設值為 0。\n\n#### flex-shrink: 數字;\n>元件的收縮性，當空間分配還不足時的當前元件的收縮性，預設值為 0。  \n\n#### flex-basis: 單位值(px) | auto;\n>元件的基準值，以自己的基本小大為單位。\n\n#### align-self：center | flex-start | flex-end | stretch | baseline;\n>調整內元件交錯軸的對齊設定(主軸不能另外設定)，也可以個別設定單一元件。\n\n{% asset_img flex7.jpg This is an image %}\n\n\n#### order: 數字;\n>重新定義元件的排列順序，依據數值的大小\n\n## Grid\n#### 一樣分成內外容器。Grid 和 flex 最大不同之處，透過 grid template 來定義版型的結構，分別由 column 及 row 定義出直排與橫列的格線，內容再依隔線作安排。\n\n### 外容器\n#### display: grid | inline-grid | subgrid;\n>定義容器的顯示類型\n\n#### grid-template-columns: <track-size> ... | <line-name> <track-size> ...;\n>橫列\n>>track-size: 可使用彈性的長度、百分比或分數 (分數的部分需使用 fr 單位)  \nline-name: 可自行命名的名稱\n  \n#### grid-template-rows: <track-size> ... | <line-name> <track-size> ...;\n>直行\n>>track-size: 可使用彈性的長度、百分比或分數 (分數的部分需使用 fr 單位)  \nline-name: 可自行命名的名稱\n\n{% asset_img grid.png This is an image %}\n\n\n範例\n\n```\n.wrap {\n  display: grid;\n  grid-template-columns: 200px 50px auto 50px 200px;\n  grid-template-rows: 25% 100px auto;\n  height: 100vh;\n  width: 940px;\n  margin: 0 auto;\n}\n```\n\n{% asset_img grid1.png This is an image %}\n\n\n#### grid-template-columns: repeat(2, 1fr 2fr) 100px;\n>repeat({次數}, {格線...} | {格線...}) | {格線...}\n>>fr：空間單位  \nrepeat：重複隔線\n\n#### grid-template-areas:\n>透過 area 定義區塊在 template 上的位置，配合 gird-area \n>>內元素 grid-area：定義空間的名稱  \n外元素 grid-template-areas：定義空間的位置\n\n範例\n\n{% asset_img grid2.png This is an image %}\n\n\n```\n.wrap {\n  display: grid;\n  grid-template-columns: 200px 50px auto 50px 200px;\n  grid-template-rows: 25% 100px auto;\n  grid-template-areas:\n    \"header header header header header\"\n    \"side  main main main main\"\n    \"side footer footer footer footer\";\n  height: 100vh;\n  width: 940px;\n  margin: 0 auto;\n}\n.item-a {\n  grid-area: header;\n  background-color: purple;\n}\n.item-b {\n  grid-area: main;\n  background-color: orange;\n}\n.item-c {\n  grid-area: side;\n  background-color: green;\n}\n.item-d {\n  grid-area: footer;\n  background-color: gray;\n}\n```\n\n*ps.空間不能分離且是唯一的，錯誤範例: \"side main side\"*\n\n其他更詳細說明，請參考以下網站。\n\n## 補充說明：\n###CSS RESET\n各瀏覽器其實都有預設一些 CSS，我們稱之為瀏覽器默認樣式(User Agent Stylesheet)，為了增進瀏覽體驗，但是各家瀏覽器的默認樣式並不相同。因此寫一個網頁的時候，我們另外寫了 CSS 檔，而網頁顯示出來的畫面，實際上是瀏覽器默認樣式加上我們的 CSS 。也因而造成同一個網頁在不同的瀏覽器看到的畫面有點不一樣。為了處理這個問題，就有了 CSS RESET，它可以幫我們清除瀏覽器默認樣式，依照我們撰寫的 CSS 檔來顯示。這樣就可以統一樣式了。\n\n目前公認是 meyerweb 的版本。\n\n```\n/* http://meyerweb.com/eric/tools/css/reset/ \n   v2.0 | 20110126\n   License: none (public domain)\n*/\n\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, embed, \nfigure, figcaption, footer, header, hgroup, \nmenu, nav, output, ruby, section, summary,\ntime, mark, audio, video {\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tfont-size: 100%;\n\tfont: inherit;\n\tvertical-align: baseline;\n}\n/* HTML5 display-role reset for older browsers */\narticle, aside, details, figcaption, figure, \nfooter, header, hgroup, menu, nav, section {\n\tdisplay: block;\n}\nbody {\n\tline-height: 1;\n}\nol, ul {\n\tlist-style: none;\n}\nblockquote, q {\n\tquotes: none;\n}\nblockquote:before, blockquote:after,\nq:before, q:after {\n\tcontent: '';\n\tcontent: none;\n}\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\n``` \n\n\n參考：  \nhttps://w3bits.com/css-box-model/\nhttps://wcc723.github.io/css/2017/07/21/css-flex/  \nhttps://wcc723.github.io/css/2017/03/22/css-grid-layout/    \nhttps://pjchender.blogspot.com/2015/04/css-3vh-vw.html  \nhttps://blog.techbridge.cc/2017/02/03/css-grid-intro/\nhttps://gridbyexample.com/  \nhttps://css-tricks.com/snippets/css/complete-guide-grid/  \nhttps://developer.mozilla.org/zh-TW/docs/Web/CSS  \nhttps://ithelp.ithome.com.tw/articles/10214957  \nhttps://medium.com/change-or-die/css-%E5%85%A5%E9%96%80%E7%AD%86%E8%A8%98-%E4%B8%80-box-model-box-sizing-56ddc49ac89e  ","tags":["CSS"],"categories":["CSS"]},{"title":"JavaScript 操作 DOM","url":"%2F2019%2F12%2F12%2F2019-12-12-DOM%2F","content":"## HTML\nHypertext Markup Language），中文為「超文字標示語言」，是一種用來組織架構並呈現網頁內容的程式語言。網頁內容的組成，可能包含了段落、清單、圖片或表格...等。\n\n## JavaScript 操作 DOM 的一些方法\nDOM：文件物件模型(Document Object Model)， 瀏覽器幫 HTML 的元素節點轉換成 JavaScript 可以操作的物件。  \n#### 選取元素\n```\nlet element = document.querySelector('<element-name>');\n```\n#### 新增元素節點\n```\ndocument.createElement(\"div\");\n```\n\n#### 在某元素後面加入元素\n```\n.appendChild()\n```\n#### 移除該元素\n```\n.removeChild()\n```\n\n#### 改變元素裡面的文字內容\n```\n.innerText()\n```\n\n#### 改變元素文字及標籤內容\n```\n.innerHTML() \n```\n\n#### 新增元素節點樣式\n```\n.classList.add('樣式');\n```\n\n#### 刪除元素節點樣式\n```\n.classList.delete('樣式')\n```\n\n#### 監聽元素事件\n```\nelement.addEventLister('事件名稱', function(e){\n    // do something\n},<boolean>)\ntrue => 捕獲 ; false => 冒泡，不加參數的話，預設值是 false\n```\n\n#### e.g. click 事件(e.target 點擊到的元素)\n```\n<div id=\"test\"></div>  \n\n<script>\ndocument.getElementById(\"test\").addEventListener(\"click\", function( event ) {\n    // 在 “clicked div”顯示點擊次數\n    event.target.innerHTML = \"click count: \" + event.detail;\n  }, false);\n</script>\n```\n## DOM 事件傳遞機制\n#### 捕獲\n>根節點開始往下傳遞子節點然後到 target \n\n\n#### 冒泡\n>從 target 往上到子節點一路逆向傳回去根節點\n\n**DOM 事件傳遞的順序，先捕獲 -> 自身 -> 冒泡。**\n\n#### 取消事件傳遞 ```e.stopPropagation```\n*加在哪邊，事件傳遞就停在那，不向上(或下)級傳遞*\n\n```\nel.addEventListener('click', (e) => {\n  // e.eventPhase 回傳一個整數值以代表目前事件於事件流中的傳遞階段\t\n  console.log('el', e.eventPhase);\n  e.stopPropagation();\n}, true)\n```\n#### 取消預設行為 ```e.preventDefault()```\n*取消瀏覽器的預設行為*\n\n```\n// 超連結使用(不會新開分頁或是跳轉）\nel_link.addEventListener('click', (e) => {\n  e.preventDefault();\n}, false)\n// <form> 的 submit - 阻止送出表單\n// <input> 的 keypress 事件 - 阻止輸入按鍵\n```\n## 事件傳遞應用\n**事件代理(Delegation)**  \n利用 DOM 事件的冒泡特性，將子層元素的監聽事件綁定在父層元素上，好處有：  \n1.如果有很多子元素，就不用一一綁定監聽事件。 \n2.動態新增進來的子元素，因為也是會冒泡到上層，就不怕沒綁定到監聽。\n\n\n## 元素操作範例\n#### 印出 9*9  \n```\n(function() {\n    const chart = document.querySelector('#chart');  \n    for (let i = 2; i <= 9; i++) {        \n      const DIV = document.createElement('div'); // 新增 DIV 節點\n      DIV.classList.add('col-md-4');   // 新增 DIV 樣式\n      chart.appendChild(DIV);   // id=chart 的元素增加子節點 DIV\n      // chart.append  將字串插入到網頁元素\n      const UL = document.createElement('ul');\n      UL.classList.add('chart-list', 'list-unstyled', 'bg-light');\n      DIV.appendChild(UL);  \n      let str = `<li class=\"chart-num\">${ i }</li>`;// 2 ~ 9 // 組開頭數字 2~9 字串\n      //console.log('外層for', str);\n      for (let j = 1; j <= 9; j++) {    \n        str += `<li class=\"h4\">${ i } x ${ j } = ${ i*j }</li>`; // 2 x 1 ~ 9 x 9\n      //console.log('內層for', str);\n      }             \n      //console.log('結果', str);\n      UL.innerHTML = str;      // 將字串插入到網頁元素\n    }  \n  }());  //立即呼叫函式 IIFE\n```\n#### 印出正方形\n```\nfunction square(size){\n    const chart = document.querySelector('#chart1');\n    for (let i = 1; i <= size; i++) {  // 印出第i列\n      for (let j = 1; j <= size; j++) {  // 第i列有size個*\n        const sp = document.createElement('span');\n        sp.classList.add('col-md-4')\n        chart.appendChild(sp);  // 增加 span 元素\n        let str = `*`;\n        sp.innerHTML = str;     // 新增元素內容\n        }\n        const Br = document.createElement('br');\n        chart.appendChild(Br);   // 增加斷行元素\n    } \n};\n```\n#### 印出斜一邊的三角形\n```\nfunction sidetriangle(size) {\n  const chart = document.querySelector('#chart2');\n  for (let i = 1; i <= size; i++) {  // 印出第i列\n    for (let j = 1; j <= i; j++) {   // 第i列有i個*\n      const sp = document.createElement('span');\n        sp.classList.add('col-md-4')\n        chart.appendChild(sp);  // 增加 span 元素\n        let str = `*`;\n        sp.innerHTML = str;     // 新增元素內容\n    }\n      const Br = document.createElement('br');\n      chart.appendChild(Br);   // 增加斷行元素\n  }\n};\n```\n\n參考：  \n[MDN](https://developer.mozilla.org/zh-TW/docs/Web/API/Document_Object_Model)  \n[DOM 的事件傳遞機制：捕獲與冒泡](https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/)\nhttps://yakimhsu.com/project/project_w10_review_DOM&EventListener.html  \n","tags":["DOM"],"categories":["DOM"]},{"title":"Git 基本介紹","url":"%2F2019%2F12%2F11%2F2019-12-12-Git%2F","content":"簡單記錄一下 Git 學習過程 \n## Git\n* Git 是一個分散式版本控制軟體，可藉由它產生一個*儲存庫( git Repository)*。\n* 可在自己本機電腦跟遠端伺服器儲存及管理檔案，並做同步處理。\n* 紀錄管理有使用 Git 的目錄內的檔案增刪、檔案內容的修改。\n* 有圖形化介面可以使用，例如：SourceTree。  \n\n## 終端機指令介紹\n在操作 Git 之前，先來介紹一下終端機的基本指令  \n#### ls \n>查看目錄中的檔案列表\n\n#### ls -la\n>列出隱藏文件\n\n#### cd ~\n>前往主目錄\n\n#### pwd \n>查看目前所在目錄位置\n\n#### mkdir test \n>建立 test 的子目錄\n\n#### cd test \n>切換到 test 目錄\n\n#### cd .. \n>回到上層目錄\n\n#### touch index.html \n>新增 html 檔,若目錄內已有檔案時,會修改檔案時間\n\n#### cp \n>複製文件\n\n#### mv\n>移動檔案\n\n#### rm index.html\n>刪除檔案\n\n#### rm -R \n>刪除資料夾與其內所有檔案\n\n## 安裝Git\n**到官方網站根據自己的作業系統下載**  \n[https://git-scm.com/downloads](https://git-scm.com/downloads)\n\n**或是透過 Homebrew 來下載**  \n[https://brew.sh/index_zh-tw.html](https://brew.sh/index_zh-tw.html)\n\n```\n$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n複製以上內容，到終端機視窗貼上並執行。\n安裝完後，再複製以下內容，\n\n```\n$ brew install git\n```\n到終端機視窗貼上並執行。\n\n## 使用者設定\n剛開始使用時 Git ，首先要設定名稱跟 e-mail 信箱  \n\n```\n$ git config --global user.name \"your_name\"\n$ git config --global user.email \"your_email\"\n```\n\n## Git 區塊\nGit 有三個檔案存放區塊  \n{% asset_img block.jpg This is an image %}\n  \n\n如圖所示，分為  \n**工作目錄** (未 add )，初始狀態。  \n**暫存區** (已 add ，未 commit )  \n**儲存區** (已 commit )  \n\n## Git 指令(終端機)\n\n#### git init \"要板控的專案目錄\"\n>初始化專案，開始版控\n\n#### git add .要放入存放區的檔案 \n>(ex.  git add .gitignore )\n\n#### git add .   \n>當前目錄所新增及修改的檔案加到暫放區(若是在根目錄執行，大致上等於 git add -A)\n\n#### git add -A \n>整個專案目錄所有的修改都加入到暫放區\n\n#### git status\n>看暫放區狀態\n\n#### git commit -m \"提交訊息(註解)\"\n>加入註解後，將專案目錄儲存到儲存庫  \n\n#### git log —oneline\n>看訊息\n\n#### git blame index.html\n>查看檔案內容是誰修改(e.g. index.html)\n\n## Git 分支\n#### git branch '分支名稱'\n>新增分支 dog(分支可當成貼上標籤)\n\n#### git branch -d '分支名或id' \n>刪除分支，若參數為 -D ，則是強制刪除\n\n#### git branch \n>查看分支  名稱前有 * 的是 head 所在\n\n#### git branch -f master 版本號碼 \n>將 master 移至該版本號碼\n\n#### git checkout '分支名稱或版本id' \n>切換到該分支或該版本\n\n#### git checkout -b dog \n>建立 dog 分支並切換過去\n\n#### git merga '分支名稱' \n>合併該分支\n\n#### git rebase '分支名稱'(另一種合併方式 ) \n>改變 base (不會產生合併節點)\n\n#### git reset commit_id(變回該版本)  \n>回到某個版本，原本內容會回到工作目錄  \n--mixed  檔案丟回工作目錄  \n--soft   檔案丟回暫存區  \n--hard   直接刪掉\n\n#### git reflog \n>看 log\n\n#### git reset commit_id^ \n>回到該版本的前一個狀態 幾個 **^** 等於回前幾個\n\n#### git reset HEAD~2\n>回到 HEAD 的前2個狀態\n\n#### git tag 1.0.0 commit_id \n>貼上標籤\n\n#### git revert \n>撤消一個commit 同時建立一個新的\n\n## 遠端資料庫操作(e.g. GitHub)  \n*ps.先到 GitHub 新增一個儲存庫*\n\n#### git remote add origin \"遠端 git 網址\"\n>連接遠端儲存庫。origin 代表遠端節點，名稱可修改。\n\n#### git remote -v  \n>查看遠端 Git 的目的地  \n\n#### git push origin master  \n>把本地的 master 分支推送到 origin 這個遠端節點並在遠端形成一個 master 分支  \n\n#### git pull origin master  \n>到 origin 這個遠端節點, 抓 master 分支的內容,並在本地電腦建立一個 origin/master 分支,同時與本地的 master 分支進行合併\n\n#### git fetch origin master  \n>到 origin 這個遠端節點, 抓 master 分支的內容,並在本地電腦建立一個 origin/master 分支\n\n#### git clone \"遠端 Git 網址\"\n>把遠端 Git 網址的內容複製ㄧ份到本地端電腦\n\n## Git 情況處理\n### 1.遠端內容比本機上的新  \nGit push 時發生以下錯誤：\n>error: failed to push some refs to 'https://github.com/xxxx/xxx.git'  \nhint: Updates were rejected because the remote contains work that you do  \nhint: not have locally. This is usually caused by another repository pushing  \nhint: to the same ref. You may want to first integrate the remote changes  \nhint: (e.g., 'git pull ...') before pushing again.  \nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n  \n這段訊息的意思是線上版本的內容比你電腦裡這份還要新，所以 Git 不讓你推上去。可用  **git pull origin master —rebase** (內容抓下來之後請使用 Rebase 方式合併。)\n盡量不要用 **git push -f origin master** 會把自己的檔推上去蓋掉他人的,並以自己的為主。  \nps.多人的話,盡量開自己的分支來做\n### 2.不想在 Git 內放機密檔案\n\n$ touch .gitignore (建立Git 忽略檔案, 然後去編輯 gitignore. 已經存在的黨無效) \n\n內容可放  \nnom-debug.log  npm除錯紀錄  \nnode_modules 專案依賴關係  \n.DS_Store  OSX資料夾屬性    \n*.tmp 暫時性檔案  \n*~\n\n## 不想再用版控\n把 **.git** 目錄刪除就可以\n\n參考   \n[為你自己學 Git](https://gitbook.tw)  \n[Git: 如何從特定 commit 切新的分支？](https://cythilya.github.io/2019/12/03/git-detached-head-to-a-new-branch/)","tags":["Git"],"categories":["Git"]},{"title":"基本陣列操作","url":"%2F2019%2F12%2F10%2F2019-12-10-%E5%9F%BA%E6%9C%AC%E9%99%A3%E5%88%97%E6%93%8D%E4%BD%9C%2F","content":"## 介紹一下陣列基本操作的幾個方法\n\n####  建立陣列\n  \n```javascript\nconst arr = [1,2,3,4,5];    \nconst arr = new Array(1, 2, 3, 4, 5);  \nconst arr = Array(1,2,3,4,5);\n```\n####  陣列長度 \n  \n```javascript \nconsole.log(arr.length);  // 5\n```\n####  設定長度  \n  \n```javascript\nconst arr = new Array(5);\n```\n####  空陣列\n  \n```javascript  \nconst arr = [];\n```\n####  讀取其中一個元素，索引從零開始，對應第一個元素  \n  \n```javascript\nconsole.log(arr[0]);  // 1\n```\n####  設定陣列長度可以操作陣列內元素，長度若為零。則輸入空陣列\n  \n```javascript\narr.length = 0;\nconsole.log(arr);  // []\n```\n####  Array.from() 可建立一個新的 Array 實體  \n  \n1.從字串\n  \n```javascript\nArray.from('Hi');  // [\"h\", \"i\"]\n```\n\n2.從集合：集合會將集合內重複的元素剔除，可作分類使用\n  \n```javascript\nvar s = new Set(['hi', 1, 1, 2]); \nArray.from(s);\nconsole.log(s);  // {\"hi\", 1, 2}  \n```\n  \n### 迭代(讀取每一個值，然後用同樣的方式處理每一個值)\n  \n#### for 迴圈取陣列元素\n  \n```javascript\nconst arr = [1,2,3,4,5];\nfor (let i = 0; i < arr.length; i++) {\nconsole.log(arr[i]); // 依序輸出 1 2 3 4 5 \n}\n// 另一種寫法\nlet arr = [1, 2, 3, 4, 5];\nfor (let index in arr) { \n    console.log(arr[index]); 依序輸出 1 2 3 4 5\n}\n```\n#### foreach：將陣列內每個元素，都傳入並執行指定函式一次。\n\n```javascript\n// 取陣列中大於 3 的數字\nconst arr = [1, 2, 3, 4, 5];\nlet arr1 = [];\narr.forEach((value) => {\nif (value > 3){\n  arr1.push(value);\n}\n});\nconsole.log(arr3);    // [4,5]\n```\n## 方法\n\n#### push()：新增元素 \n  \n```javascript\nconst arr = [1,2,3,4,5]  \narr.push(6); // [1, 2, 3, 4, 5, 6]\n```\n#### pop()：取出陣列最後一個元素並從陣列移除 \n  \n```javascript\nconst arr = [1,2,3,4,5];\nlet el = arr.pop(); // el = 5\nconsole.log(arr); //  [1,2,3,4]\n```\n#### concat()：合併兩個陣列，並把新的陣列返回\n\n```javascript\nvar a1 = [1, 2];\nvar a2 = a1.concat(['a', 'b']);\nconsole.log(a2); // 1,2,a,b\n```\n#### join()：把所有的陣列元素合併成字串\n\n```javascript\nvar a = ['Hello', 'world'];\nconsole.log(a.join('-')); // \"Hello-world\"\nconsole.log(a.join('')); // \"Helloworld\"\n```\n#### reverse()：反轉陣列元素的順序至適當的位置\n\n```javascript\nconst arr = [1,2,3,4,5];\narr.reverse();\nconsole.log(arr);  // [5, 4, 3, 2, 1]\n```\n#### ps.反轉字串應用\n\n```javascript\nconst str = 'Hello';\n// split 將字串以指定的分隔符號來分割 \nstr1 = str.split('').reverse().join('');\nconsole.log(str1);     // olleH \n```\n#### shift()：取回陣列的第一個元素並移除\n\n```javascript\nconst arr = [1,2,3,4,5];\nlet a = arr.shift();\nconsole.log(a)    // 1\nconsole.log(arr); // [2, 3, 4, 5]\n```\n#### unshift()：在陣列的開頭處加入一個以上的元素\n\n```javascript\nconst arr = [1,2,3,4,5];\narr.unshift(6)    \nconsole.log(arr); // [6, 1, 2, 3, 4, 5]\n```\n#### slice(start_index, upto_index)：回傳部分陣列\n\n```javascript\nconst arr = [1,2,3,4,5];\narr.slice(1,4)  // arr[1] 到 arr[3] 之間的元素\nconsole.log(arr); // [2, 3, 4]\n```\n#### splice(start, deleteCount, item1, ... )：刪除既有元素／或加入新元素來改變一個陣列的內容\nstart：開始位置\ndeleteCount：刪除幾個元素(0 就是不刪除)\nitem1：要加入的元素\n\n```javascript\nconst arr = [1,2,3,4,5];\nlet removed = arr.splice(1, 0, 3)\nconsole.log(removed);  // []\nconsole.log(arr);      // [1, 3, 2, 3, 4, 5]\n\nlet removed2 = arr.splice(1, 2, 3)\nconsole.log(removed2); // [3, 2]\nconsole.log(arr);      // [1, 3, 3, 4, 5]\n```\n\n#### sort()：排序陣列的元素，預設的排序順序是根據字串的 Unicode 編碼位置\n\n```javascript\nconst arr = ['bob', 'alice', 'jack'];\narr.sort();  \nconsole.log(arr); // [\"alice\", \"bob\", \"jack\"]\n```\n\n#### ps.也可以用函式來決定如何排序(陣列數字排列要用這種方式)\n\n```javascript\nconst arra = [2,6,1,8,10,32];\n// 數字排列小到大\n  arra.sort(function(a, b){\n  return a - b;\n  });\nconsole.log(arra);     // [1, 2, 6, 8, 10, 32]\n// 數字排列大到小\n  arra.sort(function(a, b){\n  return b - a;\n  });\nconsole.log(arra);     //  [32, 10, 8, 6, 2, 1]\n```\n#### ps.陣列數字找大小：用展開運算子將陣列展開成個別值就可以用函式快速找出\n\n```javascript\n// 陣列數字找大小\nconst arra = [2,6,1,8,10,32];\nlet max = Math.max(...arra);\nlet min = Math.min(...arra);\nconsole.log(max, min);   // 32, 1\n```\n#### indexOf()：尋找陣列中是否有符合的元素，回傳 -1，表示沒有，回傳正整數表示在那個位置\n\n```javascript\nconst arr = [1,2,3,4,5];\nconsole.log(arr.indexOf(3));  // 2\n```\n#### ps.jQuery 用法\n\n```javascript\nconst arr = [1,2,3,4,5];\nconsole.log($.inArray(2, arr));  // 1\n```\n#### includes：陣列中尋找指定元素，回傳 true(找到)或 false(沒找到)\n\n```javascript\nconst arr = [1,2,3,4,5];\nconsole.log(arr.includes(2));  // true\n```\n#### filter()：回傳符合條件的元素，得到一個新陣列\n\n```javascript\nconst arr = [1,2,3,4,5];\nlet arr1 = arr.filter((value) => {\n  return value > 3;\n  });\nconsole.log(arr1);   // [4,5]\n```\n#### indexOf 與 $.map 使用，尋找是否有符合的物件\n\n```javascript\nconst people = [\n  { name: 'Peter', age: 10 },\n  { name: 'John', age: 3 },\n  { name: 'Nina', age: 15 }\n];\n//find object in list\nlet result = $.map(people, function(item, index) {\n  return item.name\n}).indexOf('Nina');\nconsole.log(result); //2\n```\n\n#### map()：原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合成為一個新陣列，常用對陣列元素做加工\n\n```javascript\nconst arr = ['a', 'b', 'c'];\nlet arr1 = arr.map((value) => {\n    return value.toUpperCase() ;\n  });\nconsole.log(arr1);   // [\"A\", \"B\", \"C\"]\n```\n#### every()：檢查陣列是否全部符合條件，僅會回傳一個值 true or false\n\n```javascript\nconst arr = [1,2,3,4,5];\nlet arr1 = arr.every((value) => {\n  return value >= 1;\n  });\nconsole.log(arr1);   // true\n```\n#### some()：檢查陣列元素其中是否有符合條件，僅會回傳一個值 true or false\n\n```javascript\nconst arr = [1,2,3,4,5];\nlet arr1 = arr.some((value) => {\n  return value === 3;\n  });\nconsole.log(arr1);   // true\n```\n\n#### reduce()：陣列變成個別值，傳入函式內處理。數值加總是常見做法\n\n```javascript\nconst arr = [1,2,3,4,5];\n// 處理每個元素後等待回傳結果，第一次處理時代入初始值 0\nlet result = arr.reduce((prev, value) => {\n// 與之前的數值加總，回傳後代入下一輪的處理\n  return prev + value;\n  }, 0);  // 初始值為零\nconsole.log(result);   // 15\n```\n#### ps.陣列扁平化，將複雜的陣列變成一維\n\n```javascript\nconst myArr = [\n    [ 1, 2 ],\n    [ 3, 4, 5 ],\n    [ 6, 7, 8 ]\n];\n// 將所有元素都與之前代入的陣列相接起來，第一次處理時代入初始值空陣列\nlet newArr = myArr.reduce(function(arr, element) {\n    // ex: [ 1, 2 ].concat([ 3, 4, 5 ])\n    return arr.concat(element);\n}, []);\nconsole.log(newArr); // [ 1, 2, 3, 4, 5, 6, 7, 8 ]\n\n// 1.將空陣列與 [ 1, 2 ] 相接起來後回傳\n// 2.將被代入的 [ 1, 2 ] 與 [ 3, 4, 5 ] 相接起來後回傳\n// 3.將被代入的 [ 1, 2, 3, 4, 5 ] 與 [ 6, 7, 8 ] 相接起來後回傳\n```\n#### ps.對陣列的內容進行統計\n\n```javascript\nconst myArr = [\n    'C/C++',\n    'JavaScript',\n    'Ruby',\n    'Java',\n    'Objective-C',\n    'JavaScript',\n    'PHP'\n];\n\n// 計算出每種語言出現過幾次\nlet langStatistics = myArr.reduce(function(langs, langName) {\n    // hasOwnProperty() 回傳物件是否有該屬性的布林值。\n    if (langs.hasOwnProperty(langName)) { \n        langs[langName]++\n    } else {\n        langs[langName] = 1;\n    }\n    \n    return langs;\n}, {});\nconsole.log(langStatistics);\n// { 'C/C++': 1, 'JavaScript': 2, 'Ruby': 1, 'Java': 1, 'Objective-C': 1, 'PHP': 1 }\n```\n#### ps. Object 的形式的處理\n\n```javascript\nconst data = {\n    'Fred': 1,\n    'Leon': 2,\n    'Wesley': 3,\n    'Chuck': 4,\n    'Denny': 5\n};\n\n// 使用 Object.keys() 取得包含所有 key 的陣列\nlet result = Object.keys(data).reduce(function(prev, name) {\n    // 利用 key 取得原始物件中的值，然後加總\n    return data[name] + prev;\n}, 0);\n\nconsole.log(result); // 15\n\n// Object.keys()：回傳一個由指定物件所有可列舉之屬性(key)組成的陣列\nObject.keys(data) // [\"Fred\", \"Leon\", \"Wesley\", \"Chuck\", \"Denny\"]\ndata[Fred] // 1\n\n```\n\n#### ps. map() 和 reduce() 結合使用\n\n```javascript\nconst arr = [1,2,3,4,5,6,7,8,9,10];\nlet result = arr.map((value) => {\n  if (value > 5) {\n    return 5;\n  }\n    return value;\n })\n.reduce((prev, value) => {\n  return prev + value;\n  }, 0);  // 初始值為零\nconsole.log(result);   // 40\n```\n\n\n\n\n參考資料  \nhttps://www.hexschool.com/2017/09/01/2017-09-01-javascript-for/\nhttp://fred-zone.blogspot.com/2017/01/javascript-mapreduce.html\nhttps://cythilya.github.io/2017/05/08/javascript-find-item-in-an-array/\nhttps://developer.mozilla.org/zh-TW/","tags":["array"],"categories":["JavaScript"]},{"title":"CSS偽類與偽元素","url":"%2F2019%2F06%2F05%2F2019-06-05-CSS%2F","content":"\n### 偽元素 (pseudo element) 和偽類 (pseudo class) 差在哪\n\n有時候 CSS 裡會出現單冒號 : 跟雙冒號 :: 的符號，\n單冒號開頭的是偽類 (pseudo class) ，\n雙冒號開頭的是偽元素 (pseudo element) 。\n\n一般常見的偽類有:  \n1. 動態：:link、:hover、:active、:focus、:visited  \n2. 元素狀態：:disabled、:enabled、:checked  \n3. 結構：:root、:nth-child、:nth-last-child、:nth-of-type、:nth-last-of-type、:first-child、:last-child、:first-of-type、:last-of-type、:only-child、:only-of-type、:empty\n\n偽元素有:\n1. ::first-line：選取第一行  \n2. ::first-letter：選取第一個字  \n3. ::before：從選取元素的前面加入元素  \n4. ::after：從選取元素的後面加入元素  \n5. ::selection：選取文字反白後  \n\nps.現在單一冒號 `:` 也可以代表偽元素，但要注意瀏覽器是否支援。\n\n## 補充\n#### SCSS 的 & 符號\n是scss的语法，代表上一層選擇器(元素)\n\n有時會看到類似寫法 \n\n```\n.bordered {\n  &.float {\n    float: left; \n  }\n  .top {\n    margin: 5px; \n  }\n}\n```\n\n其實上面寫法等同於\n\n```\n.bordered.float {\n  float: left; \n}\n.bordered .top {\n  margin: 5px;\n}\n```\n\n`.bordered.float` 是串聯選擇器，作用在同一標籤上  \n`.bordered .top` 是後代選擇器，作用在不同標籤上\n\n有時 CSS 中有定義一些 pseudo-classes (或稱偽類、準類別)，被使用來為元素增加一些特效，如 `:hover`, `:link`, `:visited`,  `:before`, `:after` 等這些以冒號(:)開頭的類別名稱。例如把滑鼠移到某個網頁連結時，連結會變色的 CSS 語法：\n\n\n```\na {\n  font-weight: bold;\n  text-decoration: none;\n}\na :hover {\n  color:#FF00FF;\n}\n```\n\n上述其實還是一種巢狀的結構，只是都作用到同一個元素(例如範例的 a 元素)上。這樣情況就能夠用對 `:hover` 使用 `＆` 符號來代表其作用的父選取器，所以上述的 CSS 範例的 Sass 就可以寫成：\n\n```\na {\n  font-weight: bold;\n  text-decoration: none;\n  &:hover {\n    color:#FF00FF;\n  }\n}\n```\n\n\n參考來源：\n[oxxostudioCSS 偽類 child 和 of-type](https://www.oxxostudio.tw/articles/201405/css-selector.html)","tags":["CSS"],"categories":["CSS"]},{"title":"Markdown語法","url":"%2F2019%2F05%2F29%2F2019-05-29-Markdown%E8%AA%9E%E6%B3%95%2F","content":"*Markdown*\n\nMarkdown 是一種輕量級標記式語言它有純文字標記的特性，讓編寫的可讀性提升不少。目前已有不少網站都使用 Markdown 來撰寫文件或是在網站上發表文章。\n\n現在來介紹幾個常用的語法:\n\n### 粗體\n\n語法\n`***bold***`\n顯示畫面\n***bold***\n\n### 標題字\n語法\n`# This is an tag`\n顯示畫面\n# This is an tag\n\n### 列表\n\n語法\n{% asset_img 1.png %}\n顯示畫面\n* item 1\n* item 2\n   * item 2a\n   * item 2b\n\n### 編號列表\n\n語法\n{% asset_img 2.png %}\n顯示畫面\n1. Item 1\n1. Item 2\n1. Item 3\n   1. Item 3a\n   1. Item 3b\n\n### CheckBox\n\n括號中的 x 就代表此項目是有勾選的，它並不會主動紀錄勾選過的內容，所以使用時要注意確認。\n\n`- [x] This is a complete item`\n`- [  ] This is an incomplete item`\n\n顯示畫面\n- [x] This is a complete item\n- [ ] This is an incomplete item\n\n\n### 區塊\n\n區塊分為小區塊跟大區塊，通常用於一段相關內容的撰寫，一小段文字或是註釋可用小區塊來表示，內容較多又不想跟一般段落內容混在一起的話，則會用大區塊來表示。\n小區塊語法：\n```\n`Format one word or one line`\n```\n大區塊語法：\n```\n    code (4 spaces indent)\n```\n顯示畫面：\n\n`Format one word or one line`\n\n    code (4 spaces indent)\n\n### 程式碼\n\n只要使用三個反引號加上語言簡稱就可以了。\n高亮程式碼顯示語法\n    \n````js\nvar n=1;\nvar b=2,c=3;\neval('a'+n+'=b*c');\n````\n    \n### 圖片\n\n插入圖片語法\n`![GITHUB](_圖片網址 \"圖片名稱\"_)`\n```\n{% asset_img Steve.jpg This is an image %}\n```\n![GITHUB](_圖片網址 \"圖片名稱\"_)\n{% asset_img Steve.jpg This is an image %}\n\n### 階層式區塊\n#### 階層式區塊在表現結構或功能關係上是相當好用的呈現形式\n語法：\n\n\\> Quote one sentences\n\\>>Quote two sentences\n\\>>Quote two sentences\n\\>>>Quote three sentences\n\n顯示結果：\n> Quote one sentences\n>>Quote two sentences\n>>Quote two sentences\n>>>Quote three sentences\n\n### Images\n\n![GitHub Logo](/images/logo.png)\nFormat: ![Alt Text](url)\n\n### Links\n\n語法\n`http://github.com - automatic!`\n`[GitHub](http://github.com)`\n\n顯示\nhttp://github.com - automatic!\n[GitHub](http://github.com)\n\n### Inline code\n\nI think you should use an\n`<addr>` element here instead.\n\n### Tables\n\n語法\n\nFirst Header | Second Header\n-----------------| ---------------------\nContent from cell 1 | Content from cell 2\nContent in the first column | Content in the second column\n\n顯示\n\nFirst Header | Second Header\n----------------- | ---------------------\nContent from cell 1 | Content from cell 2\nContent in the first column | Content in the second column\n\n\n\n參考來源：\n[Markdown - 易編易讀，優雅的寫文吧！ - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天](https://ithelp.ithome.com.tw/articles/10203758)\n[Mastering Markdown · GitHub Guides](https://guides.github.com/features/mastering-markdown/)\n[Markdown文件](https://markdown.tw/#autoescape)\n\n","tags":["Markdown"],"categories":["Markdown"]},{"title":"JavaScript eval()的用法","url":"%2F2019%2F05%2F29%2F2019-05-29-JavaScript-eval%2F","content":"eval() 是個滿好用的函式，用途也多種，常常會使用到。\n\neval 是 evaluates 。例如：\n```js\nvar n=1;\nvar b=2,c=3;\neval('a'+n+'=b*c');\n```\n\n上面結果會變成 a1=b*c ，就是變數 a1 的結果為 6。\n\n由以上可知，eval() 是把一組字串，當作指令來執行，並得出結果。\n實作時，在訂單處理上應用較廣，例如以下是份簡單訂單：\n\n數量 | 單價 | 小計\n-------|--------|------\nQ1  |  P1  |  T1\nQ2  |  P2  | T2\nQ3  |  P3  | T3\n\n用編號來進行不同筆數訂單欄位命名，而不是每個欄位獨立命名，顯示，在輸入數量及單價後，小計要能自動計算。\n\n假設這份表單名為 order，所以：\n\ndocument.order.T1.value=document.order.Q1.value\\*document.order.P1.value;\ndocument.order.T2.value=document.order.Q2.value\\*document.order.P2.value;\ndocument.order.T3.value=document.order.Q3.value\\*document.order.P3.value;\n\n你是不是會想用 for 來跑迴圈？可是，T1、;Q1 這些欄位名稱一直在變，怎麼跑迴圈呢？這時，eval() 就派上用場了，eval() 把「唸的內容」當結果執行，這個例子怎麼唸呢？\n\n「第一個 T 的值等於第一個 Q 的值乘以第一個 P 的值」，換成 \n\n```js\neval()：\nvar form=document.order;\nfor (var i=1;i<=3;i++){\n    eval('form.T'+i+'value=form.Q'+i+'value(form.P'+i+'value');\n}\n```\n把 eval() 裡的字串，i 的值分別用 1,2,3 套入，結果和前面寫一大串三行的效果一模一樣。\n\n參考來源：\n[icodding愛程式: JavaScript 的 eval() 用法介紹](http://icodding.blogspot.com/2015/12/javascript-eval.html)","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Hello World","url":"%2F2019%2F05%2F26%2Fhello-world%2F","content":"{% asset_img Steve.jpg This is an image %}\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]