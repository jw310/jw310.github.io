<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用 Chart.js 來做資料視覺化]]></title>
    <url>%2F2020%2F05%2F28%2Fchartjs%2F</url>
    <content type="text"><![CDATA[Chart.jsChart.js 是款好用的圖表 JavaScript library，支援折線圖(line)、長條圖(bar)、雷達圖(radar)、圓餅圖(pie &amp; doughnut)、圓面積圖(polarArea)、氣泡圖(bubble)、分布圖(scatter)，也夠將圖表混合在一起使用，也有支援動畫效果。下列就用 Vue 結合 Chart.js 來做範例。 安裝NPM npm install vue-chartjs chart.js --save CDN &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.1/Chart.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-chartjs/dist/vue-chartjs.min.js&quot;&gt;&lt;/script&gt; 使用先建立 Chart.vue 檔，作為元件來使用。 Chart.vue 先引用 import { Line, mixins } from &#39;vue-chartjs&#39; Line 是要使用的圖表類別。 跟 const { reactiveProp } = mixins mixins 中的 reactiveProp 會自動建立名為 chartData 的 prop 並同時添加 watch 在這 prop 上，只要 data 改變，會自動更新圖表資料。讓我們可以更方便使用。 接下來，參考官方文件完成下列程式碼。 e.g. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;script&gt;import &#123; Line, mixins &#125; from &apos;vue-chartjs&apos;const &#123; reactiveProp &#125; = mixinsexport default &#123; extends: Line, mixins: [reactiveProp], data: () =&gt; (&#123; options: &#123; // RWD responsive: true, maintainAspectRatio: false, // 尺度、比例 scales: &#123; // y軸 yAxes: [ &#123; ticks: &#123; beginAtZero: true, stepSize: 1, fontSize: 20, fontColor: &apos;green&apos; &#125; &#125; ] &#125;, legend: &#123; position: &apos;right&apos;, align: &apos;start&apos;, labels: &#123; fontColor: &apos;black&apos;, fontSize: 16, fontFamily: &apos;Microsoft YaHei&apos;, padding: 30, &#125; &#125;, // 動畫效果 animation: &#123; // 持續時間 duration: 1000, // 完成後執行 // onComplete: function() &#123; // alert(&apos;hi&apos;) // &#125; &#125;, &#125; &#125;), // 隨資料重複渲染畫面 mounted() &#123; this.chartRender() &#125;, methods: &#123; chartRender() &#123; this.renderChart(this.chartData, this.options) &#125; &#125;&#125;&lt;/script&gt; 建立 ChartLine.vue 檔，圖表資料部分也由此傳入 Chart.vue。通常資料來源會由外部提供，因此可以加入 loaded 資料欄位來控制加上 v-if。等資料透過非同步技術取得後，再渲染出畫面。另外可使用 computed 來改變自訂圖表樣式。 ps.記得要設定 position: ‘relative’ e.g. ChartLine.vue Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;div&gt; &lt;chart v-if=&quot;loaded&quot; :chart-data=&quot;chartData&quot; :styles=&quot;myStyles&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import chart from &apos;../components/Chart.vue&apos;export default &#123; components: &#123; chart &#125;, data: () =&gt; (&#123; // 處理資料非同步問題，確認有資料後，才畫圖 loaded: true, width: 500, chartData: &#123; // 位於 x 軸的各筆數據 key labels: [&apos;今天&apos;, &apos;昨天&apos;, &apos;前天&apos;,&apos;一週前&apos;], // 圖表 datasets: [ &#123; // x 軸的標籤項目 label: &apos;排名&apos;, backgroundColor: [ &apos;rgba(255, 99, 132, 0.2)&apos;, &apos;rgba(54, 162, 235, 0.2)&apos;, &apos;rgba(255, 206, 86, 0.2)&apos; ], borderColor: [ &apos;rgba(255,99,132,1)&apos;, &apos;rgba(54, 162, 235, 1)&apos;, &apos;rgba(255, 206, 86, 1)&apos;, ], borderWidth: 5, // 位於 y 軸對應的各筆數據 value data: [&apos;2&apos;, &apos;3&apos;, &apos;2&apos;], &#125;, &#123; label: &apos;排名2&apos;, backgroundColor: [ &apos;rgba(255, 99, 132, 0.2)&apos;, &apos;rgba(54, 162, 235, 0.2)&apos;, &apos;rgba(255, 206, 86, 0.2)&apos; ], borderColor: [ &apos;rgba(255,99,132,1)&apos;, &apos;rgba(54, 162, 235, 1)&apos;, &apos;rgba(255, 206, 86, 1)&apos;, ], borderWidth: 5, data: [&apos;1&apos;, &apos;2&apos;, &apos;1&apos;], &#125; ] &#125; &#125;), computed: &#123; myStyles () &#123; return &#123; width: `$&#123;this.width&#125;px`, position: &apos;relative&apos; &#125; &#125; &#125;&#125;&lt;/script&gt; 完成圖如下： 補充： chart-data 的格式必須遵照官方文件，為物件型態。 watch 只會偵測物件本身的改變，而非其屬性的變化(更新資料時只會更新屬性資料)，所以父組件在傳 chartData 給子組件時必須傳物件的複製，不然 watch 會無法偵測到 props 變化，因此需要 return 一個新的物件提供給子組件。 參考：https://medium.com/@tiahi5914/前端筆記-在-nuxt-js-專案中使用-vue-chartjs-ca799560ba44https://vue-chartjs.org/guide/#vue-single-file-components]]></content>
      <categories>
        <category>Vue</category>
        <category>Chartjs</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
        <tag>Chartjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvectormap 地圖套件]]></title>
    <url>%2F2020%2F05%2F20%2Fjvectormap%2F</url>
    <content type="text"><![CDATA[Jvectormap基於 jQuery 的地圖套件，地圖由 SVG 生成。 引用link rel=&quot;stylesheet&quot; href=&quot;css/jquery-jvectormap-2.0.5.css&quot;&gt; &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/jquery-jvectormap-2.0.5.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/jquery-jvectormap-world-mill.js&quot;&gt;&lt;/script&gt; ps. 記得 jvectormap-2.0.5.min.js 要放在 bootstrap.min.js 之後，因為 bootstrap 會覆寫掉 jQuery 設定 去官網下載地圖後引用 https://jvectormap.com/maps/world/world/ 有說明載入地圖語法，例如: Code123$(&apos;#map&apos;).vectorMap(&#123; map: &apos;world_mill&apos;&#125;); 網路上方法多將 $(&#39;#map&#39;).vectorMap({}) 寫在 HTML 檔裡。這裏我將其寫在 js 檔內，除了引入順序外。另外換一下寫法。 Code1234&lt;script src=&quot;js/all.js&quot;&gt;&lt;/script&gt;&lt;script&gt; map();&lt;/script&gt; 初始化地圖HTML &lt;div id=&quot;map&quot;&gt;&lt;/div&gt; all.js Code12345function map () &#123; $(&apos;#map&apos;).vectorMap(&#123; map: &apos;world_mill&apos;, &#125;);&#125; 以上 vectorMap 中 map 的值為 jquery-jvectormap-world-mill.js 文件 jQuery 擴展方法 vectorMap 的第二個參數。當滑鼠在地圖上移動時，將會發現每個地區顯示的 tips 都是國名。如果想修改顯示，可在 jquery-jvectormap-world-mill.js 修改每個 paths的 name 屬性值或是使用 onRegionTipShow 方法。 地圖樣式、行為可以查看下列文件來修改。 https://jvectormap.com/documentation/javascript-api/jvm-map/ 下列範例是結合地圖來顯示各地區對應出的訊息： HTML Code1234567891011121314151617181920212223242526&lt;div class=&quot;wrap&quot;&gt; &lt;div id=&quot;map&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--地圖說明樣板，設成不顯示 display: none--&gt; &lt;div id=&quot;templates&quot;&gt; &lt;template id=&quot;map-legend&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;img class=&quot;national-flag h3 d-block mx-auto rounded&quot; height=&quot;36px&quot;&gt; &lt;div class=&quot;title text-center h5&quot;&gt;&lt;span class=&quot;country&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Population&lt;/td&gt; &lt;td&gt;&lt;span class=&quot;population text--green&quot;&gt;0&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;GDP&lt;/td&gt; &lt;td&gt;&lt;span class=&quot;gdp text--red&quot;&gt;0&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/template&gt; &lt;/div&gt; all.js Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 地標資料const markersData = [ &#123; &quot;latLng&quot;: [25.0338489, 121.5645294], &quot;name&quot;: &quot;台北101&quot; &#125;,]// 分類區別function map () &#123; $(&apos;#map&apos;).vectorMap(&#123; map: &apos;world_mill&apos;, backgroundColor: &apos;#364061&apos;, // 區域樣式 regionStyle: &#123; initial: &#123; fill: &quot;#fff&quot;, &quot;fill-opacity&quot;: 1, stroke: &apos;none&apos;, &quot;stroke-width&quot;: 0, &quot;stroke-opacity&quot;: 1 &#125;, hover: &#123; fill: &quot;#0080FF&quot; &#125;, selected: &#123; fill: &quot;#00BFFF&quot; &#125;, selectedHover: &#123; &#125; &#125;, // // 地標 // markers: markersData, // // 標記樣式 // markerStyle: &#123; // initial: &#123; // &#125;, // hover: &#123; // &#125;, // selected: &#123; // &#125;, // selectedHover: &#123; // &#125; // &#125;, // 類別分區資料、樣式 series: &#123; regions: [&#123; values: gdpData, scale: [&apos;#C8EEFF&apos;, &apos;#0071A4&apos;], normalizeFunction: &apos;polynomial&apos; &#125;] &#125;, // 標籤 labels: &#123; // regions: &#123; // render: function (code) &#123; // return names[code]; // &#125; // &#125; &#125;, hoverOpacity: 0.7, hoverColor: false, // 滑鼠經過區域時觸發說明 code 是鼠標當前的索引值(縮寫國名)，可用來取得資料。要用 var 來宣告，不然會有問題 onRegionTipShow: function (e, el, code) &#123; // console.log(code) // 轉換成小寫 var lowerCaseCode = code.toLowerCase(); // 取得 map-legend 的 html 內容之後複製(地圖說明的樣板) var node = $($(&apos;[id=map-legend]&apos;).html()).clone(); /* 處理 template 資料跟建立 HTML 內容 */ // attr 設定屬性值 node.find(&apos;.flag-icon&apos;).attr(&apos;src&apos;, &apos;https://cdn.jsdelivr.net/gh/hjnilsson/country-flags@latest/svg/&apos; + lowerCaseCode + &apos;.svg&apos;) node.find(&apos;.country&apos;).text(code || el.html()) node.find(&apos;.population&apos;).text(&apos;0&apos;) node.find(&apos;.gdp&apos;).text(&apos;0&apos;) // 將元素的 html 內容換成樣板內容 el.html(node.html()); &#125;, &#125;);&#125; ps. 國旗 icon svghttps://cdn.jsdelivr.net/gh/hjnilsson/country-flags@master/svg/ css Code1234567891011121314151617181920212223242526272829body &#123; margin: 0 auto; background-color: #77AF9C;&#125;#map &#123; height:calc(100vh - 60px); width: 100vw; margin-top: 50px; &#125;template &#123; display: none;&#125;.jvectormap-tip &#123; position: absolute; border: none; border-radius: 6px; background: #519D9E; color: #383A3F; font-family: sans-serif, Verdana; font-size: smaller; padding: 10px; width: 200px; pointer-events: none; font-weight: 600; z-index: 100;&#125; 類別分區的 series.regions.value 可以另外寫成 js 檔來引用 e.g. gdp-data.js Code123456const gdpData = &#123; &quot;AF&quot;: 16.63, &quot;AL&quot;: 11.58, &quot;DZ&quot;: 158.97, &quot;TW&quot;: 50,&#125;; HTML 引用&lt;script src=&quot;js/gdp-data.js&quot;&gt;&lt;/script&gt; 完成圖如下： 參考：https://jvectormap.comhttps://yi-jy.com/2015/06/24/jquery-plug-jvectormap/http://www.u396.com/jvectormaphttps://ncov2019.live/map]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>jvectormap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parallax Scrolling 視差滾動]]></title>
    <url>%2F2020%2F05%2F14%2FParallax-Scrolling%2F</url>
    <content type="text"><![CDATA[Parallax Scrolling 視差滾動原理是把背景圖片的移動速度放慢，讓前景圖片移動較快。利用多層背景以不同的速度移動，造成視覺上立體的感受。 特點有 較適合單頁面或資訊較少的網站 使用者只需簡單滾動滑鼠 提高使用者體驗 有幾種方式可以實作： JavaScript需要計算每個元素的移動位置，實作上會有些複雜。在此不多做介紹，主要針對後兩種方式。 CSS3要注意瀏覽器的支援度。 主要是利用 background-attachment 這個背景模式屬性，來造成上下滾動時所產生的視覺差。 background-attachment 有三個模式： scroll(預設)：背景會隨著外圍頁面滾動而移動fixed：背景是固定，不會隨便內外圍的頁面滾動而移動。也是視差滾動使用的模式。local：自己的區塊如果滾動時，背景也會跟著移動 e.g. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141 &lt;!--banner-1 --&gt; &lt;section&gt; &lt;div class=&quot;background_image1&quot;&gt; &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;div class=&quot;content-1&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;HELLO WORLD&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Nobis blanditiis labore voluptate molestiae vel eius quaerat, iusto illo minus possimus aspernatur natus ut dolore quis quisquam earum ratione sequi perspiciatis sunt nam in magnam? Aliquam, ducimus doloremque vel eius necessitatibus id hic eveniet, dolorum placeat voluptatibus earum. Laborum et fugiat repellat voluptatibus eveniet tempore ipsum quidem dolor. Autem aut officiis dolorem quae natus commodi ut debitis asperiores. Accusamus vel ea, illum adipisci velit veniam accusantium obcaecati vitae ullam nulla eius corrupti voluptatem fugiat voluptatibus aliquid saepe fuga? Ad illum odit molestiae, reprehenderit sequi iure fuga blanditiis voluptatum quaerat, ducimus eius.&lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;!--banner-2 --&gt; &lt;section&gt; &lt;div class=&quot;background_image2&quot;&gt; &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;div class=&quot;content-2&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;HELLO WORLD&lt;/h2&gt; &lt;p&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Quae vero a sequi saepe, fuga non! &lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;!--banner-3 --&gt; &lt;section&gt; &lt;div class=&quot;background_image3&quot;&gt; &lt;span class=&quot;mark3&quot;&gt;peaceful&lt;/span&gt; &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;div class=&quot;content-3&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;HELLO WORLD&lt;/h2&gt; &lt;p&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Soluta eaque dolorem officia magni. &lt;/p&gt; &lt;/div&gt;&lt;/section&gt;body &#123; margin: 0 auto; height: 2000px;&#125;.background_image1 &#123; width: 100%; height: 100vh; background-image: url(&apos;../images/diogo-sousa-ZVKodjhgJa0-unsplash.jpg&apos;); background-position: center; background-size: cover; background-attachment: fixed;&#125;.content-1 &#123; padding: 60px; font-size: 18px; font-family: Verdana, Geneva, Tahoma, sans-serif; text-align: justify; .title &#123; text-align: center; color: aqua; &#125; p &#123; line-height: 2; color: rgb(2, 2, 95); &#125;&#125;.background_image2 &#123; width: 100%; height: 60vh; background-image: url(&apos;../images/sea.jpeg&apos;); background-position: center; background-size: cover; background-attachment: fixed; opacity: 0.7;&#125;.content-2 &#123; padding: 60px; font-size: 15px; font-family: Verdana, Geneva, Tahoma, sans-serif; text-align: justify; color: aquamarine; background-color: black; p &#123; line-height: 2; color: rgb(230, 230, 243); &#125;&#125;.background_image3 &#123; width: 100%; height: 100vh; background-image: url(&apos;../images/francesco-ungaro-nlqqldluDBw-unsplash.jpg&apos;); background-position: center; background-size: cover; background-attachment: fixed; opacity: 0.7;&#125;.mark3 &#123; font-size: 36px; font-weight: bold; font-family: &apos;標楷體&apos;; color: pink; padding: 10px; letter-spacing: 10px; position: relative; left: calc(50% - 77px); top: calc(50% - 28px); opacity: 0.7;&#125;.content-3 &#123; padding: 20px; font-size: 15px; font-family: Verdana, Geneva, Tahoma, sans-serif; text-align: justify; color: aquamarine; background-color: black; .title &#123; text-align: center; color: aqua; &#125; p &#123; text-align: center; &#125;&#125; 第三方套件網路上有一些做 Parallax Scrolling 套件，例如 parallax.js、skrollr.js、paroller.js…等等。在此介紹的是 skrollr.js。 skrollr.js 是運用動畫影格控制概念，搭配使用 CSS 語法。 擁有下列特點： 容易上手 檔案小 支援行動裝置的瀏覽器 除此之外也有一些好用的套件可用。例如：skrollr-menu、skrollr-stylesheets、skrollr-colors…等等。 使用方式// 引用 Code12&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/skrollr/0.6.30/skrollr.min.js&quot;&gt;&lt;/script&gt; // 初始化 Code1234&lt;script type=&quot;text/javascript&quot;&gt; const skrollrObj = skrollr.init();&lt;/script&gt;&lt;/body&gt; // 運用 Code1234&lt;div data-0=&quot;background-color:rgb(0,0,255);transform[bounce]:rotate(0deg);&quot; data-500=&quot;background-color:rgb(255,0,0);transform[bounce]:rotate(360deg);&quot;&gt; test&lt;/div&gt; data-0： 0 代表 SkrollrTop 的值 background-color:rgb(0,0,255)： CSS 樣式 transform[bounce]:rotate(0deg)： 將 transform 從秒數，變成 SkrollTop的 px(距離) e.g. // 元素轉場，滾動位置從 0 到 300 時，元素背景顏色會逐漸變色跟旋轉360度 Code123&lt;div data-0=&quot;background-color:rgb(0,0,255);transform[bounce]:rotate(0deg);&quot; data-300=&quot;background-color:rgb(255,0,0);transform[bounce]:rotate(360deg);&quot;&gt; test&lt;/div&gt; // 圖片淡出 Code123&lt;div data-0=&quot;opacity: 1;&quot; data-300=&quot;opacity: 0;&quot;&gt; &lt;img src=&quot;https://picsum.photos/id/237/200/300&quot;&gt;&lt;/div&gt; // 圖片模糊 Code123&lt;div data-0=&quot;-webkit-filter: blur(0px);;&quot; data-300=&quot;-webkit-filter: blur(5px);;&quot;&gt; &lt;img src=&quot;https://picsum.photos/id/237/200/300&quot;&gt;&lt;/div&gt; ps.使用時，每個階段的樣式要一致，data-0 到 data-300 都要加上相同樣式，例如淡出樣式 &quot;opacity: 1;&quot;。不能只加在其中之一。 在這只是簡單介紹一下用法，但 skrollr.js 還有提供 Keyframe 用法。如果想更深入了解，可再深入查詢。 https://ithelp.ithome.com.tw/articles/10161180http://lala0812.logdown.com/posts/240837-skrollr-easily-implement-css3-html5-parallax-scrollinghttps://ithelp.ithome.com.tw/articles/10161180https://coderwall.com/p/we0ymg/skrollr-parallax-scrollinghttps://medium.com/code4idea/flutter-day-8-水平視差滾動效果-parallax-pageview-8e29e860e196https://github.com/Prinzhorn/skrollrhttps://andy6804tw.github.io/2018/02/02/css-background-attachment/https://wcc723.github.io/css/2013/09/25/background-att/]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>Parallax Scrolling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延遲載入圖片 lazy loading]]></title>
    <url>%2F2020%2F05%2F14%2Flazy-loading%2F</url>
    <content type="text"><![CDATA[Lazy loadingLazy loading(延遲載入)是很實用的開發技巧。在圖片很多的網站使用之後，可以提升頁面載入速度，還能節省網路的流量。 大致上的作法是： 一開始圖片不完全載入(src內先不放圖片路徑) 觀察圖片是否進入視窗範圍 視窗改變後，載入圖片(src內放入圖片路徑) 目前已有幾種方式可以實作。 瀏覽器設定目前 chrome 瀏覽器已經有加入其功能，但需要自行設定。步驟如下 在網址輸入 chrome://flags，搜尋 lazy 在 Enable lazy image loading 的項目上啟用(enable) 在 HTML 的 加上 loading=”lazy” ps. loading 有三種模式可選 lazy：延遲載入圖片eager：立即載入圖片auto：瀏覽器自行決定(Chrome 預設值是 eager) 第三方套件另外還可以使用其他第三方套件 Lozad.js、lazySize…等等，可上網搜尋 lazyload plugin。 事件監聽分別要監聽 scroll(瀏覽器滾動)、resize(瀏覽器畫面大小調整) 和 orientationchange(裝置方向改變) 事件，同時透過 Element.getBoundingClientRect() 取得目標元素位置。另外為了避免監聽事件被過度觸發，有時會加上 debounce(防抖動) 或 throttle(油門) 兩種方法來處理。最後等圖片完全載入後刪除監聽。使用此種做法似乎會顯得有些麻煩及複雜。 ps.1.debounce(防抖動) 跟 throttle(油門) 已有 library 可以用：LodashUnderscore 2.實作部分於請參考最後的參考資料網站內 Intersection Observer API這個 API 的功用是當每一個被監控的元素進入(離開)某個元素或 viewport 時，又或者兩者相交達到的一定的次數時觸發執行 callback function。此用法效能比事件監聽好，程式也更加精簡，瀏覽器支援的情況也好。另外也可以應用在 Infinite Scroll、當元素出現在可視範圍內才顯示動畫、計算廣告曝光次數…等需求。 用法範例 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546const root = document.querySelector(&apos;#root&apos;);const options = &#123; // 如果沒有指定 root，預設就是指 window root: null, // 當 target 的可見度(%)超過到多少時會執行 callback，可單一數字或陣列 threshold: [0, 0.2, 0.4, 0.6, 0.8, 1], // rootMargin: &apos;0px&apos;,&#125;;// 被監控的元素進入(離開)某個元素或 viewport 時，執行 callbackconst callback = (entries, observer) =&gt; &#123; entries.forEach(entry =&gt; &#123; // 進入 entry 的 element entry.target // 觀察者（viewport) 和被觀察者（target）是否有交互 true or false entry.isIntersecting // 被觀察者（target）和觀察者（viewport）的重疊比例，回傳 0~1 entry.intersectionRatio // entry.boundingClientRect // 目標的左上角在 viewport 的距離 // entry.intersectionRect // entry.rootBounds // entry.time // 取消觀察 // observer.unobserve(target); &#125;);&#125;;// 建立觀察者(root)const observer = new IntersectionObserver(callback, options);// 指定觀察目標const target = document.querySelector(&apos;#target&apos;);// 開始觀察observer.observe(target);// 關閉觀察器 // observer.disconnect();// 觀察多目標let lazyImg = document.querySelectorAll(&apos;img&apos;);// call() 傳入參數(arguments) img1, img2, ...，非陣列型式Array.prototype.forEach.call(lazyImg, function(img) &#123; observer.observe(img);&#125;); 補充： 1.img 標籤設定： // img 正常載入，callback 後&lt;img class=&quot;lazy_img&quot; src=&quot;dog.jpg&quot;&gt; // img 無法載入，初始設定&lt;img class=&quot;lazy_img&quot; data-src=&quot;dog.jpg&quot;&gt; 替換圖片路徑用法 // 取 data-src 的值給 srcentry.target.setAttribute(&#39;src&#39;, img.dataset.src)entry.target.removeAttribute(&#39;data-src&#39;) 2.可以先將圖片範圍設定好，用灰底取代。避免跑版。 參考：https://iandays.com/2019/04/25/reactlazyload/https://medium.com/@mingjunlu/lazy-loading-images-via-the-intersection-observer-api-72da50a884b7https://mropengate.blogspot.com/2017/12/dom-debounce-throttle.htmlhttps://blog.camel2243.com/2017/06/05/javascript-throttle-與-debounce，處理頻繁的-callback-執行頻率/https://mropengate.blogspot.com/2017/12/dom-debounce-throttle.htmlhttps://shubo.io/get-bounding-client-rect/https://letswrite.tw/intersection-oserver-basic/https://letswrite.tw/intersection-oserver-demo/https://pjchender.github.io/2018/06/27/webapis-intersection-observer-api/]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>lazy loading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 操作 DOM 及事件傳遞]]></title>
    <url>%2F2020%2F05%2F13%2FJavaScript-DOM%2F</url>
    <content type="text"><![CDATA[Window 及 Documentwindow 是指瀏覽器視窗(最上層的全域物件)，包含了 DOM。支援分頁的瀏覽器中，每一個分頁標籤都擁有自己的 window 物件。其本身有許多屬性跟方法。例如： // 跳出提示視窗 window.alert(&#39;Hello world&#39;) // 延遲某段時間(單位為毫秒)後，再執行一次 callback window.setTimeout(callback, 5000) // 固定延遲了某段時間，不斷循環執行 callback windwo.setInterval(callback, 5000) // 開啟一個新視窗 window.open() // 頁面載入時觸發 window.onload() // 歷史列表 window.history // 視窗中載入的 Document 物件 window.document // 記錄瀏覽器 (broswer) 相關資訊 window.navigator window.navigator 屬性如下: 屬性 值 appCodeName 設定的 code 名稱 appName 使用瀏覽器的官方名稱 appVersion 使用瀏覽器的版本 buildID 使用瀏覽器的 ID，ID 的格式為 “YYYYMMDDHH” cookieEnabled 瀏覽器是否可以寫入 cookie language 瀏覽器的語系編碼 onLine 瀏覽器是否有連線 oscpu 作業系統及 CPU 名稱 platform 平台（作業系統）名稱 plugins 所有瀏覽器安裝的附加元件 … … ps.使用時前面 window 可省略不寫 document 是指當前的 HTML 頁面。而 DOM (Document Object Model) 文件物件模型，是瀏覽器將 HTML 的標籤元素轉換成 JavaScript 可操作的物件。DOM 中的每個 HTML 元素就是一個節點。而 document 是根節點。 取得 DOM 元素取得單一元素document.getElementById(&#39;id&#39;) const el = document.querySelector(&#39;#id&#39;) or const el = document.querySelector(&#39;.class&#39;) 取得多個元素// 取得一整個 input 陣列的值，取值要加陣列索引 const inputElement = document.getElementsByTagName(&#39;div&#39;); // 取得所有符合的元素節點列表(非陣列) const allEl = document.querySelectorAll(&#39;.class&#39;) // 轉成陣列後，就可用陣列方法 Array.from(allEl).foreach(element =&gt; { ... }) // 動態插入一個新的 divconst el = document.createElement(&#39;div&#39;) document.body.appendChild(el) ps. querySelector() 不能查詢動態更新的元素，要用 getElement 的方法 屬性(properties、attributes)處理// 檢查是否有該屬性 document.querySelector(&#39;a&#39;).hasAttribute(&#39;href&#39;); // 取得屬性值 document.querySelector(&#39;a&#39;).getAttribute(&#39;href&#39;); // 設定屬性 document.querySelector(&#39;a&#39;).setAttribute(&#39;href&#39;, &#39;Link&#39;); ps.這些方式會讓瀏覽器進行重繪(redraw)，拖慢效能。除非必要再使用。改用以下方式來處理 // 取得屬性 const value = el.value // 設定屬性，直接指定 el.value = &#39;hi&#39; // 設定多個，用 Object.assign() Object.assign(el.{ value: &#39;hello&#39;, id: &#39;world&#39; }) // 刪除屬性 el.value = null ps.目前大多都直接將屬性集合寫在 class 類別再使用。 類別(class)處理// 增加類別，可多個 el.classList.add(&#39;abc&#39;,&#39;abc1&#39;) // 移除類別，可多個 el.classList.remove(&#39;abc&#39;) // 切換類別，元素上沒有這類別時，就新增類別；如果元素已經有了這類別，就刪除。 el.classList.toggle(&#39;abc&#39;) // 檢查是否有此類別 el.classList.contains(&#39;abc&#39;) // 查詢類別數量 el.classList.length // 取得所有類別 const all = el.classList // 修改類別(有 - 用[ ]語法) el.style.background = &#39;gray&#39;;el.style[&#39;background-color&#39;] = &#39;#000&#39;; // 直接讀寫類別 el.style.cssText = &#39;font-size: 16x; color: gray;&#39;; // 取得屬性值 window.getComputedStyle(el).getPropertyValue(&#39;font-size&#39;) DOM 處理// 建立元素節點 const divEl = document.createElement(&#39;div(tagName)&#39;) // 建立文字節點 const TextNode = document.createTextNode(&#39;hello world&#39;) // 在 el 元素的最後新增 el2 元素 el.appendChild(el2) // NODE.insertBefore(newNode, refNode)，將新節點 newNode 插入至指定的 refNode 節點的前面 el.insertBefore(el2, el3) // 在 el 元素裡的 el3 元素之後新增 el2 元素 el.insertBefore(el2, el3.nextSibling) // 替換，將 el 內的 oldNode 替換成 newNode el.replaceChild(newNode, oldNode); // 複製 const cloneEl = el.cloneNode() // 移除(需要從父元素移除) parentEl.removeChild(el) // 移除本身元素 el.parentNode.removeChild(el) // 修改元素的內容(包含子元素內容) el.innerHTML = &#39;&lt;div&gt;&lt;h1&gt;hello world&lt;/h1&gt;&lt;/div&gt;&#39; // 可增進效能的 document.createDocumentFragment()，DocumentFragment 不是真實的 DOM 結構，不會影響目前文件，所以不會導致回流(reflow) Code1234567891011121314const ul = document.getElementById(&quot;List&quot;);// 建立 DocumentFragmentconst fragment = document.createDocumentFragment();for (let i = 0; i &lt; 2; i++)&#123; // 產生 li，加入文字後加入 fragment let li = document.createElement(&quot;li&quot;); li.appendChild(document.createTextNode(&quot;No.&quot; + (i+1))); fragment.appendChild(li);&#125;// 最後將 fragment 加在 ul 後ul.appendChild(fragment); 事件事件資訊 function(e)event 資訊會放在 callback function 裡面的第一個參數，通常都是取名 event 或簡寫 e，可當成是物件，內有各種此事件的參數值。此 callback 執行的時機是事件觸發後。e.eventPhase 是表示事件在那個階段(Phase)被觸發，用數字來表示(1:CAPTURING 2:TARGET 3:BUBBLING) e.g. click 滑鼠點擊事件 e.target // 被點擊到的元素 e.screenX // 滑鼠離視窗左邊的距離 e.screenY // 滑鼠離視窗上邊的距離 keydown 鍵盤按下按鍵 e.key // 按鍵號碼 事件監聽監控標籤元素發生某件事(例如被點擊…)之後要進行的動作，若要改變這個事件要在什麼階段觸發，可以在 el.addEventListener() 加上第三個參數(可不加，不加為預設)，為 boolean 值(true:捕獲、false(預設):冒泡)。 // 單一元素監聽 &lt;button id=&quot;btn&quot; onclick=&quot;console.log(&#39;Hello&#39;);&quot;&gt;Click&lt;/button&gt; ps.不建議用上述方式綁定(框架例外) Code123el.addEventListener(&apos;click&apos;, function (event) &#123; ...&#125;,false) //監聽多個元素，event.target 取得觸發目標元素 Code12345Array.from(allEl).forEach(element =&gt; &#123; element.addEventListener(&apos;change&apos;, function (event) &#123; console.log(event.target.value) &#125;)&#125;) // 解除事件監聽(註冊) Code123el.removeEventListener(&apos;click&apos;, function()&#123; console.log(&apos;HI&apos;);&#125;, false); ps. 目前在 Vue &amp; React 等網頁框架中，如果是使用內建的語法註冊事件監聽，它們都會自動在無用的時候移除，可以放心使用。但若是自己寫事件監聽，務必要記得移除。 傳遞機制(捕獲 CAPTURING 與冒泡 BUBBLING)假設有一個列表，組成為 ul 跟 多個 li，當點了其中的一個 li。也相當於點擊了 ul。因為 li 被 ul 包住了。這樣一來 ul 及 li 的所監聽事件都將觸發。 事件傳遞順序是：先捕獲：從根節點往下傳遞到 target，過程中觸發各別元素的捕獲階段事件監聽。再冒泡：從 target 事件觸發後再逐層向上回到根節點過程中事件依序被觸發。 當事件傳到 target 本身時，沒有分捕獲跟冒泡。執行順序按照 addEventListener的順序而定，先添加的先執行，後添加的後執行。 取消事件傳遞 e.stopPropagation()不會再把事件傳遞給上或下一個節點，看是捕獲跟冒泡機制。但若是同一個節點上，不只一個 listener 的話，還是會執行。 取消相同事件 e.stopImmediatePropagation()當元素有綁定多個同樣的事件時，監聽將會按照註冊的先後順序被呼叫，若其中一個監聽事件呼叫了 e.stopImmediatePropagation()，將會阻止所有後面的綁定事件。 阻止預設動作 e.preventDefault()取消瀏覽器的元素預設行為，跟事件傳遞無關。以下是比較常用的情況： &lt;form&gt; 的 submit // 阻止送出表單&lt;a&gt; 的 click 事件 // 阻止轉址&lt;input&gt; 的 keypress 事件 // 阻止輸入按鍵 事件代理(Event delegation)為了處理大量的事件監聽跟動態新增元素(appendChild)的事件監聽，可以透過事件傳遞的機制，將子元素事件監聽器交由父元素代理。 例如列表(ul、li)的監聽，可將監聽機制設定在 ul 上，而不是內部的每一個 li。如此一來不管 li 數量有多少，都可以利用事件傳遞機制(冒泡)來做事件監聽。 補充：window.onload 與 $(document).ready 的使用差異。可以參考 https://ithelp.ithome.com.tw/articles/10092601 此文章內容。基本上建議使用 $(document).ready。 參考：https://ithelp.ithome.com.tw/articles/10191867https://www.fooish.com/javascript/dom/css.htmlhttps://jmln.tw/blog/2017-07-07-vanilla-javascript-dom-manipulation.htmlhttp://fstoke.me/blog/?p=2487https://yakimhsu.com/project/project_w7_DOM.htmlhttps://yakimhsu.com/projectproject_w7_eventListener.htmlhttps://blog.techbridge.cc/2017/07/15/javascript-event-propagation/https://medium.com/schaoss-blog/前端三十-07-js-瀏覽器-dom-元素的事件代理是指什麼-95f1e8f311dbhttps://medium.com/schaoss-blog/什麼捕獲冒泡-你是魚嗎-聊聊瀏覽器-dom-的事件傳遞-b44454690661https://pydoing.blogspot.com/2011/10/javascript-window-navigator.htmlhttps://ithelp.ithome.com.tw/articles/10191970]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 實作分頁]]></title>
    <url>%2F2020%2F05%2F07%2Fnodejs-pagination%2F</url>
    <content type="text"><![CDATA[Node.js 實作分頁一樣延續 使用 Node.js 與 RESTful API 架構來串接 mongoDB 並部署到 Heroku，跟 Node.js 實作登入及驗證 來延伸實作分頁功能。 製作分頁功能，首先要考慮四個要素： 總頁數 = 總資料量/每頁每頁資料量 目前頁數 = 預設第一頁(之後依照 query 參數傳入) 每頁資料量 = 自行設定 當前頁面資料 = 按照目前頁數及每頁資料量找出範圍區間後顯示 後端有了四個要素，就可以做出功能了。 連接資料庫後，取得資料 根據上面的四要素，算出參數 篩選出要顯示的資料 回傳資料及參數給 client 端 邏輯控制在邏輯控制加入分頁方法 ./controllers/restaurants.js Code12345678910111213141516171819202122232425262728293031323334353637383940414243getRestaurantsPage: (req, res) =&gt; &#123; // 接收前端所查詢的頁面資料 ?page=1 // 由於接收到的資料是字串，用 parseInt() 轉換成數字 let currentPage = parseInt(req.query.page) || 1 db.collection(&apos;restaurants&apos;).find().toArray((err, result) =&gt; &#123; if (err) return console.log(err) const totalResult = result.length // 每頁資料量 const perpage = 3 // 總頁數 const pageTotal = Math.ceil(totalResult / perpage) // 預設當前頁數， // let currentPage = 1 // 當前頁不能超過總頁數 if (currentPage &gt; pageTotal) &#123; currentPage = pageTotal &#125; // 第幾筆資料索引範圍 const minItem = (currentPage * perpage) - perpage + 1 const maxItem = (currentPage * perpage) // console.log(totalResult, pageTotal, currentPage, minItem, maxItem) const temp = [] result.forEach((item, i) =&gt; &#123; let itemNum = i + 1 if (itemNum &gt;= minItem &amp;&amp; itemNum &lt;= maxItem) &#123; // console.log(item.name, i) temp.push(item) &#125; &#125;) // console.log(temp) res.status(200).send(&#123; data: temp, pagination: &#123; total_pages: pageTotal, current_page: currentPage, has_pre: currentPage &gt; 1, has_next: currentPage &lt; pageTotal, category: null &#125; &#125;) &#125;) &#125;, 路由設定./routes/restaurants.js router.get(&#39;/page&#39;, getRestaurantsPage) API： http://localhost:3000/restaurants/page?page=1 前端Vue 前端製作部分： html(使用樣板) Code12345678910111213141516171819202122232425262728293031323334&lt;nav aria-label=&quot;Page navigation example&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li class=&quot;page-item&quot; :class=&quot;&#123;&apos;disable&apos;: !pagination.has_pre&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot; aria-label=&quot;Previous&quot; @click.prevent=&quot;getLocation(pagination.current_page - 1)&quot; &gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot; v-for=&quot;page in pagination.total_pages&quot; :key=&quot;page&quot; :class=&quot;&#123;&apos;active&apos;: pagination.current_page === page&#125;&quot; &gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot; @click.prevent=&quot;getLocation(page)&quot;&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot; aria-label=&quot;Next&quot; @click.prevent=&quot;getLocation(pagination.current_page + 1)&quot; &gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; 加上 pagination 資料欄位 Code12345678910111213141516export default &#123; data: () =&gt; (&#123; ... pagination: &#123;&#125;, ... &#125;), methods: &#123; getLocation(page = 1) &#123; // 用 axios 非同步取得資料 const api = `$&#123;process.env.VUE_APP_APIPATH&#125;/restaurants/page?page=$&#123;page&#125;` this.$http.get(api).then(Response =&gt; &#123; this.data = Response.data.data this.pagination = Response.data.pagination &#125;) &#125;, &#125;, 參考：六角學院 Node.js 課程https://wiki.jikexueyuan.com/project/express-mongodb-setup-blog/]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[關於 Cookie 與 Session]]></title>
    <url>%2F2020%2F05%2F06%2Fcookie-session%2F</url>
    <content type="text"><![CDATA[Cookie伺服器傳送給使用者瀏覽器的資料，通常被用來驗證使用者的登入狀態，每次 request 時都會帶上。主要用於購物車，下次購買訂單記錄。 能儲存資料在瀏覽器上的小型資料庫(4k) 傳送時以明碼傳送，機密資料不建議以此方式儲存 能在 client(瀏覽器)、server(後端程式)進行讀取、寫入 key / value 組成，並由分號跟空格來隔開 每次 request 時都會帶上 可設定失效時間，在時間過後消失。預設是關閉瀏覽器後失效 session data 並不會儲存在 cookie 裡，cookie 存的是 sessionID chrome 開發人員工具的 Application 可看到 欄位介紹Name: 鍵(key)Value: 值(value)Domain: 取得該 Cookie 的網域expires: 限制 Cookie 的有效時間max-age: 存在時間path: 設定可以存取該 Cookie 的路徑secure: 設定 Cookie 是否要 https 網址才可傳送 瀏覽器端寫法讀取瀏覽器下的 console 輸入 document.cookie 寫入 Cookiedocument.cookie = “myName=tom”; 寫入 Cookie，並加入過期時間document.cookie=”username=bob; expires=Mon, 04 Dec 2017 08:18:32 GMT; path=/“; GMT 時間 new Date().toGMTString() 寫入 Cookie，設定 10 秒後失效document.cookie=”username=bob; max-age=10; path=/“; 伺服器端(Node.js)安裝解析 Cookie NPM (cookie-parser)npm install cookie-parser --save Express 寫入 Cookie，並加入相關設定 (過期時間、httponly、path)res.cookie(name, value [, options]); Express 讀取 Client 端 Cookiereq.cookies.yourCookieName; Session會在用戶完成身分認證後，存下、用戶資料，然後產生一組對應的 id，存入 cookie 後傳回用戶端。例如餐廳點餐後，拿到號碼牌，餐廳可以透過號碼牌來識別點餐者資訊。通常應用於網站計數器，登入驗證…等等。 儲存在伺服器的暫存資料，可放在記憶體或資料庫上 session 可在 cookie 上儲存識別身份的 sessionID 不會自動失效，除非超過設置的失效時間 express-session option 介紹name：在 response 中，設定的 sessionID cookie name。預設是 connect.sidproxy：代理伺服resave：強制將 session 存回 session store 。預設是 truerolling：強制在每一次回應時，重新設置一個 sessionID cookie。到期, 將重置為原始 maxAge, 重新計數時效性saveUninitialized：強制將未初始化的 session 存回 session store，若它是新的且未被修改store：在 server 端的存放方式，預設 memorycookie：設定 sessionID 的 cookie 相關選項。其選項跟 cookie 欄位介紹一樣。預設 { path: ‘/’, httpOnly: true, secure: false, maxAge: null }secret(必要選項)：用來簽章 sessionID 的 cookie, 可以是一個字串或是多個字串組成的一個陣列。 伺服器端(Node.js)安裝設定npm install express-session --save Code12345678//express-session 設定app.use(session(&#123; secret: &apos;keyboard cat&apos;, resave: true, saveUninitialized: true, cookie:&#123;&#125;// 設定 Cookie 設定&#125;)) 寫入 sessionreq.session.username = &#39;tom&#39;; LocalStorage 與 SessionStorageHTML5 提供兩個 client 端儲存資料的方法。大小預設有 5mb，只在瀏覽器保存，沒有參與 server 溝通。 LocalStorage適合保存數據、購物車資料。 key / value 組成，value 只有字串型態 不會過期，除非手動清除 跨分頁 建立資料設定 userName 屬性，值為 bob localStorage.setItem(&#39;userName&#39;, &#39;bob&#39;); 取得資料localStorage.getItem(&#39;userName&#39;); 刪除資料localStorage.removeItem(&#39;userName&#39;); 全部刪除localStorage.clear(); SessionStorage只存在瀏覽囂的單一分頁，另開新分頁的話，又是一個新的 sessionStorage。 key / value 組成 預設無逾期時間，分頁或瀏覽器關掉後就會清除 建立資料設定 userName 屬性，值為 bob sessionStorage.setItem(&#39;userName&#39;, &#39;bob&#39;) 取得資料sessionStorage.getItem(&#39;userName&#39;); 刪除資料sessionStorage.removeItem(&#39;userName&#39;); ps.上述的瀏覽器儲存區的資料都是以不同網站為單位儲存，網站間無法共享儲存在 Client 端的資料。 JSON 轉換由於 value 只能存入 String，若要儲存其他類型(object, array…)時，可使用 JSON 來轉換，先將其他類型的資料轉為字串後儲存，要使用時再取出轉回原本格式。 轉換成字串 JSON.stringify let arrToStr = JSON.stringify(arr); 轉換回原本格式 JSON.parse let strToArr = JSON.parse(arrToStr); 參考：https://ithelp.ithome.com.tw/articles/10187464https://medium.com/@bebebobohaha/cookie-localstorage-sessionstorage-%E5%B7%AE%E7%95%B0-9e1d5df3dd7fhttps://dotblogs.com.tw/daniel/2017/04/08/110915https://ithelp.ithome.com.tw/articles/10203525https://yakimhsu.com/project/project_w7_storage.html]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 實作登入及驗證]]></title>
    <url>%2F2020%2F05%2F06%2Fnodejs-login-auth%2F</url>
    <content type="text"><![CDATA[Node.js 實作登入及驗證接續 使用 Node.js 與 RESTful API 架構來串接 mongoDB 並部署到 Heroku 的內容來修改並加入登入及驗證的功能。 這裡會專注在登入驗證的部分，使用 Passport.js 來處理。程式會分成：驗證(verification)、路由(routes)、邏輯控制(controllers)來處理，方便管理及修改。 Passport.jsPassport 可以想成是一個處理驗證的 middleware，提供超過上百組驗證策略(Strategy)。可以依照自己的需求，使用帳號和密碼或第三方認證系統，如 Facebook、Google…等等。在這我們使用本地驗證 LocalStrategy(帳號和密碼)。 使用上大致分成幾個部分： 安裝載入模組npm install passport passport-local --save app.js Code1234567891011121314151617// 引用 expressconst express = require(&apos;express&apos;)const app = express()// 身份認證const passport = require(&apos;passport&apos;)const session = require(&apos;express-session&apos;)app.use(session(&#123; secret: &apos;secretok&apos;, // 強制將未初始化的session存回 session store saveUninitialized: false, // 強制將session存回 session store, resave: false,&#125;))// passport.user 初始化app.use(passport.initialize())// 處理 Session，呼叫 deserializeUser()。若有找到 req.user，則判定其通過驗證。app.use(passport.session()) ps. session() 需設定在 passport.session() 之前，以確保 session 能正確地被處理 建立驗證策略及序列化與反序列化的函式在 web 應用中，驗證訊息(credentials)，只在登入時被傳送，驗證成功後，會記錄在 session 並儲存 cookies 在瀏覽器內。之後的 request 都不會再帶驗證訊息，而是透過 cookie 來辨認 session，為了支援 login sessions，在 Passport 中會序列化（serialize）和反序列化（deserialize）在 session 中的使用者實例。 ps.序列化(serialize)簡單說就是把 物件轉換成可被儲存在儲存空間的資料的這個過程，例如把 JavaScript 中的物件透過 JSON.stringify() 變成字串儲存。而反序列化則是倒過來把資料轉換成程式碼中的物件，例如把 JSON 字串透過 JSON.parse() 轉換成物件。 建立驗證策略機制 引用 passport 及 策略 passport.use() 建立策略 Code123456const passport = require(&apos;passport&apos;)const LocalStrategy = require(&apos;passport-local&apos;).Strategypassport.use(new LocalStrategy( // 驗證 code ..... )) 設定完 Strategy 後，要加上 Verify Callback Verify Callback 帶入 username, password 參數，進行驗證 完成驗證後，呼叫 done，帶入驗證後結果 Code123456passport.use(new LocalStrategy( // Verify Callback 驗證時，呼叫此函式 function(username, password, done) &#123; // 驗證 code... &#125; )) 使用 LocalStrategy 時，預設從 req.body 中的 username 和 password 的欄位取得資料。若要使用其他欄位，並使用 req 物件時，例如：使用 req.flash() 設定時，可加上 options(非必要)。 Code1234567891011121314passport.use(new LocalStrategy( &#123; // 改用 email 的欄位作為帳號 usernameField: &apos;email&apos;, // 改用 userpassword 的欄位作為密碼 passwordField: &apos;userpassword&apos; // 讓 varify callback 函式可以取得 req 物件 passReqToCallback: true &#125;, // 新增 req 引數 function(req, email, userpassword, done) &#123; // 驗證 code... &#125;)) done 是 callback function，驗證完成後，呼叫 done 並將驗證結果作為參數傳入，提供給 Passport 使用。 done 接收三種參數：1.錯誤訊息：伺服器端回傳錯誤訊息時，帶入錯誤訊息 err；無錯誤訊息時，則可以帶入 null 取代2.使用者資料：驗證成功時，帶入使用者資料 user；驗證失敗時，則可以帶入 false 取代3.驗證失敗訊息：當驗證失敗時，可以額外補充驗證失敗的原因和資訊 Code1234567891011// 驗證成功時，提供 Passport 該名使用者資料return done(null, user)// 驗證失敗時，不提供 Passport 任何使用者資料return done(null, false)// 驗證失敗時，不提供 Passport 任何使用者資料，但告知失敗原因return done(null, false, &#123; message: &apos;Incorrect password.&apos; &#125;)// 當伺服器端產生錯誤訊息時，提供 Passport 錯誤訊息內容return done(err) e.g. 完整驗證策略 Code123456789101112131415161718192021222324252627282930313233const passport = require(&apos;passport&apos;)const LocalStrategy = require(&apos;passport-local&apos;).Strategy// 透過 passport.use() 建立驗證機制passport.use(new LocalStrategy(&#123; // 改以名為 email 的欄位資訊作為帳號 // usernameField: &apos;email&apos;, // 改以名為 passwd 的欄位資訊作為密碼 // passwordField: &apos;passwd&apos;, // 讓 varify callback 函式可以取得 req 物件 passReqToCallback: true &#125;, // 當請 passport 要驗證時，呼叫此 callback 函式，並帶入驗證資訊驗證 // Varify Callback: 新增 req 引數 function (req, username, password, done) &#123; // console.log(username, password) // 從 MongoDB 查詢使用者 db.collection(&apos;users&apos;).findOne(&#123; username: username &#125;, function (err, user) &#123; // console.log(user) // 如果伺服器端回傳錯誤訊息，提供 passport 錯誤訊息 if (err) &#123; return done(err) &#125; // 如果沒有在資料庫裡找到該位使用者，不提供 passport 任何使用者資訊，告知失敗原因，並將錯誤資訊放內 flash() 內 if (!user) &#123; return done(null, false, req.flash(&apos;info&apos;, &apos;User not found.&apos;)) &#125; // 驗證密碼 bcrypt.compare(password, user.password, (err, isMatch) =&gt; &#123; // password correct if (isMatch) &#123; return done(null, user) &#125; // 如果從資料庫找到了該名使用者，但密碼錯誤時，不提供 passport 任何使用者資訊，告知失敗原因 return done(null, false, req.flash(&apos;info&apos;, &apos;Invalid password&apos;)) &#125;) &#125;) &#125; )) 序列化與反序列化passport.serializeUser() 從 strategy 得到參數值 user，可設定將哪些 user 資訊，儲存在 Session 中的 req.session.passport.user Code1234passport.serializeUser(function(user, done) &#123; // 只將用戶 id 序列化存到 session 中 done(null, user.id)&#125;) passport.deserializeUser() 從 session 中取得 user (req.session.passport.user) 值，透過該資訊至資料庫找到完整的用戶資料，儲存在 req.user Code123456passport.deserializeUser(function(id, done) &#123; // 為了讓 session 小一點，透過使用者 id 到資料庫尋找用戶完整資訊 User.findById(id, function(err, user) &#123; done(err, user) &#125;)&#125;) 將驗證策略及序列化與反序列化的函式整合後，再引入 app.js 使用 ./verification/passport.js Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 用帳密來做驗證const LocalStrategy = require(&apos;passport-local&apos;).Strategyconst FacebookStrategy = require(&apos;passport-facebook&apos;).Strategyconst GoogleStrategy = require(&apos;passport-google-oauth20&apos;).Strategyconst mongoose = require(&apos;mongoose&apos;)const db = require(&apos;../connections/mongoDB_connect&apos;)// 加解密const bcrypt = require(&apos;bcryptjs&apos;)//const ObjectID = require(&apos;mongodb&apos;).ObjectIDmodule.exports = passport =&gt; &#123; // local strategy // 透過 passport.use() 建立驗證機制 passport.use(new LocalStrategy(&#123; // 改以名為 email 的欄位資訊作為帳號 // usernameField: &apos;email&apos;, // 改以名為 passwd 的欄位資訊作為密碼 // passwordField: &apos;passwd&apos;, // 讓 varify callback 函式可以取得 req 物件 passReqToCallback: true &#125;, // 當請 passport 要驗證時，呼叫此 callback 函式，並帶入驗證資訊驗證 // Varify Callback: 新增 req 引數 function (req, username, password, done) &#123; // console.log(username, password) // 從 MongoDB 查詢使用者 db.collection(&apos;users&apos;).findOne(&#123; username: username &#125;, function (err, user) &#123; // console.log(user) // 如果伺服器端回傳錯誤訊息，提供 passport 錯誤訊息 if (err) &#123; return done(err) &#125; // 如果沒有在資料庫裡找到該位使用者，不提供 passport 任何使用者資訊，告知失敗原因，並將錯誤資訊放內 flash() 內 if (!user) &#123; return done(null, false, req.flash(&apos;info&apos;, &apos;User not found.&apos;)) &#125; // 驗證密碼 bcrypt.compare(password, user.password, (err, isMatch) =&gt; &#123; // password correct if (isMatch) &#123; return done(null, user) &#125; // 如果從資料庫找到了該名使用者，但密碼錯誤時，不提供 passport 任何使用者資訊，告知失敗原因 return done(null, false, req.flash(&apos;info&apos;, &apos;Invalid password&apos;)) &#125;) &#125;) &#125; )) // 從 strategy 得到輸入值 user，可設定將哪些 user 資訊，儲存在 Session 中的 req.session.passport.user passport.serializeUser(function (user, done) &#123; // 只將用戶 id 序列化存到 session 中，mongoDB 的 id 欄位為 _id done(null, user) &#125;) // 輸入 user (req.session.passport.user) 值，從 session 中取得該資料，儲存在 req.user passport.deserializeUser(function (user, done) &#123; // 為了讓session小一點，透過使用者 id 到 MongoDB 資料庫尋找用戶完整資訊 // const objid = &#123; _id: ObjectID(id) &#125; // db.collection(&apos;users&apos;).findById(id, function (err, user) &#123; // done(err, user) // // console.log(req.user) // &#125;) done(null, user) &#125;)&#125; app.js Code1require(&apos;./verification/passport&apos;)(passport) 建立驗證路由加上 passport.authenticate() middleware 驗證使用者是否認證。 路由基本使用 加上使用的策略 及成功或失敗，各自導向的頁面 Code1234app.post(&apos;/login&apos;, passport.authenticate(&apos;local&apos;, &#123; successRedirect: &apos;/&apos;, failureRedirect: &apos;/users/login&apos;&#125;)) 改寫成驗證成功後，先執行 function()。再導向頁面 Code12345678app.post(&apos;/login&apos;, passport.authenticate(&apos;local&apos;, &#123; failureRedirect: &apos;/login&apos; &#125;), // 驗證成功時，呼叫函式，且 req.user 帶有該使用者資訊 function(req, res) &#123; // 想執行的動作 res.redirect(&apos;/&apos;) &#125;) 如果內建的驗證請求不符合使用，可以客制化 callback 來處理 passport.authenticate(&#39;&lt;strategyName&gt;&#39;, callback&lt;err, user, info&gt;) 這範例，是在 Express 中的路由中去執行，而不是當 middleware 使用。因此這是使用 closure 來在 callback 中取得 req 和 res。如果認證失敗，user 會被設成 false；如果例外發生；err 會被設定；info 則可以拿到 strategy 中 verify callback 所提供的更多訊息 要注意的地方是，使用客制化的 callback 時，需要透過 req.logIn(‘user’, callback) 來建立 session，並且回傳 response。若使用者登入成功，user 會被指定到 req.user。req.logout() 則會移除 req.user 這個屬性，並同時清除 login session(若有的話) Code1234567891011121314151617181920app.post(&apos;/login&apos;, &#123;passport.authenticate(&apos;local&apos;, function (err, user, info) &#123; if (err) &#123; return next(err); &#125; if (!user) &#123; return res.status(200).send(&#123; success: false, message: &quot;帳密錯誤&quot; &#125;) &#125; req.logIn(user, function (err) &#123; if (err) &#123; return next(err); &#125; return res.status(200).send(&#123; success: true, message: &quot;登入成功&quot;, uid: &apos;&apos;, &#125;) // res.redirect(&apos;/&apos;) &#125;); &#125;)(req, res, next); &#125;) 這裡是將 passport.authenticate() 寫在邏輯控制，再給路由引用。 ./controllers/user.js Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 引用 expressconst express = require(&apos;express&apos;)const router = express()// 登入驗證const passport = require(&apos;passport&apos;);// 連接 mongoDBconst db = require(&apos;../connections/mongoDB_connect&apos;)// 加解密const bcrypt = require(&apos;bcryptjs&apos;)// 查詢條件是 id 時，要轉換成 objectIDconst ObjectID = require(&apos;mongodb&apos;).ObjectIDmodule.exports = &#123; getLogin: (req, res) =&gt; &#123; res.render(&apos;login&apos;, &#123; error: req.flash(&apos;info&apos;) &#125;); &#125;, postLogin: function (req, res, next) &#123; passport.authenticate(&apos;local&apos;, function (err, user, info) &#123; if (err) &#123; return next(err); &#125; if (!user) &#123; return res.status(200).send(&#123; success: false, message: &quot;帳密錯誤&quot; &#125;) &#125; req.logIn(user, function (err) &#123; if (err) &#123; return next(err); &#125; return res.status(200).send(&#123; success: true, message: &quot;登入成功&quot;, uid: &apos;&apos;, &#125;) // res.redirect(&apos;/&apos;) &#125;); &#125;)(req, res, next); &#125;, getLogout: function (req, res) &#123; req.logOut() req.session.destroy(() =&gt; &#123; res.clearCookie(&apos;connect.sid&apos;) res.status(200).send(&#123; success: true, message: &apos;已登出&apos; &#125;) // res.redirect(&apos;/&apos;) &#125;) &#125; ...&#125; ./routes/user.js Code1234567891011121314151617181920const express = require(&apos;express&apos;);const router = express.Router();// Include user controller method 解構賦值來使用const &#123; getLogin, postLogin, getSignup, postSignup, getUserInfo, getLogout &#125; = require(&apos;../controllers/user&apos;)// 驗證是否已登入，需驗證的頁面使用const &#123; authenticated &#125; = require(&apos;../verification/auth&apos;)router.get(&apos;/login&apos;, getLogin)router.post(&apos;/login&apos;, postLogin)router.get(&apos;/signup&apos;, getSignup)router.post(&apos;/signup&apos;, postSignup)router.get(&apos;/userinfo&apos;, authenticated, getUserInfo)router.get(&apos;/logout&apos;, getLogout)module.exports = router; 建立 req.isAuthenticated()在 req 物件上可以使用的 passport method，可以拿來做 middleware，來確認使用者是否通過驗證的狀態，獲得瀏覽該頁面的權限。 ./verification/auth.js Code1234567module.exports = &#123; authenticated: (req, res, next) =&gt; &#123; if (req.isAuthenticated()) &#123; return next() &#125; req.flash(&apos;warning_msg&apos;, &apos;請先登入才能此用&apos;) res.redirect(&apos;/user/login&apos;) &#125;&#125; 使用： ./routes/user.js Code12345// 驗證是否已登入，需驗證的頁面使用const &#123; authenticated &#125; = require(&apos;../verification/auth&apos;)//前往 /userinfo 時，驗證身份後才執行 getUserInfo() 渲染頁面router.get(&apos;/userinfo&apos;, authenticated, getUserInfo) 驗證完成後續的請求過程 Session 機制會在一個用戶完成身分認證後，存下所需的用戶資料，接著產生一組對應的對應的 id，存入 cookie 後傳回用戶端。 客戶端產生請求，透過 cookie 上的 session id 至 session 中取得被序列化的用戶資訊，存放到 req.session.passport.user。 passport.initialize() 被觸發：確認 passport.user 上有被序列化的使用者物件，若物件不存在，則創建一個空物件。 passport.session() 被觸發：若有找到被序列化的使用者物件，則判定此請求的用戶是已經通過驗證的狀態。 passport.session() 呼叫 deserializeUser() — 透過用戶 資料前往資料庫找到使用者完整資料，放置在 req.user 上供往後使用。 參考：https://ithelp.ithome.com.tw/articles/10228464?sc=rss.ironhttps://pjchender.github.io/2017/09/26/node-passport-學習筆記（learn-to-use-passport-js）/https://medium.com/麥克的半路出家筆記/筆記-透過-passport-js-實作驗證機制-11cf478f421ehttps://andyyou.github.io/2017/04/11/express-passport/http://sj82516-blog.logdown.com/posts/1249667/nodejs-passportjs-cors-in-the-certification-process-and-developmenthttps://segmentfault.com/a/1190000005783325https://segmentfault.com/a/1190000005783306https://dotblogs.com.tw/daniel/2017/04/08/110915]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Passportjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[處理 vue eslint 錯誤(分號、雙引號、函式空格)]]></title>
    <url>%2F2020%2F04%2F20%2Fvue-eslint-quotes-error%2F</url>
    <content type="text"><![CDATA[Vue eslint 錯誤(vscode)最近在 vscode 中修改之前的 Vue 3.0 程式時，只要存檔後，就會產生關於分號、雙引號、函式空格的相關錯誤。 於是搜尋了一下，找出以下的處理方式。 vscode 安裝 Vetur 套件。之後在 vscode 的 settings.json 加上： Code1234567891011121314&quot;[vue]&quot;: &#123; // 使用 vetur 規則 &quot;editor.defaultFormatter&quot;: &quot;octref.vetur&quot;&#125;,&quot;vetur.validation.template&quot;: false,&quot;vetur.format.defaultFormatterOptions&quot;:&#123; &quot;prettier&quot;:&#123; // 去分號 &quot;semi&quot;: false, // true 使用單引號 &quot;singleQuote&quot;: true, &#125;,&#125;,&quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true, 若是無法解決再用下述方式。 專案根目錄新增 .eslintrc.js，內容如下： Code12345678910111213module.exports = &#123; &quot;rules&quot;: &#123; // &quot;indent&quot;: [&quot;error&quot;, 4], // &quot;linebreak-style&quot;: [&quot;error&quot;, &quot;unix&quot;], &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;], &quot;semi&quot;: [&quot;error&quot;, &quot;never&quot;], &apos;space-before-function-paren&apos;: [&apos;error&apos;, &#123; anonymous: &apos;always&apos;, named: &apos;never&apos;, asyncArrow: &apos;always&apos; &#125;] &#125;&#125; 參考：https://www.cnblogs.com/earthZhang/p/12628618.html]]></content>
      <categories>
        <category>vue</category>
        <category>eslint</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>eslint</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Node.js 與 RESTful API 架構來串接 mongoDB 並部署到 Heroku]]></title>
    <url>%2F2020%2F04%2F15%2Fnodejs-mongodb-restfulapi%2F</url>
    <content type="text"><![CDATA[使用 Node.js 與 RESTful API 架構來串接 mongoDB 並部署到 Heroku網站組成通常是前端加後端、資料庫，簡單來說，前端主要是畫面加上操作介面，包含了一些前端語言及框架，後端則處理使用者請求控制回應，例如登入，後台管理…等等，後端語言常見的有 PHP、Java、ASP.NET、Node.js、Python…等等。資料庫則有 MySQL、MSSQL、MongoDB…。 因前端不斷的演進，畫面處理需快速變化，傳送資料方式也大都改用 Web API 的方式來提供服務。所以後端(server)就負責建立 API，透過串接 API 處理資料。 這邊就要來使用 Node.js 搭配 express 架構 RESTful API，連接 MongoDB，並部署到 server。 MongoDB是開源的 NoSQL 資料庫，不需先制定每張資料表的結構、畫出 ER Model，因此不管是用來做個人專案，還是用來處理較大量資料都可以。 MongoDB 是用 Key-value 的方式來儲存資料： Code1234&#123; name: &quot;john&quot;, job: &quot;farmer&quot;&#125; 另外 MongoDB 不是 JSON 格式，而是 BSON。它的 key 和 value 是有區分大小寫。但 MongoDB 大都是用 JSON 格式來儲存資料。 ps.BSON(Binary JSON)，是 JSON 的擴充，因此可使用 Binary data 等。 MongoDB 跟傳統資料庫大致上對應的關係： DB MongoDB MySQL 資料名稱 Document Row 資料存放區名稱 Collection Table 資料庫名稱 Database Database RESTful APIREST(Resource Representational State Transfer 具象狀態變化傳輸)，API(Application Programming Interface 應用程式介面)。 RESTful API 可以理解成具有 Rest 架構的 Web API，是一種設計風格。意思大致上是，由發送的 HTTP 請求中所包含的資訊，就可以容易解讀出這請求會收到什麼類型的資料。用淺顯易懂的方式來解釋，就是只看 API 的格式就可以看得懂。 由於 API 設計方式跟 HTTP 請求及資料庫資料操作有關，因此就簡略說明一下： 常見的 HTTP 請求方式：GET：取得資料POST：新增一筆新的資料(如果存在會新增一筆新的)PUT：更新一筆資料，如果存在這筆資就會覆蓋過去PATCH：部分更新資料DELETE：刪除資料 資料庫基本操作 CRUD：Create(新增)Read(讀取)Update(更新)Delete(刪除) 常見的 HTTP method 正好會對應到資料庫基本操作。 假設有一組待辦事項的 API，或許會用以下方式來設計： 獲得資料GET /getData新增資料POST /createData刪除資料DELETE /deleteData/1 以 REST 風格來開發 RESTful API： 獲得資料GET /data新增資料POST /data刪除資料DELETE /data/1 兩者差異是在於 RESTful API 充分地使用了 HTTP Protocol Method，達到： 1.直觀簡潔的資源 URI2.並且善用 HTTP Verb3.達到對資源的操作4.並使用 Web 所接受的資料類型: JSON, XML, YAML 等，最常見的是 JSON。 前置工作1.建立 heroku 上的 mongoDB 資料庫 2.heroku 建立新 App 3.安裝 mlab 套件 要填寫信用卡資料(才能用 Add-ons) 首先到我們要安裝插件的應用程式頁面，點選「Configure Add-ons」 在搜尋列打上「mlab」，並安裝 4.建立使用者 5.記得連線 URL mlab 建立後，可在畫面上找到。 格式：&quot;mongodb://dbuser:dbpass@host1:port1,host2:port2/dbname&quot; 6. 接下來就是程式處理方面。 建立 nodejs server先建立專案資料夾 npm init npm install express --save 建立 index.js Code1234567891011121314// 引用 expressconst express = require(&apos;express&apos;);const server = express();// 預設 portconst port = process.env.PORT || 3000// 建立 get method 顯示 index.html 內容server.get(&apos;/&apos;, (req, res) =&gt; &#123; // __dirname 回傳被執行 js 檔所在資料夾的絕對路徑 res.sendFile(__dirname + &apos;/index.html&apos;)&#125;)// 監聽 portserver.listen(port, () =&gt; console.log(`Listening on $&#123;port&#125;`)) 建立 index.html Code1234567891011&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Welcome&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; package.json 加上 Code123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node index.js&quot; // 加此行 &#125;, 測試一下，終端機下執行 npm start，在瀏覽器網址輸入 http://localhost:3000/ 。看畫面是否成功出現 welcome 字樣。 連線 mongodb1.安裝 mongodb npm install mongodb --save index.js 加上以下內容： Code12345678910111213// 引用const MongoClient = require(&apos;mongodb&apos;).MongoClient;// mongoDB 連線位置(可看 heroku 的 mlab 頁面有資訊)const url = &apos;mongodb://&lt;username&gt;:&lt;password&gt;@&lt;host1&gt;:&lt;port1&gt;/&lt;dbName&gt;&apos;;// 連線 mongoDBMongoClient.connect(url, function (err, db) &#123; if (err) throw err; const dbo = db.db(&quot;&lt;dbName&gt;&quot;) console.log(&apos;mongoDB in running&apos;) db.close()&#125;); 測試一下，終端機下執行 npm start，終端機畫面上是否顯示 Listening on 3000 字樣。 若產生以下字樣 (node:39803) DeprecationWarning: current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor. 修改連線內容 Code12345678910// 連線 mongoDB// 加上以下設定//&#123; useNewUrlParser: true, useUnifiedTopology: true &#125;MongoClient.connect(url, &#123; useNewUrlParser: true, useUnifiedTopology: true &#125;, function (err, db) &#123; // 連線資料庫 const dbo = db.db(&quot;&lt;dbName&gt;&quot;) console.log(&apos;mongoDB in running&apos;) // 關閉連線 db.close()&#125;); MongoDB 加上一筆資料修改 index.js Code1234567891011121314151617// 連線 mongoDBMongoClient.connect(url, &#123; useNewUrlParser: true, useUnifiedTopology: true &#125;, function (err, db) &#123; if (err) throw err; // 連線資料庫 const dbo = db.db(&quot;&lt;dbName&gt;&quot;) // console.log(&apos;mongoDB in running&apos;) // // 關閉連線 // db.close() // 建立一筆資料 const myobj = &#123; name: &quot;jw&quot;, time: &quot;2020/04/14/15:00&quot;, content: &quot;hello world&quot; &#125;; // mongoDB 的操作方式 dbo.collection(&quot;comments&quot;).insertOne(myobj, function (err, res) &#123; if (err) throw err; console.log(&quot;1 document inserted&quot;); db.close(); &#125;);&#125;); 執行 npm start，畫面上會顯示 1 document inserted。 heroku 的 mlab 頁面上會有新增的資料。 Get API-取得資料index.js Code123456789//GET API 從 http://localhost:3000/comments 取得資料server.get(&apos;/comments&apos;, (req, res) =&gt; &#123; // 回傳 comments 的所有資料 db.collection(&apos;comments&apos;).find().toArray((err, result) =&gt; &#123; if (err) return console.log(err) // 顯示取得資料在頁面上 res.send(&#123; data: result &#125;) &#125;)&#125;) 終端機輸入 npm start，打開瀏覽器 http://localhost:3000/comments， 可以看到畫面顯示資料。 POST API-新增資料下載 body-parser 套件，來處理資料格式，將其轉型別成 JSON。 npm install body-parser --save index.js 加上 Code12345678910111213141516171819202122232425const bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.json());// POST API 路徑為/comments expressjs 取參數的方法之一 req.bodyserver.post(&apos;/comments&apos;, (req, res) =&gt; &#123; // 顯示 clinet 端傳送過來的 JSON console.log(req.body); db.collection(&apos;comments&apos;).save(req.body, (err, result) =&gt; &#123; if (err) return console.log(err) console.log(&apos;saved to database&apos;) res.send(req.body); &#125;);&#125;)// modify server.listen(3000, () =&gt; &#123;&#125;);/* 將之前的監聽 server.listen(port, () =&gt; console.log(`Listening on $&#123;port&#125;`)) 註解掉，改寫至 MongoClient.connect() 裡 */MongoClient.connect(url, &#123; useNewUrlParser: true, useUnifiedTopology: true &#125;, (err, client) =&gt; &#123; if (err) return console.log(err) db = client.db(&apos;&lt;dbName&gt;&apos;) server.listen(port, () =&gt; &#123; console.log(&apos;listening on 3000&apos;) &#125;)&#125;) 執行 npm start，打開瀏覽器輸入網址 localhost:3000，在 console 輸入： JavaSript fetch post Code1234567891011121314fetch(&apos;http://localhost:3000/comments&apos;, &#123; method: &apos;post&apos;, headers: &#123; &apos;Accept&apos;: &apos;application/json, text/plain, */*&apos;, &apos;Content-Type&apos;: &apos;application/json&apos; &#125;, // 傳給 server 的 JSON body: JSON.stringify(&#123; &quot;name&quot;: &quot;jw&quot;, &quot;time&quot;:&quot;2020/04/13-15:10:01&quot;, &quot;content&quot;: &quot;Hello&quot; &#125;)&#125;).then(res=&gt;res.json()) .then(res =&gt; console.log(res)) ps. 顯示 (node:3970) DeprecationWarning: collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead. 修改 save() 為提示中的函式 insertOne()…等等 DELETE API-刪除資料利用 網址:id 來帶參數，方便維運 API。若要使用 MongoDB 預設的 _id 當作查詢刪除，需要使用 ObjectID 處理來 value，但如果使用其他物件來作查詢，就不需使用 ObjectID。 index.js Code123456789101112131415161718const ObjectID = require(&apos;mongodb&apos;).ObjectID;// DELETE APIserver.delete(&apos;/comments/:id&apos;, (req, res) =&gt; &#123; // use _id need use ObjectID(value) const obj = &#123; _id: ObjectID(req.params.id) &#125;; // 顯示刪除 _id console.log(obj) if (!obj) &#123; res.sendStatus(403); &#125; db.collection(&quot;comments&quot;).deleteOne(obj, function (err, obj) &#123; if (err) throw err; console.log(&quot;1 document deleted&quot;); // 回傳訊息 res.send(&apos;delete success&apos;); &#125;);&#125;) ps. 顯示 (node:3826) DeprecationWarning: collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead. 修改 remove() 為提示中的函式 deleteOne()…等 PUT API-更新(UPDATE)資料用 updateOne(obj, newvalues, function(err, obj){}) 來更新資料，前面兩個參數分別帶查詢條件及更新資料。 index.js Code1234567891011121314server.put(&apos;/comments/:id&apos;, (req, res) =&gt; &#123; // 顯示 id 及 修改內容 console.log(req.params.id, req.body); if (!req.body) &#123; res.sendStatus(403); &#125; const newvalues = &#123; $set: req.body &#125;; const obj = &#123; _id: ObjectID(req.params.id) &#125;; db.collection(&quot;comments&quot;).updateOne(obj, newvalues, function (err, obj) &#123; if (err) throw err; console.log(&quot;1 document update&quot;); res.send(&apos;update success&apos;); &#125;);&#125;) 建立 config.json可以將連線字串、帳密…環境變數等，放在這再引用，方便修改管理。 config.json Code123&#123; &quot;DB_URL&quot; : &quot;&quot;mongodb://dbuser:dbpass@host1:port1,host2:port2/dbname&quot;&quot;&#125; index.js 加上 const { DB_URL: url } = require(&#39;./config.json&#39;); postman 測試處理完 RESTful API 部分後，可以使用 postman 來測試。 GET% asset_img postman_get.png This is an image %} POST(記得依照標頭輸入設定來調整) PUT(記得依照標頭輸入設定來調整) DELETE 部署到 Heroku部署到 server 上，可方便使用 API。 終端機輸入： heroku config set Code1$ heroku config:set PROD_MONGODB=mongodb://dbuser:dbpass@host1:port1,host2:port2/dbname 2.登入 heroku heroku login 3.建立 GIT git initgit add .git commit -m &quot;nodejs&quot; 4.設定連結的 heroku 遠端主機 heroku git:remote -a (Heroku 上 的 App 名稱) 5.push remote git push heroku master heroku open 打開瀏覽器，輸入 heroku 的 app 路徑加上 /comments。 接著處理前端及畫面互動就可以做其他運用了。 CORS若是其他應用要連線 heroku 取用 API 資料時，有可能會發生 CORS 問題。可用以下方式處理。 1.後端 API 開放跨網域 cors 權限 安裝 cors npm install cors index.js 加上 const cors = require(&#39;cors&#39;) server.use(cors()); 也可以單一 API 使用 Code12345server.get(&apos;/&apos;, (req, res) =&gt; &#123; res.send(&apos;welcome&apos;); res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;*&apos;);&#125;); 2.使用第三方資源來協助存取使用 cors-anywhere、bypasscors 將 cors-anywhere 所提供的 API 放前面，後面加上要訪問的 API。 e.g. Code12345678910111213// use cors-anywhere to fetch api dataconst cors = &apos;https://cors-anywhere.herokuapp.com/&apos;; // origin api urlconst url = &apos;https://xxx.xxx/xxx.php?=2223&apos;;axios.get(`$&#123;cors&#125;$&#123;url&#125;`) .then((response) =&gt; &#123; const msg = response.data; document.body.innerHTML = JSON.stringify(msg) &#125;, (error) =&gt; &#123; &#125; ); 參考：https://iandays.com/2018/10/11/nodejsapi/https://blog.johlmike.com/2016/08/05/heroku-cha-jian-mlab-mongodb-zi-liao-ku/https://blog.johlmike.com/2016/07/12/mongoose-node-js-上連接-mongodb/#more-453https://ithelp.ithome.com.tw/articles/10186483https://dotblogs.com.tw/felixblog/2019/12/11/171324https://medium.com/%E4%BC%81%E9%B5%9D%E4%B9%9F%E6%87%82%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/express-restfulapi%E8%B5%B7%E6%89%8B%E6%95%99%E5%AD%B83-77206cd64ebbhttps://i5ting.github.io/node-http/https://progressbar.tw/posts/53https://medium.com/itsems-frontend/api-是什麼-restful-api-又是什麼-a001a85ab638https://ithelp.ithome.com.tw/articles/10157431https://ithelp.ithome.com.tw/articles/10157674https://noob.tw/mongodb/https://medium.com/@des75421/cors-跨來源資源共用cors-191d4bfc4735https://andy6804tw.github.io/2017/12/27/middleware-tutorial/#中介軟體https://andy6804tw.github.io/2019/09/21/fix-cors-problem/]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Heroku</tag>
        <tag>MongoDB</tag>
        <tag>RESTful</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postman 好用 API 測試工具]]></title>
    <url>%2F2020%2F04%2F14%2Fpostman%2F</url>
    <content type="text"><![CDATA[Postman模擬 HTTP Request 來測試 API 的好用工具，包含幾種 HTTP 請求方式： GET 、POST、PUT、DELETE。 安裝安裝版下載網址https://www.postman.com/downloads/ Chrome 線上應用程式https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=zh-TW 可以選擇註冊於否，皆可正常使用。 畫面基本使用欄位 Headers設定請求中的內容是使用何種編碼方式，包含了 Key 和 Value 两部分。 Key：大都使用 Content-TypeValue：application/x-www-form-urlencoded：瀏覽器的 form，就是在 url 後面加上 key=val。 multipart/form-data：加上 enctype 屬性，送出訊息後會用 boundary 分割不同的字段，後面再接要送出的欄位與值。 application/json：JSON 格式。{ “name”: “john”} Method 使用GET取得資料 POST新增資料（如果存在會再新增一筆新的，以資料庫來說，就是ID不一樣。) headers 設定傳送資料編碼方式 PUT更新一筆資料，如果資料存在就會覆蓋過去 使用方式，跟 POST 差不多。把 method 選擇 PUT ，Body 輸入資料即可。 DELETE刪除資料 PATCH針對已經存在的資料欄位去做部分更新 參考：https://ithelp.ithome.com.tw/articles/10201503https://ithelp.ithome.com.tw/articles/10201528https://progressbar.tw/posts/53]]></content>
      <categories>
        <category>API</category>
      </categories>
      <tags>
        <tag>postman</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket 介紹]]></title>
    <url>%2F2020%2F04%2F09%2FWebSocket-base%2F</url>
    <content type="text"><![CDATA[WebSocket 介紹WebSocket 是網路協定的一種，只需要連線一次。Client 與 Server 便能保持連線進行雙向傳輸溝通，不必一直發送 Request 保持溝通。 請求網址通常是： ws://example.com //SSL 加密後 wss://example.com 以下開始建立 WebSocket 連線測試，分別建立 Server 跟 Client 端。 Server 端建立連接環境使用 node.js 來寫後端程式。安裝好 node.js 後，建立專案資料夾後執行： npm init 然後下載兩個套件來使用: // Web 框架 npm install express --save // 處理 WebSocket 協定 npm install ws --save 新增一個 server.js 檔，內容如下： Code12345678910111213141516171819202122232425//import express 和 ws 套件const express = require(&apos;express&apos;)const SocketServer = require(&apos;ws&apos;).Server//指定開啟的 portconst PORT = process.env.PORT || 3000//建立 express 的物件，並監聽 3000 port ，開啟後在 console 中提示const server = express() .listen(PORT, () =&gt; console.log(`Listening on $&#123;PORT&#125;`))//將 express 交給 SocketServer 開啟 WebSocket 的服務const wss = new SocketServer(&#123; server &#125;)//當 WebSocket 從外部連結時執行wss.on(&apos;connection&apos;, ws =&gt; &#123; //連結時執行此 console 提示 console.log(&apos;Client connected&apos;) //當 WebSocket 的連線關閉時執行 ws.on(&apos;close&apos;, () =&gt; &#123; console.log(&apos;Close connected&apos;) &#125;)&#125;) 執行 server.js 檔。測試檔案是否 ok。cmd 環境專案資料夾下輸入： node server.js 若成功開啟，console 會出現提示 Listening on 3000 ps. 注意 package.json 裡的 “main”: “server.js”, 接收發送訊息(接收 Clinet 訊息處理後回傳)開啟 WebSocket 後， Server 端使用 send 發送訊息，接收則是如同在 connection 內監聽 close 一樣，只是加入對 message 設定監聽，並接收一個參數 data(Client 端發送的訊息)： Code12345678910111213wss.on(&apos;connection&apos;, ws =&gt; &#123; console.log(&apos;Client connected&apos;) //對 message 設定監聽，接收從 Client 發送的訊息 ws.on(&apos;message&apos;, data =&gt; &#123; //data 為 Client 發送的訊息，現在將訊息原封不動發送出去 ws.send(data) &#125;) ws.on(&apos;close&apos;, () =&gt; &#123; console.log(&apos;Close connected&apos;) &#125;)&#125;) Server 端直接發送資料給 Clinet 端(用 setInterval )// setInterval() 則是固定延遲了某段時間之後，才去執行對應的程式碼，然後 “不斷循環”。 發送訊息改寫： Code123456789101112131415161718wss.on(&apos;connection&apos;, ws =&gt; &#123; console.log(&apos;Client connected&apos;) //固定送最新時間給 Client const sendNowTime = setInterval(()=&gt;&#123; ws.send(String(new Date())) &#125;,1000) ws.on(&apos;message&apos;, data =&gt; &#123; ws.send(data) &#125;) ws.on(&apos;close&apos;, () =&gt; &#123; //連線中斷時停止 setInterval clearInterval(sendNowTime) console.log(&apos;Close connected&apos;) &#125;)&#125;) 多人連線環境( ws 套件使用 clients )當某個 Client 發送訊息時，同時讓 Server 告知所有其他連接中的 Client，Server 所收到的訊息，也同時接收到 Server 回傳的資料。類似廣播功能。 改寫監聽 message 部分， 加入 Clients 發送的訊息 Code12345678910111213141516171819wss.on(&apos;connection&apos;, ws =&gt; &#123; console.log(&apos;Client connected&apos;) ws.on(&apos;message&apos;, data =&gt; &#123; //取得所有連接中的 client let clients = wss.clients //做迴圈，發送訊息至每個 client clients.forEach(client =&gt; &#123; client.send(data) //傳送時間 //client.send(new Date().toTimeString()); &#125;) &#125;) ws.on(&apos;close&apos;, () =&gt; &#123; console.log(&apos;Close connected&apos;) &#125;)&#125;) Client 端建立連接環境新增一個專案資料夾，新增 index.js，內容如下： Code123456789101112//使用 WebSocket 網址連結 Serverlet ws = new WebSocket(&apos;ws://localhost:3000&apos;)//開啟後執行的動作，指定一個 function 會在連結 WebSocket 後執行ws.onopen = () =&gt; &#123; console.log(&apos;open connection&apos;)&#125;//關閉後執行的動作，指定一個 function 會在連結中斷後執行ws.onclose = () =&gt; &#123; console.log(&apos;close connection&apos;)&#125; 接著新增 index.html，內容如下： Code123456// 引用 index.js&lt;html&gt; &lt;body&gt; &lt;script src=&apos;./index.js&apos;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 接收發送訊息( Client 發送訊息給 Server 處理後得到回傳資料)Client 端用 onmessage 處理接收，用 send 送出訊息： Code1234567891011121314let ws = new WebSocket(&apos;ws://localhost:3000&apos;)ws.onopen = () =&gt; &#123; console.log(&apos;open connection&apos;)&#125;ws.onclose = () =&gt; &#123; console.log(&apos;close connection&apos;)&#125;//接收 Server 發送的訊息，Server 回傳的資料會在 event 的 data 屬性ws.onmessage = event =&gt; &#123; console.log(event)&#125; 測試連結是否成功server 端訊息(cmd 環境下) 用瀏覽器開啟 index.html，連結 server 端。打開 console，會顯示 open connection 字樣，輸入 ws 看訊息。 列出 WebSocket 的物件有哪些屬性， Client 是用 onmessage 屬性接收由 Server 發送的資料。 server 端接收訊息後，是否回傳雙向連線環境建立完後，開啟瀏覽器 index.html 。然後在 console 環境中，輸入 ws.send(&#39;hello&#39;)，來測試。Server 是否有接收到資料(console 環境內看)。 將 WebSocket 部署至 Heroku利用 Git 的方式上傳至 Heroku Heroku 註冊並開啟新 app註冊網址 註冊後登入，從右上 New 選單中， Create new app 建立。 安裝 Heroku CLIHeroku CLI 到上面網站，依照本身電腦系統下載後安裝。 建立 Git 環境切換到要上傳的專案資料夾下，輸入以下指令： // 初始化資料夾 git init // 打包檔案 git add . // 寫註解 git commit -m &quot;upload&quot; // 登入 Heroku，開啟登入頁面，輸入帳密 heroku login // 設定連結的 heroku 遠端主機heroku git:remote -a (Heroku 上 的 App 名稱) e.g. heroku git:remote -a xxx // 上傳至 heroku git push heroku master 上傳前程式調整(上述的範例)package.jsonCode12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, // 加上此行，node 後面要對應 main 屬性的值 &quot;start&quot;: &quot;node server.js&quot;&#125;, server.js頁面加上 WebSocket test!! 字樣 Code12345678910111213141516171819202122232425262728293031加上//引用&apos;http&apos;模組const http = require(&apos;http&apos;);// 建立一個server並指定他的頁面資訊，並監聽 port ，開啟後在 console 中提示const server = http.createServer((req, res) =&gt; &#123; // 進入網站首頁顯示 index if (req.url == &apos;/&apos;) &#123; // 設定 response header res.writeHead(200, &#123; &apos;Context-Type&apos;: &apos;text/html&apos; &#125;); // 回應內容 res.write(&apos;&lt;h1&gt;WebSocket test!!&lt;/h1&gt;&apos;); // 送出 response res.end(); // 不是的話顯示 404 例如 /abc/ &#125; else &#123; res.writeHead(200, &#123; &apos;Context-Type&apos;: &apos;text/html&apos; &#125;); res.write(&apos;&lt;h1&gt;404&lt;/h1&gt;&apos;); res.end(); &#125;&#125;).listen(PORT, () =&gt; console.log(`Listening on $&#123;PORT&#125;`))// 註解以下程式// 建立 express 的物件，並監聽 port ，開啟後在 console 中提示// const server = express().listen(PORT, () =&gt; console.log(`Listening on $&#123;PORT&#125;`)) index.js將原本連結的網址調整成 Heroku 給的網站 let ws = new WebSocket(&#39;ws://appname.herokuapp.com/&#39;) 然後在瀏覽器開啟 index.html，打開 console。看是否有 open connection 字樣，確認是否成功。 ps:因為 WebSocket 只連線一次就可以雙向傳輸，因此開發人員工具的 Network 看不到 Request 的資料，但是傳遞過程可以透過第一次要求連接時的 Request 中觀察。 關於 WebSocket 傳送資料時，除了字串外還可以使用 USVString、ArrayBuffer、Blod、ArrayBufferView …，另外傳送 JSON 時，記得在 send 中做 JSON.stringify ，接收到時再用 JSON.parse 轉成物件處理。 參考：Heroku | 搭配 Git 在 Heroku 上部署網站的手把手教學JavaScript | WebSocket 讓前後端沒有距離https://www.npmjs.com/package/ws六角學院課程]]></content>
      <categories>
        <category>WebSocket</category>
        <category>Heroku</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>Heroku</tag>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hamburger_menu 介紹]]></title>
    <url>%2F2020%2F03%2F26%2Fhamburger-menu%2F</url>
    <content type="text"><![CDATA[hamburger_menu 漢堡式選單常運用在小尺寸螢幕的機器上，可以保持畫面簡單、選單設計彈性等等優點。 但有時會產生操作上的問題，例如不夠直覺、操作麻煩等問題。應該依照實際情況跟頁籤式選單交互或配合使用。 這裏介紹一下，如何實作漢堡式選單。這裡是將選單列或導覽列切換成漢堡式選單，固定在畫面左上角，可以依照情況調整。 首先處理 HTML 部分 Code1234567891011121314&lt;body&gt; &lt;!--選單--&gt;&lt;ul class=&quot;menu-s&quot;&gt; &lt;li&gt;&lt;a href=&quot;#profile&quot;&gt;profile&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#resume&quot;&gt;resume&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#skill&quot;&gt;skills&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#portfolio&quot;&gt;portfolio&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;contact&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--圖示--&gt;&lt;a href=&quot;#&quot; class=&quot;showmenu&quot;&gt; menu&lt;/a&gt;&lt;/body&gt; 接著是 CSS Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 漢堡選單// 圖示，一開始隱藏 display: none;.showmenu &#123; color: #69CA62; display: none; width: 50px; height: 50px; position: fixed; top: 30px; left: 25px; // 置於其他元素上 z-index: 9; cursor: pointer; .fa-bars &#123; font-size: 35px; &#125;&#125;// 選單.menu-s &#123; position: fixed; // display: none; width: 100%; // border-bottom: 1px solid #777; // padding: 10px 20px; text-transform: uppercase; // background-color: rgba(255, 255, 255, 0.8); // 置於其他元素上 z-index: 9; list-style-type: none; li &#123; line-height: 2em; &#125; a &#123; color: #69CA62; text-decoration: none; &#125;&#125;// 當螢幕尺寸小於 768px 時@media (max-width: 768px) &#123; .menu-s &#123; /* 選單出現*/ display: block; /*隱藏選單開始*/ max-height: 0px; overflow: hidden; /*隱藏選單結束*/ transition: max-height 2.3s; margin-top: 1px; /*絕對定位疊在網頁上*/ position: fixed; z-index: 9; /*header 80px+1px boder 線條*/ top: 81px; left: 0; right: 0; // background: #69CA62; &#125; // .menu-s li&#123; // border-bottom: 1px dashed #69CA62; // &#125; .menu-s li a&#123; transition: all 0.2s; &#125; .menu-s li a:hover&#123; background: gray; color: #fff; &#125; // 顯示圖示 .showmenu&#123; display: block; float: right; margin: 1em; &#125; /*jQ點擊後動態在 body 加上 class 影響選單高度*/ .menu-show .menu-s &#123; max-height: 500px &#125;&#125; 最後是 jQuery Code123456789$(document).ready(function () &#123; $(&apos;.showmenu&apos;).on(&apos;click&apos;, function (e) &#123; // 讓原來 &lt;a&gt; 效果失效 e.preventDefault(); $(&apos;body&apos;).toggleClass(&apos;menu-show&apos;); &#125;);&#125;);/* toggleClass()可以用來為匹配的元素進行新增或是刪除CSS類別。實際運作時有點類似開關一樣。如果某個類別存在，那就刪除他，若是不存在那就新增。 */ 以上是程式碼部分，下列網址是 demo。 https://codepen.io/jw103/pen/xxGQPOZ?editors=1111 另外也可以使用 Bootstrap 4 的模板來做。 參考：https://a-cart.com.tw/blog/blog_detail/204https://w3c.hexschool.com/blog/5054d6fe]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>hamburger_menu</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base64 轉檔加快圖片載入]]></title>
    <url>%2F2020%2F03%2F19%2Fbase64image%2F</url>
    <content type="text"><![CDATA[base64可將圖片轉成字串形式再引用，以加快網頁載入速度。適合容量較小的圖檔。 轉檔網站： https://www.base64-image.de 將圖片拖曳網頁上或是選取圖片檔案，轉檔後。按下 show code 按鈕，會顯示引用方式。即可引用。 參考：https://cythilya.github.io/2018/07/26/base64-images/https://sofree.cc/base64-images/]]></content>
      <tags>
        <tag>image</tag>
        <tag>efficacy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[簡單介紹 maskmap 查詢網站]]></title>
    <url>%2F2020%2F02%2F21%2Fmaskmap%2F</url>
    <content type="text"><![CDATA[簡單介紹口罩查詢地圖製作因為看到網路上有相關網站製作的教學，就試著做了一個簡易的查詢網站。 建立模板是使用教學提供的，沒有做什麼變動。使用 vue create 來建立專案 Vue CLI 4.2使用 vue create 來建立專案 套件leafletjs用來建立免費地圖 OSM 的地標資訊 npm install --save leaflet 記得載入 css 樣式 Code1234567&lt;link rel=&apos;stylesheet&apos; href=&apos;https://unpkg.com/leaflet@1.5.1/dist/leaflet.css&apos;&gt;or&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.6.0/dist/leaflet.css&quot; integrity=&quot;sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==&quot; crossorigin=&quot;&quot;/&gt; 載入套件 在要使用的檔案 &lt;script&gt;&lt;/script&gt; 標籤內 import L from &#39;leaflet&#39; bootstrap處理 css 樣式 npm install --save bootstrap@4.0.0-beta.3 安裝完後檔案路徑node_modules/bootstrap/scss/bootstrap 載入套件 在要使用的檔案 &lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 標籤內 @import &#39;bootstrap/scss/bootstrap&#39;; axios vue-axios處理 ajax 及 API 資料部分 npm install --save axios vue-axios 載入 在 main.js 加入 Code1234import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos; Vue.use(VueAxios, axios) jQuerynpm install — save jquery popper.js 載入 在要使用的檔案 &lt;script&gt;&lt;/script&gt; 標籤內 import $ from &quot;jquery&quot;; webpack 中設定必須要在 webpack 執行時就去載入 jQuery ，修改./build/webpack.base.conf.js，加入以下程式碼： Code12345678910111213var webpack = require(&apos;webpack&apos;)接著在同一份檔案當中加入plugin設定module.exports = &#123; entry: &#123;&#125;, output: &#123;&#125;, resolve: &#123;&#125;, module: &#123;&#125;, plugins: [new webpack.ProvidePlugin(&#123; jQuery: &apos;jquery&apos;, $: &apos;jquery&apos;, jquery: &apos;jquery&apos;&#125;)]&#125; 台灣縣市鄉鎮 JSON以下網址可下載台灣縣市鄉鎮資訊 https://github.com/donma/TaiwanAddressCityAreaRoadChineseEnglishJSON 載入 在檔案的 &lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 標籤內，加上 import cityName from &#39;./assets/CityCountyData.json&#39; 藥局資訊 APIhttps://raw.githubusercontent.com/kiang/pharmacies/master/json/points.json leafletjs 基本操作建立地圖、圖標、訊息…等等Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;div class=&quot;col-sm-9&quot;&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;// 載入 leaflet 套件import L from &apos;leaflet&apos;export default &#123; name: &apos;home&apos;, data: () =&gt; (&#123; osmMap: &#123;&#125;, &#125; &#125;),mounted () &#123;// 新增並顯示地圖this.osmMap = L.map(&apos;map&apos;, &#123; center: [25.03, 121.55], zoom: 15 &#125;)// 載入圖層到地圖(不然地圖會是空白) L.tileLayer(urlTemplate, options).addTo(map) L.tileLayer(&apos;https://&#123;s&#125;.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png?&#123;foo&#125;&apos;, &#123; foo: &apos;bar&apos;, attribution: &apos;Map data &amp;copy; &lt;a href=&quot;https://www.openstreetmap.org/&quot;&gt;OpenStreetMap&lt;/a&gt; contributors, &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/2.0/&quot;&gt;CC-BY-SA&lt;/a&gt;&apos;, maxZoom: 18 &#125;).addTo(this.osmMap) // 加上圖標 // L.marker([25.0085455, 121.4594333]).addTo(this.osmMap) // 加上圖標與訊息 // L.marker([ // geometry.coordinates[1], // geometry.coordinates[0] // ]).addTo(this.osmMap).bindPopup( // `&lt;strong&gt;$&#123;properties.name&#125;&lt;/strong&gt; &lt;br&gt; // 口罩剩餘：&lt;strong&gt;成人 - $&#123;properties.mask_adult ? `$&#123;properties.mask_adult&#125; 個` : &apos;未取得資料&apos;&#125;/ 兒童 - $&#123;properties.mask_child ? `$&#123;properties.mask_child&#125; 個` : &apos;未取得資料&apos;&#125;&lt;/strong&gt;&lt;br&gt; // 地址: &lt;a href=&quot;https://www.google.com.tw/maps/place/$&#123;properties.address&#125;&quot; target=&quot;_blank&quot;&gt;$&#123;properties.address&#125;&lt;/a&gt;&lt;br&gt; // 電話: $&#123;properties.phone&#125;&lt;br&gt; // &lt;small&gt;最後更新時間: $&#123;properties.updated&#125;&lt;/small&gt;`, &#123; closeOnClick: false &#125;).openPopup() // 多邊形 // L.polygon([ // [22.992, 120.289], // [22.982, 120.299], // [22.970, 120.267], // [22.990, 120.267] // ]).addTo(this.osmMap) // 圓形 // L.circle( // [22.988, 120.220], // 圓心座標 // 1000, // 半徑（公尺） // &#123; // color: &apos;red&apos;, // 線條顏色 // fillColor: &apos;#f03&apos;, // 填充顏色 // fillOpacity: 0.5 // 透明度 // &#125; // ).addTo(this.osmMap) // 獨立訊息 // L.popup() // .setLatLng([23.010, 120.289]) // .setContent(&apos;獨立的訊息方塊。&apos;) // .openOn(this.osmMap) // 連接到指定點 //this.osmMap.panTo([geometry.coordinates[1], geometry.coordinates[0]]); &#125;&lt;/script&gt; 刪除地標OSM 是以圖層的概念來組成，地標會以圖層類型累加，因此地標數量過多會影響效能。所以在切換查詢地點時，最好要清除其他不需要顯示的地標。 Code1234567removeMarker () &#123; this.osmMap.eachLayer((layer) =&gt; &#123; if (layer instanceof L.Marker) &#123; this.osmMap.removeLayer(layer) &#125; &#125;) &#125;, 改變地標樣式Code1234567891011121314const greenIcon = L.icon(&#123; iconUrl: &apos;https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png&apos;, iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowUrl: &apos;https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png&apos;, shadowSize: [41, 41], shadowAnchor: [12, 41] &#125;) const &#123; properties, geometry &#125; = item L.marker([ geometry.coordinates[1], geometry.coordinates[0] ], &#123; icon: greenIcon &#125;).addTo(this.osmMap) 其他程式載入藥局資訊Code12345const api = &apos;https://raw.githubusercontent.com/kiang/pharmacies/master/json/points.json&apos; this.$http.get(api).then((Response) =&gt; &#123; // console.log(Response) this.data = Response.data.features &#125;) 其他程式碼部分可參考 https://github.com/Wcc723/wheremask 個人實作網站(有做小地方調整)https://jw310.github.io/maskmap/#/ 參考：https://www.openstreetmap.org/https://leafletjs.com/https://leafletjs.com/examples/quick-start/https://blog.gtwang.org/web-development/leaflet-open-source-javascript-library-for-mobile-friendly-interactive-maps/https://www.youtube.com/watch?v=pUizu62dlnYhttps://www.youtube.com/watch?v=7CXnNMVMXeo&amp;t=2s六角學院]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>Leafletjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM 介紹]]></title>
    <url>%2F2020%2F02%2F03%2FNPM%2F</url>
    <content type="text"><![CDATA[NPMnpm（全稱 Node Package Manager，即「node包管理器」）是Node.js 預設的、以 JavaScript 編寫的軟體套件管理系統。 專案使用 npm到專案資料夾下，輸入以下指令 $npm init 會新增 package.json 檔案紀錄套件安裝情況。 安裝套件 $sudo npm install express —save ps. mac 有時要加 sudo 指令npm -v ：觀看 NPM 版本 npm init ：新增 package.json npm install [模組名稱][參數]：安裝 NPM 模組，會根據 package.json 去下載安裝套件，放在 node_modules 資料夾。 安裝位置常用屬性如下： -g：全域安裝，安裝資料夾位置 /usr/local/lib/node_modules。 –save：安裝模組及紀錄在 package.json 的 “dependencies” 中，並產生 node_modules 資料夾。 –save-dev：安裝模組並寫入 package.json 的“devDependencies”。 npm start(npm run start)：執行 package.json 裡的 scripts 中的 start 指令(express)。 npm list：顯示安裝的 NPM 列表。 npm uninstall [模組名稱]：刪除專案裡的 NPM。 版本號編碼 1.12.0 -1 主要版本號 -12 次要版本號 -0 bug 修正 推薦套件nodemon 套件：它會監視你的程式碼有無的任何更改並自動重新啟動服務，這時只要刷新你的瀏覽器就能看到改動，此外 nodemon 使用 npm 進行安裝，只需使用 nodemon 取代 node 執行你的程式碼，就能輕鬆的開發 node.js。 npm install nodemon -g 安裝於專案資料夾中 npm install --save-dev nodemon // 執行，網頁重新整理就會立即看出結果 nodemon index.js 補充clone 別人的專案後，發現 package.json 有dependencies NPM 列表，但沒有 node_modules 資料夾時，該下什麼指令來安裝該專案的 NPM 列表？ npm install 參考：https://medium.com/az-下筆記/webpack-前端打包工具-1-前置-c9380f688c1bhttps://tw.alphacamp.co/blog/npm-node-package-managerhttps://medium.com/@hugh_Program_learning_diary_Js/javascript-進階-npm-abf96671c915]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nodejs 簡單介紹]]></title>
    <url>%2F2020%2F01%2F21%2Fnodejs-base%2F</url>
    <content type="text"><![CDATA[Node.js 簡單介紹能夠在伺服器端運行 JavaScript 的開放原始碼、跨平台 JavaScript 執行環境。用 Google 的 v8 引擎開發。 安裝到以下網站按照自己的作業系統下載，安裝 https://nodejs.org/en/download/ 要確認是否安裝成功的話，到終端機或命令提示字元下輸入 node –version看是否有顯示安裝版本。 modulemodule 是一些由 Javascript 編寫而成的功能集合, 它分別放在不同的 Javascript 檔案，可被匯入、應用。 分為三大類 1.Core Modules (原生模組)2.Local Modules (自建模組)3.Third Party Modules (第三方模組) 常用原生模組有：http：建立並使用 http server 的一些類別，方法，及事件。url：解析 url 的方法。querystring：處理由 client 端傳來 querystring 的方法。path：處理檔案或資料夾路徑的方法。fs：檔案的存取及操作的類別，方法及事件。util：提供程序者使用的效能函式。 自建模組基本上一個 Javascript 檔就是一個模組。 Code1234567let data = 2;module.exports = data; // 要載入的資料// 也可提供物件型態module.exports = &#123; a: 2; &#125; 如何載入const module = require(&#39;module_name&#39;); e.g. Code123456const http = require(&apos;http&apos;); let server = http.createServer(function(req, res)&#123; // ...&#125;); server.listen(8080); 載入其他自建模組 有兩個 js 檔，分別為 app 及 data。由 app.js 載入 data.js 的 data。 Code123456app.jsconst content = require(&apos;./data&apos;) // 載入模組同層下的 jslet a = 1;console.log(a);console.log(content); Code12345data.jslet data = 2;module.exports = data; // 要載入的資料 另一種模組呼叫方式(不能跟 module.exports 混用，module.exports 會覆寫 exports 的東西)。 Code123456app.jsvar content = require(&apos;./data&apos;) // 載入模組同層下的 jsvar a = 1;console.log(a);console.log(content); Code123456data.jsexports.data = 2;exports.bark = function() &#123; return &apos;bark!!&apos; &#125; node.js 核心模組 http 使用Code1234567const http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; // 開啟 web 伺服器 response.writeHead(200, &#123; &quot;context-Type&quot;: &quot;text/plain&quot;&#125;); response.write(&apos;hello&apos;); response.end(); console.log(request.url) // 可以撈到使用者造訪的網站的網址&#125;).listen(8080); node.js 核心模組 path 使用Code1234567891011121314const path = require(&apos;path&apos;);// 抓目錄路徑console.log(path.dirname(&apos;xx/yy/zz.js&apos;)) // xx/yy// 路徑合併console.log(path.join(__driname,’/xx’)); // 將檔案路徑跟 /xx 合併// 抓檔名console.log(path.basename(&apos;xx/yy/zz.js&apos;)); // zz.js// 抓副檔名console.log(path.extname(&apos;xx/yy/zz.js&apos;)); // .js// 分析路徑console.log(path.parse(&apos;xx/yy/zz.js&apos;)); // &#123; root: &apos;/&apos;, dir: &apos;/xx/yy&apos;, base: &apos;zz.js&apos; ext: &apos;.js&apos; name: &apos;zz&apos;&#125;__dirname // 取得當下資料夾的目錄__filename // 取得當下資料的檔名 node.js 核心模組 fs 使用非同步讀取fs.readFile(fileName [,options], callback) fileName: 檔案的完整路徑及檔名，格式字串。options: options 可能是一個物件或字串，包含”編碼”及”flag”。這裡預設的編碼是 utf8 , flag 是 “r”。可不加。call back: 是帶兩個參數的 function，err 及 file data，當我們執行 readFile 完成時, 要做的事, 例如: 回傳 file data。 e.g. test.txt Code1Hello! app.js Code123456const fs = require(&apos;fs&apos;); fs.readFile(&apos;test.txt&apos;, function (err, data) &#123; if (err) throw err; console.log(data.toString());&#125;); 同步讀取檔案Code123const fs = require(&apos;fs&apos;); let data = fs.readFileSync(&apos;test.txt&apos;, &apos;utf8&apos;);console.log(data); 寫入檔案如果檔案存在，會覆寫原本檔案資料；否則會自動新增檔案並寫入資料。 fs.writeFile(filename, data[, options], callback) fileName: 檔案的完整路徑及檔名，格式字串。data: 要寫入的檔案內容。options: options 可能是一個物件或字串，包含”編碼”及”flag”。這裡預設的編碼是 utf8 , flag是 “w”。call back: 只帶一個錯誤參數err的function，當我們執行writeFile完成時, 要做的事。例如: 寫入成功的訊息顯示；失敗時，丟出err。 Code12345678const fs = require(&apos;fs&apos;); fs.writeFile(&apos;test.txt&apos;, &apos;您好嗎?&apos;, function (err) &#123; if (err) console.log(err); else console.log(&apos;Write operation complete.&apos;);&#125;); 新增內容Code12345678const fs = require(&apos;fs&apos;); fs.appendFile(&apos;test.txt&apos;, &apos;我很好！&apos;, function (err) &#123; if (err) console.log(err); else console.log(&apos;Append operation complete.&apos;);&#125;); 開啟檔案fs.open(path, flags[, mode], callback) path: 檔案的完整路徑及檔名，格式字串。flag: 用 flag 代表操作行為。mode: mode 代表文件的權限，預設為 0666 代表可讀可寫。call back: 是帶兩個參數的function，err及file data，當我們執行open完成時, 要做的事, 例如: 打開成功的訊息顯示；失敗時，丟出err。 Code123456const fs = require(&apos;fs&apos;); fs.open(&apos;test.txt&apos;, &apos;r+&apos;, function (err,fd) &#123; if (err) throw err; console.log(&apos;success!&apos;);&#125;); 開啟時讀取fs.read(fd, buffer, offset, length, position, callback) fd: 透過 fs.open() 方法返回的文件描述符。buffer: 數據寫入的緩衝區。offset: 緩衝區寫入的寫入偏移量。length: 要從文件中讀取的字元數。position: 文件讀取的起始位置，如果 position 的值為null，則會從當前文件游標的位置讀取。callback: 回呼函式，有三個參數err, bytesRead, buffer。err 為錯誤訊息， bytesRead 表示讀取的字元數，buffer 為緩衝區對象。 Code1234567891011121314151617181920212223242526const fs = require(&apos;fs&apos;); fs.open(&apos;test.txt&apos;, &apos;r&apos;, function (err, fd) &#123; if (err) &#123; return console.error(err); &#125; let buffr = new Buffer(1024); fs.read(fd, buffr, 0, buffr.length, 0, function (err, bytes) &#123; if (err) throw err; // Print only read bytes to avoid junk. if (bytes &gt; 0) &#123; console.log(bytes+&quot; 字元被讀取&quot;); console.log(buffr.slice(0, bytes).toString()); &#125; // Close the opened file. fs.close(fd, function (err) &#123; if (err) throw err; &#125;); &#125;);&#125;); 刪除檔案fs.unlink(path, callback); path: 檔案路徑。callback: 只帶一個錯誤參數err的function，當我們執行unlink完成時, 要做的事。例如: 刪除成功的訊息顯示；失敗時，丟出err。 Code12345const fs = require(&apos;fs&apos;); fs.unlink(&apos;test.txt&apos;, function () &#123; console.log(&apos;已經刪除檔案!&apos;);&#125;); 網址規則 router 路由https://www.google.com/search?q=google&amp;oq=google&amp;aqs=chrome..69i57j0l2j69i60l3.6463j0j7&amp;sourceid=chrome&amp;ie=UTF-8 http：網路協定、https 加密協定www(子網域):根據服務不同來設定不同的。例 mail、cloud 之類。domain(主網域)：google.com路徑：/search，用「/」作為層級或不同目錄的區隔，可能包含目錄、頁面或檔案名稱?：以「?」為開頭與前面的部分分開，後面的內容稱為參數。彼此之間不具階層關係。參數(query)：q，參數之間以「&amp;」分隔，參數名稱與值之間再以「=」分開。 Web 應用框架(處理底層問題): express整合 資料庫—firebase—mongo—mysql 安裝npm initnpm install express —save 開啟 Web 伺服器建立一個 app.js 檔 Code12345678910111213141516cosnt express = require(&apos;express&apos;); // 載入模組const app = express(); // 取得功能app.get(&apos;/&apos;,function(req, res)&#123; // 首頁 //res.send(&apos;1234&apos;); res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hi!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;)&#125;)app.get(&apos;/user&apos;,function(req, res)&#123; // user 頁面 //res.send(&apos;1234&apos;); res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;2&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;)&#125;)// 監聽var port = process.env.PORT || 3000; app.listen(port); 路由設計Code123456789app.get(&apos;/user/edit-profile&apos;,function(req,res)&#123; // res.send(&apos;1234&apos;); res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;profile&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;)&#125;)app.get(&apos;/user/edit-photo&apos;,function(req,res)&#123; // res.send(&apos;1234&apos;); res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;photo&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;)&#125;) 取得指定路徑 params (物件資料)Code12345678910111213141516171819202122232425var express = require(&apos;express&apos;);var app = express();app.get(&apos;/user/:name/&apos;,function(req,res)&#123; // :name 取得 name 資料(隨機輸入) var myName = req.params.name;//app.get(&apos;/user/:name/:data&apos;,function(req,res)&#123; // 輸入 user/tom/1081024 // 回傳 &#123;name: &apos;1234&apos;, data: ’1081024&apos;&#125;//var myName = req.params; console.log(myName); if(myName !== &apos;tom&apos;)&#123; res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&apos;+&apos;查無此人&apos;+&apos;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;) // 網頁輸出 &#125;else&#123; res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&apos;+myName+&apos;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;) &#125; &#125;)app.get(&apos;/user/edit-photo&apos;,function(req,res)&#123; // res.send(&apos;1234&apos;); res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;photo&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;)&#125;)// 監聽 portvar port = process.env.PORT || 3000;app.listen(port); 參考：Node.JS - 30 天入門學習筆記系列六角學院課程]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 介紹]]></title>
    <url>%2F2020%2F01%2F16%2Fwebpack-base%2F</url>
    <content type="text"><![CDATA[webpackwebpack 在處理整個專案時，它會在內部建立一個依賴的關係圖，裡面記錄著每個頁面所需要用到的模組，並將每個模組綑綁成一個或多個來使用。簡單來說就是可以幫我們打包所有用到的 JavaScript 、SASS … 等檔案，編譯後讓瀏覽器可讀取。另一個工具 gulp 跟 webpack 的差異在一個是協助自動化，另外一個是協助前端打包的。gulp 比較偏向命令式的編寫設定，也就是說所有的編譯動作的邏輯都要自己編寫，webpack 就偏向設定。 安裝首先需要用 npm 安裝 webpack 與 webpack-dev-server, 如果你第一次裝，可以用 -g 安裝，以便在任何地方都可以使用該指令： webpack //打包工具webpack-dev-server //即時產生一個 server 看執行結果 npm install -g webpack webpack-dev-server 接著安裝指令包 npm install webpack-cli -g 專案使用1.建立專案資料夾 2.建立 NPM (參照 NPM 文件，記得移動到專案資料夾的目錄) npm init 按照資訊設定，產生 package.json 內容會像以下 Code123456789101112131415&#123; &quot;name&quot;: &quot;my-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;this is my project&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot; &quot;url&quot;: &quot;http://github.com/npm/npm.git&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 若想快速設定可用 npm init -y。設定結束後，會產生 package.json(設定紀錄檔)。 scripts 屬性可以自訂指令名稱及執行指令，設定完後，輸入 npm run 指令名稱 就可以執行了。 建議可在 package.json 加入以下 webpack-dev-server scripts Code123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --devtool eval --progress --colors --content-base build&quot; &#125;, –devtool eval: 將把 source 加到我的 code–progress 與 –colors： 反應現今程序執行狀況–content-base build： 將 build 裡的 index.html 作為啟始頁 安裝 webpack 套件在專案資料夾裡：npm install webpack webpack-cli --save-dev 3.用 NPM 安裝要使用的套件。安裝後的套件資訊，也會記錄在package.json 內。 紀錄的訊息會像是： 開發的時候會用到的套件 Code12345&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.18.0&quot; &quot;babel-eslint&quot;: &quot;^10.0.1&quot;, &quot;eslint&quot;: &quot;^5.16.0&quot;,&#125;, 上線發佈後依然需要用到的套件 Code12345&quot;dependencies&quot;: &#123; &quot;axios&quot;: &quot;^0.19.0&quot;, &quot;bootstrap&quot;: &quot;^4.3.1&quot;, &quot;jquery&quot;: &quot;^3.4.1&quot;,&#125;, package.json 可以手動加入也可自動加入。要自動加入的指令是 --save-dev ，在套件安裝時加上。 e.g.npm install webpack webpack-cli --save-dev 4.建立 webpack.config.js 檔案，用來當作 webpack 的設定檔，檔名也不能亂取。 檔案內容： Code12345678910111213const path = require(&apos;path&apos;);module.exports = &#123; //webpack打包的路徑及對象， index.js entry: &#123; index: &apos;./index.js&apos; &#125;, output: &#123; //這裡是打包後的檔案名稱 filename: &apos;bundle.js&apos;, //打包後的路徑，這裡使用 path 模組的 resolve() 取得絕對位置，也就是目前專案的根目錄 path: path.resolve(&apos;./&apos;), &#125; &#125;; 使用 loader告訴 webpack，該如何處理匯入的檔案(編譯打包)，通常是 Javascript 但 webpack 不限於處理 Javascript，其他像是 Sass，圖片等也可處理，只要提供可處理的 loader。loader 的設定會寫在 module 的 rules 中。 Code123456789101112131415module.exports = &#123; //如果有一個以上的檔案需要打包，可以傳陣列給entry entry: [&apos;./index.js&apos;, &apos;./app.jsx&apos;], output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;./&apos;), &#125;, //將loader的設定寫在module的rules屬性中 module: &#123; //rules的值是一個陣列可以存放多個loader物件 rules: [ &#123; test: /.jsx$/, exclude: /node_modules/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-react&apos;] &#125; &#125; &#125; ] &#125;&#125;; loader 物件屬性 test：指定編譯檔案的副檔名為何，用正規表達式來尋找結尾處為.jsx的檔案。 exclude：指定不編譯的路徑。 use：指定用來編譯符合副檔名條件的loader，這個物件裡面還有兩個屬性： loader：指定進行編譯的套件option：指定 loader 套件中的 presets 是什麼 其他 loader 對應：CSSCSS：style-loader、css-loaderSASS：sass-loader、node-sass 安裝：npm install --save-dev autoprefixer css-loader node-sass postcss-loader precss sass-loader style-loader 設定 Code12345678910// webpack.config.jsmodule: &#123; rules: [ &#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125; ]&#125; 使用 Code12// ./src/index.jsimport &apos;./styles/style.scss&apos; PICfile-loader、url-loader npm install --save-dev url-loader 設定 Code123456789101112131415161718192021222324252627// webpack.config.jsmodule:&#123; rules:[ // url loader (for image) &#123; test: /\.(jpe?g|png|gif|svg)$/, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 40000 /* 小於 40kB 的圖片轉成 base64 */ &#125; &#125; ] &#125; ], [ // file-loader &#123; test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ &apos;file-loader&apos; ] &#125; ]&#125; 使用 Code123456789101112131415// ./src/image-viewer.jsimport midImgUrl from &apos;./../assets/mid.jpeg&apos;import minImgUrl from &apos;./../assets/min.jpeg&apos;// midImg 會是被壓縮過的檔案名稱const midImg = document.createElement(&apos;img&apos;)midImg.src = midImgUrldocument.body.appendChild(midImg)// minImg 是被注入在 bundle.js 中，可以直接使用const minImg = document.createElement(&apos;img&apos;)minImg.src = minImgUrldocument.body.appendChild(minImg)export &#123;midImg, minImg&#125; ES6 轉譯 ES5babel-loader、babel-core、babel-preset-env npm install --save-dev @babel/core @babel/preset-env @babel/preset-react babel-loader 設定 Code12345678910111213141516171819202122232425262728// webpack.config.jsmodule: &#123; rules: [ // babel-loader &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [ [ &apos;@babel/preset-env&apos;, &#123; useBuiltIns: &apos;entry&apos;, // targets: &quot;&gt; 0.25%, not dead&quot; targets: &#123; chrome: &apos;69&apos; &#125; &#125; ] ] // End of presets &#125; // End of options &#125; &#125; // End of Babel ];&#125; 開啟本機伺服器在 webpack.config.js 中增加 devserver 的一些設定，例如要開啟的 port，如果沒有特別設定的話，port 的預設值為 8080，以下為了區隔所以設定 9000 Code123456789101112131415161718192021const path = require(&apos;path&apos;);module.exports = &#123; entry: [&apos;./index.js&apos;, &apos;./app.jsx&apos;], output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;./&apos;), &#125;, //將loader的設定寫在module的rules屬性中 module: &#123; //rules的值是一個陣列可以存放多個loader物件 rules: [ &#123; test: /.jsx$/, exclude: /node_modules/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-react&apos;, &apos;@babel/preset-env&apos;] &#125; &#125; &#125;, &#123; test: /.js$/, exclude: /node_modules/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-env&apos;] &#125; &#125; &#125; ] &#125;, //增加一個給devserver的設定 devServer: &#123; //指定開啟port為9000 port: 9000 &#125;&#125;; Plugin透過 clean-webpack-plugin 可以每次打包前都清除特定資料夾。 安裝 $ npm install clean-webpack-plugin --save-dev Code123456789101112// webpack.config.jsconst path = require(&apos;path&apos;)const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new CleanWebpackPlugin([&apos;dist&apos;]), // ... ]&#125; 指令(命令提示字元下 or 終端機輸入)看版本webpack -v 打包webpack -p or npm run start 開啟本機伺服器webpack-dev-server 執行完後，打開瀏覽器輸入 http://localhost:9000 ，關閉 webpack-dev-server 開啟的 port，在命令提示字元的畫面上輸入 Ctrl+C。 參考：https://webpack.js.org/concepts/#entryhttps://ithelp.ithome.com.tw/articles/10200329https://ithelp.ithome.com.tw/articles/10200459?sc=ptWebpack 學習筆記（Webpack Note）]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 簡單介紹]]></title>
    <url>%2F2020%2F01%2F16%2FjQuery-base%2F</url>
    <content type="text"><![CDATA[jQuery 簡單介紹JavaScript 的 Library，jQuery 主要是用在 DOM 文件操作，包含快速選取元素(Element)與執行事件，例如隱藏元素、顯示元素等等。此外 jQuery 的核心程式還加強了非同步傳輸(AJAX)以及事件(Event)的功能。 使用 jQueryjQuery 用 $(selector).action() 格式，指派元素到指定的事件。詳細來說， $(selector) 會呼叫 jQuery 選取 selector 元素，並指派它到稱作 .action() 事件。回傳值是 Array。可以直接用 for 或是 foreach 迴圈去處理。 e.g. $(&quot;div&quot;).addClass(&quot;special&quot;); 範例是將先前所選取到的 &lt;div&gt; 元素都加上一個名為 “special” 的 class。 記號 $ 是被當成 jQuery 的縮寫。等同， jQuery(&quot;div&quot;).addClass(&quot;special&quot;); 另一個例子 Code123456$(document).ready(function()&#123; // 等所有的 HTML 都載入，且 DOM 都以建構完成執行 &#123; &#125; 內容，將所有 function(); // 放入裡面是常見做法 alert(&quot;Hello World!&quot;); $(&quot;#blackBox&quot;).hide();&#125;); 上面這段 jQuery 程式碼，會執行與這段原生 JavaScript 程式碼相同的事情： Code1234window.onload = function() &#123; alert( &quot;Hello World!&quot; ); document.getElementById(&quot;blackBox&quot;).style.display = &quot;none&quot;;&#125;; 選取元素選取所有 &lt;div&gt; 元素$(&quot;div&quot;) 選取 id 為 menu 的元素$(&quot;#menu&quot;) 選取 class 為 content 的元素$(&quot;.content&quot;) 選取 id 為 body 的 &lt;div&gt;$(&quot;div#body&quot;) 選取 class 為 content 的 &lt;div&gt; 所包住的所有內層的 &lt;p&gt;$(&quot;div.content p&quot;) 取得第index個子節點: eq(index)$(&#39;ul&#39;).children.eq(3).text(); //取得第三個子節點 利用屬性內容找節點$(&quot;input[name=&#39;A&#39;]&quot;); //找出 name 屬性為 ‘A’ 的 input 操作元素讀取和修改一個元素的HTML內容: html()若是多個元素，只能讀取第一個元素的內容 讀取 &lt;p&gt; 元素的內容 $(&quot;p&quot;).html(); 修改 &lt;p&gt; 元素的內容 $(&quot;p&quot;).html(&quot;Hello &lt;b&gt;world&lt;/b&gt;!&quot;); 讀取和修改一個元素的純文本內容: text()讀取 Element 的文本內容 $(&quot;Element&quot;).text(); 修改 Element 的文本內容，Element 的 content 是 Hello &lt;b&gt;world&lt;/b&gt;! 是文字格式，不是標籤元素 $(&quot;Element&quot;).text(&quot;Hello &lt;b&gt;world&lt;/b&gt;!&quot;); 讀取和修改一個表單元素的 value 值: val()若是多個元素，只能讀取第一個元素的內容。要使用 for 或 each 來讀取多個。 讀取 Code12345// 讀取每一個被 checked 的值$(&apos;input:checkbox[name=size]:checked&apos;).each(function() &#123; alert($(this).val()); &#125;); 修改 $(&quot;Element&quot;).val(value); 元素節點末端加入純文字或 HTML 語法(增加元素): appendCode12// 選取所有有 target 屬性的 `&lt;a&gt;`，並且在其節點下加入一段文字。$(&quot;a[target]&quot;).append(&quot;(Opens in New Window)&quot;); 元素節點前端加上純文字或 HTML 語法(增加元素): prepend()$(div).prepend(&quot;first&quot;); 修改 css 屬性: css.css(&#39;border&#39;,&#39;3px solid red&#39;) or Code1234$(&quot;#body&quot;).css(&#123; border: &quot;1px solid green&quot;, height: &quot;40px&quot; &#125;); class的新增: addClass()$(&quot;#test&quot;).addClass(&quot;aaa&quot;); class的移除: removeClass()$(&quot;#test&quot;).removeClass(&quot;aaa&quot;); 移除多個 $(&quot;#test&quot;).removeClass(&quot;aaa bbb&quot;); 事件事件寫法有兩種 $(selector).click(function(){}) or $(selector).on(&#39;click&#39;, function(){}) or // 動態綁定$(selector).on(&#39;click&#39;, selector, function(){ }) ps. 補充有說明兩種的不同 點選元素: clickCode1234567891011121314151617//當 user 點選 id 為 open 的連結時，顯示 id 為 menu 的區塊，並回傳 false 避免瀏覽器真的換頁。$(&quot;a#open&quot;).click(function() &#123; $(&quot;#menu&quot;).show(); return false; &#125;);html&lt;style type=&quot;text/css&quot;&gt; #menu &#123;display: none&#125; &lt;/style&gt; &lt;a id=&quot;open&quot; href=&quot;#&quot;&gt;menu&lt;/a&gt; &lt;ul id=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;a&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;b&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;c&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 失焦並且內容改變: change() 聚焦: focus()Code123$(&quot;input&quot;).focus(function()&#123; $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;#FFFFCC&quot;);&#125;); 失焦(滑鼠游標移開): blur()Code123$(&quot;input&quot;).blur(function()&#123; $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;#D6D6FF&quot;);&#125;); 加上鍵值: keyup()Code1234567(&apos;#target&apos;).keyup(function(event) &#123;if (event.keyCode == &apos;13&apos;) &#123; event.preventDefault(); ... &#125; ...&#125;) 表單送出: submitCode12345678910111213141516//在網頁上的表單送出時加入一個判斷，如果 username 這個欄位是空值的話，就顯示 help 這個區塊內的文字。$(&quot;form&quot;).submit(function() &#123; if ($(&quot;input#username&quot;).val() == &quot;&quot;) $(&quot;span.help&quot;).show(); &#125;);html&lt;style type=&quot;text/css&quot;&gt; .help &#123;display: none&#125; &lt;/style&gt; &lt;form&gt; &lt;label for=&quot;username&quot;&gt;請輸入姓名&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt; &lt;span class=&quot;help&quot;&gt;此欄位為必填&lt;/span&gt; &lt;/form&gt; 布幕動態效果: slideDownCode123456789101112$(&quot;#menu&quot;).slideDown(&quot;fast&quot;);html&lt;style type=&quot;text/css&quot;&gt; #menu &#123;display: none&#125; &lt;/style&gt; &lt;ul id=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;a&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;b&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;c&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; animate 函數Code1234567891011//將所有的 &lt;div&gt; 漸變為寬 300px、文字與邊界寬 20px$(&quot;div&quot;).animate(&#123; width: &apos;300px&apos;, padding: &apos;20px&apos; &#125;, &apos;slow&apos;); HTML&lt;div style=&quot;width: 100px; border: solid 1px red;&quot;&gt; Hello world! &lt;/div&gt; 顯示: show()$(&#39;.target&#39;).show(); //顯示target 隱藏: hide()Code1234567891011121314/*所有的 &lt;div&gt; 以 0.5 秒的動態效果隱藏後，再以 0.5 秒的動態效果顯示。hide() 的第二個參數就是一個 callback 函數，其中 $(this) 是原本程式所處理的各個元素。*/$(&quot;div&quot;).hide(500, function()&#123; // $(this) 是每一個別的 &lt;div&gt; $(this).show(500); &#125;); HTML&lt;div style=&quot;width: 100px; border: solid 1px red;&quot;&gt; Hello world! &lt;/div&gt; &lt;div style=&quot;width: 100px; border: solid 1px red;&quot;&gt; jsGears.com! &lt;/div&gt; 切換: toggle()toggle() 方法用於綁定兩個或多個事件處理器函式，以響應被選元素的輪流的 click 事件。該方法也可用於切換被選元素的 hide() 與 show() 方法。 Code123456789// 切換背景色$(&quot;p&quot;).toggle( function()&#123; $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;green&quot;);&#125;, function()&#123; $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;red&quot;);&#125;, function()&#123; $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);&#125;); Code12345678910111213// 按下 Hello 元素第一次會文字會是綠，第二次會是藍色$(&apos;#mydiv&apos;).toggle( function()&#123; $(this).css(&#123;&quot;color&quot;: &quot;green&quot;&#125;); &#125;, function()&#123; $(this).css(&#123;&quot;color&quot;: &quot;blue&quot;&#125;); &#125;,);html &lt;div id=&quot;mydiv&quot;&gt;Hello&lt;/div&gt; AjaxajaxCode12345678$.ajax(&#123;type: &quot;GET&quot;, //指定method url: &apos;ajax/test.html&apos;, success: function(data) &#123; $(&apos;.result&apos;).html(data); alert(&apos;Load was performed.&apos;); &#125;&#125;); 取得 HTML: load()$(&quot;#htmDoc&quot;).load(&quot;test.html&quot;); 取得 XML 格式的資料Code1234$.get(&quot;test.xml&quot;,function(xml)&#123;var text = $(&quot;title&quot;,xml).text();$(&quot;#xmlDoc&quot;).html(text);&#125;); 取得 TXT 格式的資料Code123$.get(&quot;test.txt&quot;,function(txt)&#123;alert(txt);&#125;); 取得 JSON 格式的資料: getJSON()Code123456789101112131415161718$.getJSON(&quot;test.json&quot;, function(data)&#123; for (var idx in data) $(&quot;#menu&quot;).append(&quot;&lt;li&gt;&quot; + data[idx] + &quot;&lt;/li&gt;&quot;); &#125;); HTML&lt;ul id=&quot;menu&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;/ul&gt; test.json[ &quot;Hello world!&quot;, &quot;jsGears.com!&quot; ] 連續使用函數如果想將所有的 &lt;div&gt; 隱藏，並修改文字顏色，再用布幕動態效果顯示出來的話，可用下方程式碼處理： Code123$(&quot;div&quot;).hide(); $(&quot;div&quot;).css(&quot;color&quot;, &quot;green&quot;); $(&quot;div&quot;).slideDown(); 上方三行程式碼可簡化成 $(&quot;div&quot;).hide().css(&quot;color&quot;, &quot;blue&quot;).slideDown(); 另一個範例： 選取第三個 &lt;li&gt; 加上 5px 的紅色邊框，並在 &lt;li&gt; 裡面加上文字 A$(&#39;li:nth-child(3)&#39;).css(&#39;border&#39;,&#39;5px solid red&#39;).append(&#39;A&#39;); jQuery plugin 應用 下載 jQuery 的 js 和要使用的 plugin 打開 HTML 檔，在 &lt;header&gt; 加上 &lt;link&gt;，分別為套件的 *.css 與自己的 *.css 檔 e.g. &lt;link rel=&quot;stylesheet&quot; href=&quot;css/flexslider.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&gt; 在 body 加上官網上給的使用語法 在 &lt;/body&gt; 之前 加上 jquery.min.js、套件的*.js檔與套件使用的 js 語法。 e.g. &lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.slim.min.js&quot; integrity=&quot;sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; 依照套件的教學及範例，基本上就可以使用了。 document ready 事件有時，在網頁下載完成後，要立即執行一些程式的話。可以用 window.onload 來處理，或是直接在 &lt;body&gt; 標籤上加入 onload 的事件處理函式。 jQuery 提供了 .ready() 來處理這類情況。 e.g. Code1234// 網頁下載完成後立即執行 alert()$(document).ready(function() &#123; alert(&apos;Hello&apos;); &#125;); jQuery 的 document ready 事件是模擬 W3C DOM 標準的 DOMContentLoaded 事件，DOMContentLoaded 和 window.onlad 的差異在於前者是在 DOM 文件下載完成後觸發，而後者是文件和所有文件內的元件，包含圖檔等等全部下載完成後才會觸發。因此通常 window.onload 的發生時間要比 DOMContentLoaded 晚一點。 而 DOMContentLoaded 和 window.onload 的另一個差異在於 window.onload 並沒有辦法多次指定不同的函數來執行，最後指定的那個函數會複寫掉先前的。但 jQuery 的 document ready 函數並不會有覆寫的情況發生。 document ready 函數也有更精簡的寫法，如下： Code123$(document).ready(function() &#123; alert(&apos;Hello&apos;); &#125;); 可改寫成 Code123$(function() &#123; alert(&apos;Hello&apos;); &#125;); 別名jQuery 本身提供一個函式來避免 $() 的衝突，使用 jQuery 函式前，加上 jQuery.noConflict(); Code1234jQuery.noConflict();$(document).ready(function() &#123; alert(&apos;Hello&apos;); &#125;); 或是另外設定名稱 Code1234const $j = jQuery.noConflict();$j(document).ready(function() &#123; alert(&apos;Hello&apos;); &#125;); 補充.click(function()) 及.on(‘clcik’,function())，這兩者間到底有什麼不一樣？Code12345&lt;ul&gt; &lt;li&gt;&lt;span&gt;click me&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;click me&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;click me&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; .click(function())若是使用$(&#39;li span&#39;).click(function(){alert(&#39;hi&#39;)});的話，它只對於你現在 HTML 上所指定的全部元素進行事件綁定，如果你在後來透過 jQuery 或其他方式所增加的元素都不會出現在這個事件所綁定的範圍裡，所以 .click 是沒有辦法幫助你做到動態的事件綁定。 .on基本上 .click 能做到的事情，透過.on(‘click’)的方式一樣都能做到，但是 .on() 能做到動態事件綁定，以上述的例子而言，我們可能會寫 $(&#39;li span&#39;).on(&#39;click&#39;,function(){alert(&#39;hi&#39;)});這時你會發現，在動態事件這種方式會跟上述的.click事件處理方式一樣沒反應，那到底 .on() 要怎麼做到動態事件綁定？.on()方法有提供第二個參數「childSelector」$(&#39;li&#39;).on(&#39;click&#39;,&#39;span&#39;,function(){alert(&#39;hi&#39;)}); childSelector 的原理就是事件冒泡 event bubbling ，在你點擊子元素 span 時，子元素 span 一樣是在父元素 li 裡面，所以你樣是有點擊到父元素 li，而事件的傳遞會從子元素先發生接著向父元素傳遞，但是實際上我們這邊事件一樣是綁定在父元素 li 上，所以它會再去而找到相對應的子元素，來進行事件處理。這兩者間最大的差異，大概就在動態事件處理上，當然還有像是一些小差異像是 .on() 所佔用的記憶體會比.click還少.on() 為Namespaced Events，可以做到事件命名的管理。 一般來說，如果不會用到 append … 等這些插入元件控制用的語法。使用第三個程式寫法就行了，不需要用到 on 處理。在某些情況下，on 最好還是少用。不得已非要用到的情況才去使用它會比較好。 blur 事件會觸發兩次jQuery 解決使用 blur 事件時，會觸發兩次的問題 (好像用 focus 事件也會)。因為在綁定 onblur 事件的時候都會被觸發兩次，原因不明…..網路上有找到解法，但好像不是用 on 來綁，是用一般的 blur(無法動態綁定)，若是 dom 都是動態產生的，這個沒法用。 可用此方式試試 e.g. $(&#39;#gradeUpdate&#39;).blur() 改成這樣就可以了 $(&#39;#gradeUpdate&#39;)[0].blur() 參考：https://jquery.com/https://www.j2h.tw/bbs/bbs16/511.htmlhttps://developer.mozilla.org/zh-TW/docs/Glossary/jQueryhttps://ithelp.ithome.com.tw/articles/10197512http://greenkm.blogspot.com/2016/03/jquery_8.htmlhttps://jjnnykimo.pixnet.net/blog/post/21585448https://felixx.pixnet.net/blog/post/36966403http://shioulo.eu5.org/node/256https://sweeteason.pixnet.net/blog/post/42677633-jquery-%E8%A7%A3%E6%B1%BA%E4%BD%BF%E7%94%A8-blur-%E4%BA%8B%E4%BB%B6%E6%99%82%EF%BC%8C%E6%9C%83%E8%A7%B8%E7%99%BC%E5%85%A9%E6%AC%A1%E7%9A%84%E5%95%8Fhttp://skaih.logdown.com/posts/712464-jquery-click-on-the-where-differenthttps://ithelp.ithome.com.tw/questions/10191601https://www.w3cplus.com/blog/134.html]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass 基本介紹]]></title>
    <url>%2F2020%2F01%2F16%2FSass-base%2F</url>
    <content type="text"><![CDATA[SassSass(Syntactically Awesome StyleSheets) 是種 CSS 的擴充，經過編譯(compiled) 成 CSS 檔，讓瀏覽器可讀取。解決了專案 CSS 遇到的重複、可維護性差等問題。bootstrap 也有使用 Sass。 格式寫法 SCSS用大括號跟分號來區分段落，多數人使用，與 CSS 語法相近。 e.g. Code1234567891011121314151617181920&lt;ul class=menu&gt; &lt;li&gt;&lt;a href=&apos;#&apos;&gt;1234&lt;/a&gt;&lt;/li&gt;.menu &#123; li &#123; font-size: 30px; a &#123; color: red; &#125; &#125; &#125;compiler:.menu li &#123; font-size: 30px;&#125;.menu li a &#123; color: red;&#125; SASS使用排縮跟斷行來區分。 e.g. Code12345678&lt;ul class=menu&gt; &lt;li&gt;&lt;a href=&apos;#&apos;&gt;1234&lt;/a&gt;&lt;/li&gt;.menu li font-size: 30px a color: red Sass 轉成 CSS 方式(透過編譯)編譯順序是從上到下 軟體編譯 https://sass-lang.com/install 安裝 Sass Prepros：免再安裝其它軟體即可編譯 Jade/SASS1.下載：https://prepros.io2.安裝好之後就拖曳網站資料夾(根目錄)到 prepros 拖曳後產生兩個欄位，左邊是網站資料夾，右邊是 檔案清單、Log、FTP、軟體設置，最重要的就是 Log，他會顯示SASS紀錄，當SASS無法轉成CSS時，他會有紀錄，方便看程式是否哪邊有問題?3.而且他會在資料夾產生一個 prepros-6.config，如後續沒有要用到 SASS，網站完成後可以刪掉，如果要再用 SASS 輸出成 CSS 要再重新拖曳檔案到 prepros 讓他讀取該資料夾繼續編譯 SASS。4.新增 Scss 和 css 資料夾：開始寫 SCSS 之前，先在網站資料夾新增 Scss 和 CSS 資料夾，SCSS檔案存在同名資料夾，SCSS 檔案儲存時，電腦桌面會出現編譯成功的小視窗，CSS 資料夾會出現一個 CSS的檔案。 打包：gulp / webpack編輯器內建插件編譯VSCode 套件：Live Sass compiler 在 vscode 安裝 Live Sass compiler 插件。 產生專案資料夾，在專案資料夾內新增 Scss 資料夾。新增一個 all.scss 文件。程式視窗下方，會啟用 Live Sass compiler 程式。有 Watch Sass 字樣。寫完 Scss 後，點擊 Watch Sass 字樣，會產生 all.css 跟 all.css.map 至預設的資料夾內，且每一次儲存檔案都會自動編譯一次。想要停止即時編譯的狀態，點擊視窗下方的「Watching…」即可停止。 預設的情況編譯產生的 CSS 將會被放置在與 SCSS 檔案同層的資料夾內，要指定 CSS 輸出路徑或輸出形式，可依照以下的步驟來設定。 指定輸出CSS的路徑於檔案總管內另外新增一層名為 css 的資料夾，接著進入 VSCode 的喜好設定 -&gt; 設定，可直接將以下的程式碼複製並貼到區塊存檔： Code12345&quot;liveSassCompile.settings.formats&quot;:[ &#123;&quot;savePath&quot;: &quot;/css&quot; &#125; ] LiveSassCompile.settings.formats：可用於調整 Live Sass Compiler 外掛相關的屬性設定。savePath：輸出後的 CSS 檔存放資料夾。 更改輸出樣式Live Sass Compiler 支援以下四種輸出樣式： expanded(預設) compact compressed (去除檔案所有空格及縮排) // 常見 nested將以下的程式碼貼入設定檔，並存檔。 Code12345678&#123; &quot;liveSassCompile.settings.formats&quot;:[ &#123; &quot;format&quot;: &quot;compressed&quot;, &quot;savePath&quot;: &quot;/css&quot; &#125; ]&#125; Sass 使用巢狀(nesting)透過巢狀式的結構也可以清楚的知道元素上下層的關聯性。 e.g. Code12345678910.box&#123; width: 100%; margin: 0 auto; .title&#123; padding: 10px; p&#123; color: rgba(255, 0, 0, 1);; &#125; &#125;&#125; 編譯成 CSS 就會變成 Code12345678910.box&#123; width: 100%; margin: 0 auto;&#125;.box .title&#123; padding: 10px;&#125;.box .title p&#123; color: rgba(255, 0, 0, 1);;&#125; 還有一個方便的功能是使用 &amp; 符號來代替父層(上層) Code123456.box&#123; color: rgba(0, 0, 0, 1); &amp;:hover&#123; color: red; &#125;&#125; 編譯後 Code123456.box&#123; color: rgba(0, 0, 0, 1);&#125;.box:hover&#123; color: rgba(255, 0, 0, 1);&#125; 變數(Variable)$ 來表示變數，變數可以用來儲存值，方便重複利用。時常需要設定的 CSS 可設為變數。 $變數名: 樣式; e.g. Code12345$box-shadow: 10px 10px 5px rgba(0, 0, 0, 1);.box&#123; box-shadow: $box-shadow;&#125; 變數也能拿來做運算，格式有 數字：10、1px、3em字串：’test’、”../images/big/“顏色：red、#000000、rgba(255,255,255,0.9)布林：true、false空值：null Code1234$num:5px;.container&#123; margin:$num*2 $num;&#125; 集合變數 Code12345678910$themes: ( //key, value &apos;primary&apos;: blue; &apos;danger&apos;: red; &apos;secondary&apos;: orange;);.box-primary &#123; background-color: map-get($themes, &apos;primary&apos;); &#125; 混合(mixin)函式可以使用在重複多行的樣式上面，像是 CSS 的一些新屬性就可能需要加上瀏覽器前綴，這個部分就可以透過函式來完成，要特別注意的是：@mixin需要配合 @include 來使用@mixin來設定要使用的樣式、@include則是套用樣式 Code12345678910@mixin css3-border-radius() &#123; -ms-border-radius: 5px; -moz-border-radius: 5px; -webkit-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; &#125;.box &#123;@include css3-border-radius();&#125; 編譯後 Code1234567.box &#123; -ms-border-radius: 5px; -moz-border-radius: 5px; -webkit-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125; 函式也可以搭配參數使用讓使用上更加靈活。 Code12345678910@mixin css3-border-radius($i) &#123; -ms-border-radius: $i; -moz-border-radius: $i; -webkit-border-radius: $i; -o-border-radius: $i; border-radius: $i; &#125;.box &#123;@include css3-border-radius(3px);&#125; 導入(import)在檔案中加入其他SCSS或CSS檔案，最後編譯時會一併編譯。假如我想在某個SCSS檔案裡面匯入 head、main、footer 等 SCSS 的檔案就可以使用下面這段程式碼 @import &quot;head.scss&quot;;@import &quot;main.scss&quot;;@import &quot;footer.scss&quot;; 繼承(Extend)@extend 主要是用在合併相同程式碼，假如有很多段相同的程式碼就可以使用 @extend 進行合併，只要加上站位符號 % 就能讓被繼承的 CSS 類消失。 Code123456789101112131415%box &#123; border: 1px solid rgba(0, 0, 0, 1); padding: 10px; color: rgba(0, 0, 0, 1);&#125;.success &#123; @extend %box; border-color: rbga(0, 128, 0, 1);&#125;.danger &#123; @extend %box; border-color: rgba(255, 0, 0, 1);&#125; 編譯後 Code12345678910111213.success, .danger&#123; border: 1px solid black; padding: 10px; color: black;&#125;.success&#123; border-color: rgba(0, 128, 0, 1);&#125;.danger&#123; border-color: rgba(255, 0, 0, 1);&#125; 函式(Functions)SCSS 中也有 @function 可以使用，像是 @if、@for，可以查看內建函式的清單 Code12345678910.box &#123; background-color: $i; &#125;&#125;@for $i from 1 through 5 &#123; // 包含 5 有 1-5 .box-#($i) &#123; background-color: $i; &#125;&#125; @for@for $i from 1 to 5{}@for $i from 1 through 5{} 先用 @for 啟用此功能，再來用 $ 設立一個變數i(可自訂但通常慣用 i )，再來 from 1 to 5 的意思是，$i 這個變數，從 1 開始逐步替換到 4(不包含 5 )，若要需要包含 5，用 through，所以就會寫成 @for $i from 1 through 5{}，這樣才 $i 才是從 1逐步的替換到 5，然後在 @for 最後面的大括弧內寫上要替換的對象(選擇器)以及條件(語法)，如下： Code12345@for $i from 1 through 5&#123; .box#&#123;$i&#125;&#123; background:darken(red,$i*5%); &#125;&#125; 假設這個簡單的案例是有五個 .box，從 .box1 ~ .box5，然後分別用 darken 來加深他們的 background 顏色，首先先在 .box 後面緊接著 #{$i}，讓他變成 .box#{$i}，變數 $i一定要先用 {} 包起來，然後在前面再加一個 # 字，這樣 .box 就會被逐步的迭代成 .box1、.box2到 .box5 了。 一個簡單的 @for 就可以一次給五個 class 效果，接著看後面的 background，我們給它的值是利用 darken 功能，再來後面接條件 (red,$i*5%)，寫成background:darken(red,$i*5%);，利用 @for 的迭代功能，就可以把 background 分別改成 darken(red,$5%、10%、15%、20%、25%);。 @each迭代變數內容 e.g. Code1234567$list: (orange, purple, melon);@each $item in $list &#123;.#&#123;$item&#125; &#123; background: $item; &#125;&#125; Code12345@each $key, $value in $themes &#123; .box-#($key) &#123; background-color: $value; &#125;&#125; 註解(Comment)只要在程式碼開頭加上兩條斜線 // 就可以加入註解。 @mixin 整理 CSS 應用將 CSS 功能寫成 @mixin 再 @include 到使用該功能的標籤元素。 e.g. 圖片取代文字Code12345@mixin hide-text&#123; text-indent: 110%; white-space: nowrap; overflow:hidden; &#125; 用 CSS 畫各方向的三角形用 CSS 畫圓Code1234567891011@mixin circle($size,$bgcolor) &#123; border-radiu: 50%; height: $size; width: $size; font-size: $size/3; background: $bgcolor;&#125;.box &#123; @include circle(30px,#fff)&#125; @mixin + import 應用CSS 分類、整合_variable.SCSS //變數整理_reset.SCSS //樣式清空，bootstrap 用 normalize.css(會保有瀏覽器預設樣式)_mixin.SCSS CSS 功能_main.SCSS 合成 all.scss (內容 @import 上述 .SCSS 檔) Code12345@import &quot;variable&quot;;@import &quot;normalize&quot;;@import &quot;mixin&quot;; //or @import &quot;mixin/mixin&quot;;// 主要CSS@import &quot;main&quot;; @mixin + RWD響應式處理 @media RWD @mixin + content Code12345678910111213141516171819202122232425262728293031323334353637@mixin desktop-below&#123; @media (max-width: 1023px)&#123; @content &#125;&#125;@mixin pad&#123; @media (max-width: 768px)&#123; @content &#125;&#125;.header &#123; width: 500px; @include pad&#123; width: 13px; // pad&#123;content 內容)&#125; font-size: 20px; &#125;;&#125;@mixin mobile&#123; @media (max-width: 568px)&#123; @content &#125;&#125;.header &#123; width: 500px; @include pad&#123; width: 13px; // pad&#123;content 內容)&#125; font-size: 20px; &#125;; @include mobile&#123; font-size: 8px; &#125;;&#125; SASS 設計模式簡單介紹SMACSS結構分類：Base、Layout、Module、State、Theme。命名規則：id 與 class 受限制地使用、名稱使用 dash 分隔。結構的分類存在模糊界線。 OOCSSObject Oriented CSS，範例是 Bootstrap。 結構(header)與樣式(header-shadow)分離 Code123456789101112html&lt;div class=&quot;header header-shadow&quot;&gt;&lt;/div&gt;css.header &#123; width: 200px; height: 100px;&#125;.header-shadow &#123; box-shadow: 10px 10px 10px #000;&#125; Code1&lt;button class=&quot;pure-button pure-button-primary&quot;&gt;btn&lt;/button&gt; 容器與內容分離 BEM由 Yandex 團隊提出來命名 Class 名稱的設計模式，BEM 的意思是區塊(Block)、元素(Element)、修飾符(Modifier)。以元件觀念進行開發，具有重用性。 Code1234&lt;ul class=&quot;menu&quot;&gt; &lt;li class=&quot;item active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 變成 Code123456&lt;div class=&quot;product&quot;&gt; &lt;div class=&quot;menu&quot;&gt; &lt;li class=&quot;menu__item menu__item--active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;menu__item&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/div&gt;&lt;/div&gt; .block{} //區塊 (Block).block__element{} //元素(Element).block--modifier{} //修飾符(Modifier) 區塊 (Block)我們在設計網站時，一定會設計幾個區塊(Block)出來，如下圖表頭裡面有 LOGO 、選單、搜尋框、登入視窗等等，這樣才能方便移動整個區塊到對應位置，這時候我們就會用 class 命名他們區塊對應的語意，例如.menu、.logo、.search、.auth。 元素 (Element)再來我們深入 menu 的區塊，你可以看到下圖選單內有四個元素，如果這些元素設定是會綁定在這個區塊上時，就可以在區塊的 class 後面加上雙下底線 __ 來辨識他是該區塊底下的元素，class 就會設計為 .menu__item{}。PS：除了HTML tag外，如果是一個 CSS 組件也可把它視為元素 (Element) 。 修飾符（Modifier）修飾符（Modifier）的觀念和 SMACSS 的 State Rules 很相似。當區塊或元素因為狀態而改變時，就在後面加上雙中線–來辨識它是修飾符，像是下圖選單的部份，當被點選時為了要讓使用者了解該元素有被點選，所以就會用 javascript 動態加入 class 為 .menu__item--active，所以如果我們要判斷這個 class 是屬於元素還是修飾符的設定，就只要看 class 最後面是雙中線 -- 還是雙下底線 __ 就知道他是屬於哪一種了。 BEM + SassCode1234567891011121314.list&#123;&#125;.list__title&#123;&#125;.list__img&#123;&#125;.list__img—changebg&#123;&#125;.list &#123; &amp;__title &#123; &#125; &amp;__img &#123; height: 50px; &amp;—changing &#123; &#125; &#125; CSS 命名.bookList { } 比較好懂.bookList-title { } //bookList 下的 title.bookList_title { } //跟 .bookList-title {} 一樣，保持一致就好。 拋棄語意命名方式，改以工具性質來命名。容易重複利用.list{}.list_title{}顏色，不要直接用顏色來命名.textcolor {color: green;}利用格線系統來命名.col_3 {} ps.Sass的檔名如果在最前面加上 _ 就不會被轉譯工具輸出成CSS檔案(例如：_base.scss)，可用時單純匯入、整合 Sass 檔 reset.csshttps://meyerweb.com/eric/tools/css/reset/CSS 前掛上這一段「Reset CSS」的語法，樣式會全部清空，處理各大瀏覽器的差異。用 @import 來引用 reset.css。 normalize.css 會保有瀏覽器預設樣式。 參考：https://blog.techbridge.cc/2017/06/30/sass-scss-tutorial-introduction/https://ithelp.ithome.com.tw/articles/10132821https://ithelp.ithome.com.tw/articles/10203396?sc=iThelpRhttps://medium.com/@enshenghuang/%E4%BD%BF%E7%94%A8vscode%E5%A4%96%E6%8E%9B%E8%87%AA%E5%8B%95%E7%B7%A8%E8%AD%AFsass-scss-9ff768d23b48https://www.hexschool.com/courses/sass.htmlhttps://cythilya.github.io/2018/06/05/css-methodologies/https://cythilya.github.io/2018/05/22/bem/]]></content>
      <categories>
        <category>Sass</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>Sass</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 基本介紹]]></title>
    <url>%2F2020%2F01%2F15%2FHTML-base%2F</url>
    <content type="text"><![CDATA[HTML 基本介紹超文本標記語言（英語：HyperText Markup Language，簡稱：HTML）是一種用於建立網頁的標準標記語言。HTML是一種基礎技術，常與CSS、JavaScript一起被眾多網站用於設計網頁、網頁應用程式以及行動應用程式的使用者介面[3]。網頁瀏覽器可以讀取HTML檔案，並將其彩現成視覺化網頁。HTML描述了一個網站的結構語意隨著線索的呈現，使之成為一種標記語言而非程式語言。目前已經到了 5.0 版。標籤元素使用標籤元素來呈現網頁內容，通常為 “區塊級” 或是 “行內”。瀏覽器預設以在元素前後換行(另起一行)的方式，表現區塊級元素。視覺上會呈現為一排縱向堆疊的方塊。行內元素是與鄰近元素保持在同一行。 元素組成可以加入屬性及屬性值，可以同時有多種屬性及值，每個標籤都可以有 id 及 class 屬性。 id=”名稱”：識別單一元素用，可利用 id 來跟特定元素互動，名稱不能相同。class=”名稱”：識別同類別元素，可利用 class 來跟同類別元素互動，多元素可以同一個 class 類別。 屬性也可以自訂，使用方式為 date-* 。 e.g. data-timezone=&quot;Europe/London&quot; 利用 getAttribute 方法可取出值。 let timezone = tz.getAttribute(&#39;data-timezone&#39;); 標籤種類網頁頁面資訊版本宣告(HTML5)&lt;!DOCTPYE html&gt; 網頁語系&lt;html lang=&quot;en&quot;&gt; 網頁資訊&lt;head&gt;&lt;/head&gt; 裡面通常包含 &lt;meta&gt; &lt;meta&gt; 提供網頁內容資訊給瀏覽器或搜尋引擎通常有以下屬性： 用來寫網頁的簡短描述 name=&quot;description&quot; content=&quot;網頁簡短描述&quot; 放置網頁關鍵字 name=&quot;keywords&quot; content=&quot;網頁關鍵字&quot; 內容種類及編碼 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html&quot;; charset=&quot;uft-8″&gt; 使用語言 &lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-TW&quot;&gt; 自動更新時間 &lt;meta http-equiv=&quot;Refresh&quot; content=&quot;time&quot;&gt; 避免瀏覽器儲存快取 &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no cache&quot;&gt; 瀏覽器頂端或該頁面標題列&lt;title&gt;&lt;/title&gt; 連結外部資源&lt;link&gt;ps. 一般有 rel、type、href 屬性。 rel=”stylesheet”：連結樣式。type=”text/css”：連接類型。(不一定要加上)href=”URL”：連結位置。crossorigin＝”anonymous”：屬性是否使用CORS(不一定要加)，anonymous：發起跨域請求，但不發送認證訊息。 e.g. Code1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T&quot; crossorigin=&quot;anonymous&quot;&gt; script 外部引用&lt;script src=&quot;/path/to/your.js&quot;&gt;&lt;/script&gt;ps. 另外可加上 async 、 defer 屬性(必須搭配 src)。 async：下載後會先執行，但執行此 js 同時也繼續載入頁面及執行其他 js。defer：要整個頁面都下載及分析完成後才會執行，非常類似於把 js 放在頁尾的情況。integrity: 驗證完整性。 e.g. Code1&lt;script defer src=&quot;https://use.fontawesome.com/releases/v5.0.8/js/solid.js&quot; integrity=&quot;sha384-+Ga2s7YBbhOD6nie0DzrZpJes+b2K1xkpKxTFFcx59QmVPaSA8c7pycsNaFwUK6l&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; 網頁內容標籤body 標籤包含的元素會顯示在瀏覽器視窗，標籤組成有分成語意及無語意，來描述頁面資料及結構，視覺效果用 CSS 處理。&lt;body&gt;&lt;/body&gt; div 區塊標籤，可當做無語意的 &lt;header&gt;、&lt;article&gt;，無明顯含義的區塊或為了排版目的&lt;div&gt;&lt;/div&gt; span 行內標籤，可當做無語意的 &lt;strong&gt;、&lt;em&gt;。將文字與元素群組組在行內中。&lt;span&gt;&lt;/span&gt; 樣式標籤，使用 css 樣式(內部宣告用)。&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; 語意標籤用來排版及了解網頁區塊的設計目的，語意標籤和 &lt;div&gt;、&lt;span&gt; 在排版上具有完全一樣的特性，雖可用 &lt;div&gt;、&lt;span&gt; 來快速排版，但最好用以下語意標籤來替代。使用 HTML5 語意化標籤的優點有可以快速抓到網頁架構和每個區塊的位置，對於 SEO 優化有幫助。 HTML5 語意標籤(大多是區塊標籤)&lt;header&gt;：網頁的標頭，通常放置網站標題。&lt;nav&gt;：網頁的選單、導覽。&lt;main&gt;：網頁的主要內容。&lt;aside&gt;：網頁的側欄、附加內容。&lt;article&gt;：一篇文章內容。&lt;section&gt;：自訂的區塊，例如數篇摘要組成的空間。&lt;footer&gt;：網頁的頁尾，通常放置聯絡方式、著作權宣告等等。&lt;mark&gt;：強調一小塊內容。&lt;time&gt;：顯示日期時間。 //不是區塊&lt;mark&gt;：如黃色螢光筆的方式畫出重點，強調內容。 //不是區塊&lt;details&gt;：描述文章的細節。 //不是區塊&lt;figure&gt;、&lt;figcaption&gt;：&lt;figure&gt;用於圖像，&lt;figcaption&gt;用於圖像標題。&lt;hgroup&gt;：當內容有主標題及次標題等多個標題的狀況下使用。&lt;cite&gt;：引用其他文獻或作品(例如書籍、歌曲、電影、繪畫、雕塑等）的標題。 ps.也可當做屬性用 //不是區塊 e.g. 首先是使用 &lt;div&gt; 可能的網頁結構，除了基本元素之外，主內容展示一篇文章和側欄，頁尾則顯示網頁最後更新的時間： Code123456789&lt;div class=&quot;header&quot;&gt;&lt;/div&gt;&lt;div class=&quot;nav&quot;&gt;&lt;/div&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;article&quot;&gt;&lt;/div&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt; Updated on &lt;span class=&quot;time&quot;&gt;&lt;/span&gt;&lt;/div&gt; 接著改用語意標籤，語意標籤和 &lt;div&gt;、&lt;span&gt; 一樣，沒有預設樣式。 Code123456789&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;main&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/main&gt;&lt;footer&gt; Updated on &lt;time&gt;&lt;/time&gt;&lt;/footer&gt; 空白：原始碼可用空白字元來排版，因為瀏覽器有空白壓縮功能，兩個或以上的空白字元，瀏覽器畫面上只會顯示一個空白，原始碼內的斷行也視為單一空白字元。 標題 //區塊標籤&lt;h1&gt;&lt;/h1&gt; ~ &lt;h6&gt;&lt;/h6&gt; 段落 //區塊標籤&lt;p&gt;&lt;/p&gt; 粗體&lt;b&gt;&lt;/b&gt; 斜體&lt;i&gt;&lt;/i&gt; 上標&lt;sup&gt;&lt;/sup&gt; 下標&lt;sub&gt;&lt;/sub&gt; 斷行&lt;br&gt; 水平線 //區塊標籤&lt;hr&gt; 加強，通常標記為重要&lt;strong&gt;&lt;/strong&gt; 斜體，強調元素內容&lt;em&gt;&lt;/em&gt; 編號清單 //區塊標籤Code1234&lt;ol&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ol&gt; 項目清單 //區塊標籤Code1234&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt; 定義清單 //區塊標籤Code1234&lt;dl&gt; &lt;dt&gt;a&lt;/dt&gt; //被定義名詞 &lt;dd&gt;bb&lt;/dd&gt; // 定義&lt;/ul&gt; 巢狀清單Code12345678&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;ul&gt; &lt;li&gt;cc&lt;/li&gt; &lt;li&gt;dd&lt;/li&gt; &lt;/ul&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt; 將內容縮排，通常作為引述 區塊標籤&lt;blockquote&gt;&lt;/blockquote&gt; 引號&lt;q&gt;&lt;/q&gt; ps.&lt;blockquote&gt;及&lt;q&gt;通常會加上 cite=”url” 屬性標明來源。 縮寫及縮略字&lt;abbr&gt;&lt;/abbr&gt; ps. 可加上 title 屬性來註記全名 email or 地址 //區塊標籤&lt;address&gt;&lt;/address&gt; 插入字，會加上底線&lt;ins&gt;&lt;/ins&gt; 刪節線，元素內容會加上刪節線&lt;del&gt;&lt;/del&gt; 元素內容加上刪節線，標示不正確但不刪除的內容&lt;s&gt;&lt;/s&gt; 畫 canvas //區塊標籤&lt;canvas&gt;&lt;/canvas&gt; 置中，標籤內元素會置中&lt;center&gt;&lt;/center&gt; 顯示標籤內資料的原始格式&lt;pre&gt;&lt;/pre&gt; 旁註標記Code1234&lt;ruby&gt; 漢 &lt;rt&gt; ㄏㄢˋ &lt;/rt&gt; 漢 字的上面會標示 ㄏㄢˋ 漢 &lt;rr&gt; ㄏㄢˋ &lt;/rr&gt; 漢 字的旁邊會標示 ㄏㄢˋ&lt;/ruby&gt; 插入圖片&lt;img src=&quot;圖片位置&quot; alt=&quot;沒有圖片時的替代文字&quot; title=&quot;圖片資訊&quot;&gt; HTML5 用法 可放置一張以上的圖 Code12345&lt;figure&gt; &lt;img src=&quot;圖片位置&quot; alt=&quot;沒有圖片時的替代文字&quot; &gt; &lt;br&gt;&lt;figcaption&gt;圖片說明&lt;/figcaption&gt;&lt;/figure&gt; 超連結&lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;連結名稱&lt;/a&gt; ps. href：可用絕對或相對路徑target=”_blank”：連結另開新視窗title=”提示”：加入滑鼠游標提示href=”#id：連結到同網頁的某個部份href=”url#id”：連結到另一個網頁的某個部份href=”mailto:aa@example.org“：Email 連結 絕對路徑/img/logo.png 根目錄下的圖片page.html 同層目錄中的 html 檔 相對路徑 (通常用在自己的網站中)./css/all.css 同層目錄中的 css 資料夾裡的 css 檔../img/logo.png 上層目錄中的 img 資料夾裡的圖檔 音訊&lt;audio src=&quot;url&quot;&gt;&lt;/audio&gt; 屬性： control 提供撥放控制鈕preload=”none or auto or metadata” 頁面載入時是否載入視訊control 提供撥放控制鈕autoplay 自動播放loop 結束後從頭播放 多重音訊 HTML5 Code1234&lt;audio&gt;&lt;source src=&quot;檔案路徑&quot; type=&quot;視訊格式&quot; &gt;&lt;source src=&quot;檔案路徑&quot; type=&quot;視訊格式&quot; &gt;&lt;/audio&gt; 播放視訊(HTML5) //區塊標籤&lt;video src=&quot;url&quot;&gt;&lt;/video&gt;ps.video 標籤的屬性不需要值，屬性存在選項就會開啟，如果不存在選項就關閉。 屬性： src=”檔案路徑”height=”200”width=”100”preload=”none or auto or metadata” 頁面載入時是否載入視訊control 提供撥放控制鈕autoplay 自動播放loop 結束後從頭播放poster=”圖片位置” 視訊下載時或播放前所顯示的影像 放數個視訊 Code12345&lt;video&gt;&lt;source src=&quot;檔案路徑&quot; type=&quot;視訊格式&quot; code=&quot;編碼&quot; &gt;&lt;source src=&quot;檔案路徑&quot; type=&quot;視訊格式&quot; code=&quot;編碼&quot; &gt;&lt;source src=&quot;檔案路徑&quot; type=&quot;視訊格式&quot; code=&quot;編碼&quot; &gt;&lt;/video&gt; 表格：不要用來排版，只要顯示資料就好。用 CSS 處理排版。Code123456789101112131415161718192021222324252627&lt;table&gt; &lt;thead&gt; &lt;!--表頭--&gt; &lt;tr&gt; &lt;!--列的起始 row - - - column(行,欄) | | | --&gt; &lt;th&gt;Month&lt;/th&gt; &lt;!--表格標題--&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!--內容--&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;!--表格內容--&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;February&lt;/td&gt; &lt;td&gt;$80&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;!--註腳--&gt; &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt; &lt;td&gt;$180&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;td colspan=&quot;2&quot;&gt;$180&lt;/td&gt; 資料超過一欄 (跨欄)&lt;td rowspan=&quot;2&quot;&gt;$180&lt;/td&gt; 資料超過一列 (跨列) 表單&lt;form action=&quot;按下後接收送出資訊的url&quot; method=&quot;get or post&quot; id=&quot;a&quot;&gt;&lt;/from&gt; get：搜尋框 or 只想從伺服器取得資料(普通資料)。post：上傳檔案 or 表單很長 or 有敏感資料(密碼) or 資料加到資料庫或從資料庫刪除。 name 跟 value 屬性欄位的值有些會傳給伺服器任何文字輸入欄位可以使用 placeholder 屬性，placeholder=”顯示在欄位內的文字” e.g. Code123456789101112131415161718192021222324252627&lt;form action=&quot;按下後接收送出資訊的url&quot; method=&quot;get or post&quot; id=&quot;a&quot;&gt; &lt;p&gt;username 文字輸入 &lt;input type=&quot;text&quot; name=&quot;username&quot; maxlength=&quot;限制字元數&quot;&gt; &lt;/p&gt; &lt;!--多行文字輸入欄位標籤--&gt; &lt;textarea name=&quot;Content&quot;&gt;&lt;/textarea&gt; &lt;!--密碼輸入--&gt; &lt;input type=&quot;password&quot; name=&quot;username&quot; maxlength=&quot;限制字元數&quot;&gt; &lt;!--單選--&gt; &lt;input type=&quot;radio&quot; name=&quot;username&quot; value=&quot;傳到伺服器的值，每個單選鈕都不應相同&quot; checked=&quot;checked(預先選好)&quot;&gt; &lt;!--勾選(可取消)--&gt; &lt;input type=&quot;checkbox&quot; name=&quot;username&quot; value=&quot;傳到伺服器的值，每個單選鈕都不應相同&quot; checked=&quot;checked(預先選好)&quot;&gt; &lt;!--下拉式選單 (若都沒 selected 屬性的話，會顯示第一個選項)--&gt; &lt;select name=&quot;Location&quot; size=&quot;3&quot; multiple=&quot;multiple(可多選)&quot;&gt; &lt;option value=&quot;Taipei&quot; selected=&quot;selected(預先選好)&quot;&gt;台北&lt;/option&gt; &lt;option value=&quot;Taoyuan&quot;&gt;桃園&lt;/option&gt; &lt;/select&gt; &lt;!--檔案輸入 (method 必須使用 post)--&gt; &lt;input type=&quot;file&quot; name=&quot;username&quot;&gt; &lt;!--送出按鈕 (name 跟 value 欄位可用可不用)--&gt; &lt;input type=&quot;submit&quot; name=&quot;username&quot; value=&quot;顯示按鈕文字&quot;&gt; 影像按鈕 &lt;input type=&quot;image&quot; src=&quot;url&quot;&gt;&lt;/from&gt;&lt;input type=&quot;hidden&quot; name=&quot;&quot; value=&quot;&quot;&gt; 隱藏控制項，用隱藏欄位來記錄資訊 ps.表單驗證HTML5 有驗證功能，加入 required 屬性(不需要值)，由瀏覽器來做。)，HTML5 才有(不支援 HTML5 的瀏覽器會當作文字框)。 日期輸入&lt;input type=&quot;date&quot; name=&quot;date&quot;&gt;EMAIL 輸入&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;URL 輸入&lt;input type=&quot;url&quot; name=&quot;website&quot;&gt;搜尋輸入&lt;input type=&quot;search&quot; name=&quot;search&quot;&gt; label 協助使用者在點選到該標籤時，可以透過 for 的屬性值，去連動具有相同 id 屬性值的標籤。或是直接將 &lt;input&gt; 元素包圍起來。&lt;label for=&quot;某id值&quot;&gt;&lt;/label&gt; e.g. Code123&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;booktype&quot; value=&quot;1&quot; id=&quot;booktype1&quot; checked &gt;&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;booktype&quot; value=&quot;2&quot; id=&quot;booktype2&quot; checked &gt;&lt;label for=&quot;booktype1&quot;&gt;html 書&lt;/label&gt; 按鈕(可添加圖片)&lt;button type=&quot;button&quot;&gt;&lt;img src=&quot;url&quot; alt=&quot;&quot;&gt;&lt;/button&gt; iframe 顯示別的 url 的網頁內容在本身網頁的某區塊上&lt;iframe src=&quot;url&quot; height=&quot;20&quot; width=&quot;10&quot;&gt;&lt;/iframe&gt; 註解&lt;!----&gt; 符號顯示&amp;lt; &lt;&amp;gt; &gt;&amp;amp; &amp;&amp;copy; 版權符號&amp;reg; 註冊商標&amp;nbsp; 空白 //在畫面上出現多個空白 補充使用編輯器小技巧(emmet)： 若檔案為 *.HTML 的話，在開啟檔案後，打 ! ，可產生出以下標籤。 Code1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;``` + 打 link:css：快速產生 `&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;`+ 打 lorem300，可以產生 300個假字。+ 使用 `標籤名稱.class名稱*數量&gt;要包覆的標籤1+要包覆的標籤2` 方式，按下 enter，可以快速產生標籤。e.g.`div.test*2&gt;p+img`產生 Code123### 簡單網頁範例： &lt;!DOCTYPE html&gt; Document h1{color:red} 標題1 標題2 標題3 標題4 標題一 lorem js後的標題 123` 參考：https://zh.wikipedia.org/wiki/HTMLhttp://cychiang719.blogspot.com/2008/08/html.htmlhttp://n.sfs.tw/content/index/10323https://ithelp.ithome.com.tw/articles/10160131http://www.dlps.tc.edu.tw/html_teach/]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[記錄一下 AJAX 操作的幾個方法]]></title>
    <url>%2F2019%2F12%2F15%2FAJAX-base%2F</url>
    <content type="text"><![CDATA[AJAX(Asynchronous JavaScript and XML)的縮寫間單來說是與伺服器進行非同步通訊，可用來自伺服器的資料更新網頁元素，綜合了多項技術的瀏覽器端網頁開發技術。可以增進使用者的操作體驗。 以下介紹幾種使用方法： JavaScript XHR透過 XMLHttpRequest(XHR) 物件作為實作。它能夠在 client 端對 server 端送出 http request，使用的資料格式是 XML(這也變成時代眼淚，現今大多使用 JSON，它的格式像是 JS 中的物件)，用 XMLHttpRequest() 取到的結果會是字串，要額外透過 JSON.parse() 轉成 JSON 才可以使用。 Ps.目前較少用，難以閱讀及撰寫，我們大多都會使用框架來處理這段，如 jQuery, Axio… 程式碼大概長這樣： Code1234567891011121314151617181920212223242526272829303132333435363738function reqOnload () &#123; // 資料轉成 JSON 格式 const data = JSON.parse(this.responseText); console.log(data)&#125;function reqError (err) &#123; console.log(&apos;錯誤&apos;, err)&#125;// 宣告一個 XHR 的物件var Req = new XMLHttpRequest(); // 定義連線方式 true: 非同步 , false: 同步Req.open(&apos;get&apos;, &apos;https://randomuser.me/api/&apos;, true);// 送出請求Req.send();// 如果成功就執行 reqOnload()Req.onload = reqOnload; // 失敗就 reqError()Req.onerror = reqError;//POST(Form)var xhr = new XMLHttpRequest();xhr.open(&apos;post&apos;, &apos;http://xxx&apos;, true);xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);xhr.send(&apos;name=Bob&amp;password=123456&apos;);//POST(JSON)var account = &#123; name: &apos;Bob&apos;, password:&apos;123456&apos;&#125;var xhr = new XMLHttpRequest();xhr.open(&apos;post&apos;, &apos;https://xxx&apos;, true);xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);var data = JSON.stringify(account);xhr.send(data); XMLHttpRequest 有各種狀態碼(readyState)，能夠知道當前進行到什麼狀態。 0 : 已經產生 XMLHttpRequest，但還沒連結到要取得的網址。1 : 用了 open() ，但還沒傳送資料過去2 : 用了 send()3 : loading 資料4 : 撈回資料了，數據已接收完全 jQueryCode123456789101112131415161718$.ajax(&#123; url: &quot;http://xxx&quot;, // 傳送至Server的資料，必須為物件格式 data : &#123; datafromtestFile : $(&quot;#input&quot;).val(), &#125;, type: &quot;GET&quot;, // 傳回 JSON dataType: &apos;json&apos;, // 成功時執行函式 success: function(data) &#123; // 取得的遠端資料 console.log(data); &#125;, error: function(error) &#123; console.log(&quot;error:&quot;, error); &#125;&#125;); FetchES6 原生方法 ，是搭配 Promise(Promise 的基本用法)來執行請求網站和請求後獲取 Response 的處理。then 作為下一步，catch 作為錯誤回應 (404, 500…)。回傳的為 ReadableStream 物件，需要使用不同資料類型使用對應方法，才能正確取得資料物件。 Code1234567891011fetch(&apos;http://abc.com/&apos;, &#123;method: &apos;GET&apos;&#125;).then((response) =&gt; &#123; // 這裡會得到一個 ReadableStream 的物件 console.log(response); // 可以透過 blob(), json(), text() 轉成可用的資訊 return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log(&apos;錯誤:&apos;, err);&#125;); text()：改為 response.text()，取得的資料格式將會是純字串。blob()：將資料轉為 blob 物件，像是圖片就可以做這樣的轉換(指的是圖片檔案本身)。 範例： Code123456789101112// unsplash 上的圖片let url = &apos;https://images.unsplash.com/photo-1513313778780-9ae4807465f0?auto=format&amp;fit=crop&amp;w=634&amp;q=80&apos;fetch(url) .then((response) =&gt; &#123; return response.blob(); &#125;) .then((imageBlob) =&gt; &#123; let img = document.createElement(&apos;IMG&apos;) document.querySelector(&apos;.newImg&apos;).appendChild(img); // 將 blog 物件轉為 url img.src = URL.createObjectURL(imageBlob); &#125;) 用 Fetch 做 post 時，需做一些調整。將 body 所送出的資料轉純字串後才能送出。 Code12345678910111213141516171819let url = &apos;https://hexschool-tutorial.herokuapp.com/api/signup&apos;;fetch(url, &#123; method: &apos;POST&apos;, // headers 加入 json 格式 headers: &#123; &apos;Content-Type&apos;: &apos;application/json&apos; &#125;, // body 將 json 轉字串送出 body: JSON.stringify(&#123; email: &apos;lovef1232e@hexschool.com&apos;, password: &apos;12345678&apos; &#125;)&#125;).then((response) =&gt; &#123; return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log(&apos;錯誤:&apos;, err);&#125;) 使用 Fetch 需要注意，只要是伺服器有正確回應，不管是什麼狀態碼，就算是 404 也會將 response 傳入 then 之後的 function 繼續執行，而不會進到 catch。 此時可以透過 response 中的 ok 來判斷狀態碼是否正常，如果是 true 則表示狀態碼在於 200~299 之間。 所以可以多加個判斷 Code1234567891011121314fetch(&apos;http://abc.com/&apos;, &#123;method: &apos;get&apos;&#125;).then((response) =&gt; &#123; if (!response.ok) &#123; throw new Error(response.statusText); &#125; // 這裡會得到一個 ReadableStream 的物件 console.log(response); // 可以透過 blob(), json(), text() 轉成可用的資訊 return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log(&apos;錯誤:&apos;, err);&#125;); axios1.依賴 ES6 Promise，若不支援請使用 Polyfill2.支援 Promise API3.可取消請求 (Promise 無法)4.自動轉換 JSON5.axios 實體建立，可統一套用 Config、管理 API 安裝$ npm install axios Code12345678910111213141516171819202122232425// GETaxios.get(&apos;http://user/12345&apos;).then(res =&gt;&#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;)// POSTaxios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;).finally(() =&gt; &#123; /* 不論失敗成功皆會執行 */ &#125;); 管理 API 方式 開新檔 api.js Code12345678910111213141516171819202122232425262728import axios from &apos;axios&apos;;// User相關的 apiconst userRequest = axios.create(&#123; baseURL: &apos;https://api/user/&apos;&#125;);// 文章相關的 apiconst articleRequest = axios.create(&#123; baseURL: &apos;https://api/article/&apos;&#125;);// 搜尋相關的 apiconst searchRequest = axios.create(&#123; baseURL: &apos;https://api/search/&apos;&#125;);// User 相關的 apiexport const apiUserLogin = data =&gt; userRequest.post(&apos;/signIn&apos;, data);export const apiUserLogout = data =&gt; userRequest.post(&apos;/signOut&apos;, data);export const apiUserSignUp = data =&gt; userRequest.post(&apos;/signUp&apos;, data);// 文章相關的 apiexport const apiArticleItem = () =&gt; articleRequest.get(&apos;/ArticleItem&apos;);export const apiArticleMsg = data =&gt; articleRequest.post(&apos;/ArticleMsg&apos;, data);export const apiArticleLink = data =&gt; articleRequest.post(&apos;/ArticleLink&apos;, data);// 搜尋相關的 apiexport const apiSearch = data =&gt; searchRequest.get(`/Search?searchdata=$&#123;data&#125;`);export const apiSearchType = () =&gt; searchRequest.get(`/SearchType`); 如果需要用到的話，就 import Code1234567891011121314// import api.jsimport &#123; apiUserLogin, apiUserLogout, apiUserSignUp &#125; from &quot;api.js&quot;; // 使用 LoginapiUserLogin(&#123; email: &quot;mike@gmail.com&quot;, password: &quot;123456789&quot;&#125;).then(res=&gt; &#123; console.log(res);&#125;).catch(err=&gt; &#123; console.log(err);&#125;) 參考：axios 默認值 &amp; 建立實體 &amp; 錯誤偵測鐵人賽：ES6 原生 Fetch 遠端資料方法使用Axios你的API都怎麼管理？Day21 AJAX(1): 科普 &amp; XHRDay22 AJAX(2): Fetchaxios 基本使用 &amp; Config使用 fetch 來進行 Ajax 呼叫axios小筆記：一些特殊用法]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap 簡單介紹]]></title>
    <url>%2F2019%2F12%2F14%2Fbootstrap-base%2F</url>
    <content type="text"><![CDATA[Bootstrap前端框架，含HTML、CSS及JS等內容的框架，可以快速開發出一個網頁版型(包含響應式網頁)。簡單介紹一下樣式寫法：文字對齊text-justify、text-center 置右text-right 字體font-weight-bold 大小寫text-capitalize 文字顏色綠class=&quot;text-success&quot; 去除文字類別效果class=&quot;text-decoration-none&quot; 背景色bg-primary 背景梯度(Background gradient)顏色漸層bg-gradient-warning 邊界四邊都有border 只有上邊界border-top 沒有邊界border-0 除上邊界沒有其他三邊有border-top-0 邊界顏色class=&quot;border border-primary&quot; 邊界角度(Border-radius)四周都圓角class=&quot;rounded&quot; 圓形rounded-circle 無圓角rounded-0 上方圓角rounded-top 清除浮動(Clearfix)class=&quot;clearfix&quot; display 屬性設定class=&quot;d-block&quot; // display: block class=&quot;d-inline&quot; // display: inline Code1234&lt;div class=&quot;bg-danger m-5 p-2 text-light d-inline&quot;&gt;d-inline&lt;/div&gt;&lt;div class=&quot;bg-warning m-5 p-2 text-secondary d-inline&quot;&gt;d-inline&lt;/div&gt;&lt;span class=&quot;bg-danger m-5 p-2 text-light d-block&quot;&gt;text-danger&lt;/span&gt;&lt;span class=&quot;bg-warning m-5 p-2 text-secondary d-block&quot;&gt;text-secondary&lt;/span&gt; 隱藏元素也不佔空間class=&quot;d-none&quot; 顯示陰影class=&quot;shadow&quot; Close icon x&lt;button type=&quot;button&quot; class=&quot;close&quot; arialabel=&quot;Close&quot;&gt; 詳細樣式、元件、模板請參考網站 https://getbootstrap.com/docs/4.0/utilities 網格系統Bootstrap 的 Grid System。規則如下：結構依序為如下：container -&gt; row -&gt; column所有的「row」都要放在「container」之下，「col-\」(column) 要放在「row」之下。column 為最小單位的方格，且有間格將彼此格開。由「row」校正 colume 左右多出來的左右 padding。基本上一個 row 放置 12 個 column，若有一個 row 超過 12 個 column，則會斷行放置多出來的 column。* Container 提供方式來置中你的內容，當你的容器寬度是固定的使用 .container 如果想要滿版則使用 .container-fluid。 Column命名規則：phone (576px~767px) = .col-xs-* // 預設斷點 為數字 1~12Small grid (≧768px) = .col-sm-\ // 平板Medium grid (≧992px) = .col-md-* // 電腦Large grid (≧1200px) = .col-lg-* // 電腦(大型).col-md-offset-* // 位移 ps. 調整不同視圖下的欄寬度，在 Bootstrap 4 中 .col-xs-* 已消失，取而代之的 .col-* 在語意上代表的差別是「從最小設備到最大設備都相同的網格」。 只要在 row 中，直接加入 col 後，就會自動將 row 的 div 等分，比方要作三等份，以前需寫 col-md-4 ，但現在只要 col 重覆三次，無需再特別註明裝罝與數量，還可以混用，將 col 後再加數量。 範例一 Code1234567&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt;a&lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt;b&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;c&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 範例二 Code1234567891011&lt;div class=&quot;wrap&quot;&gt; or &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-8&quot;&gt;col-sm-8&lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt;col-sm-4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm&quot;&gt;col-sm&lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt;col-sm&lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt;col-sm&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 螢幕尺寸大小上調整不同寬度同一 column 加上多的 class 來調整版面： Code1234567&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-4 col-md-8&quot;&gt;.col-sm-4 .col-md-8&lt;/div&gt; &lt;div class=&quot;col-sm-8 col-md-4&quot;&gt;.col-sm-8 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- 當螢幕尺寸為 md 以上時會有 8:4 來顯示 當螢幕尺寸為 sm 時會以 4:8 來顯示 當螢幕尺寸小於 sm 時會換行顯示 --&gt; 隨著內容變動寬度使用 col-{breakpoint}-auto 同時搭配上 水平對齊 可以讓 column 的寬度隨著內容而改變。 間距拿掉.row 加入: no-gutters e.g.&lt;div class=&quot;row no-gutters&quot;&gt; 垂直對齊.row 或 .col 加入: align-items-start // 列或欄垂直的置頂align-items-center // 列或欄垂直的置中align-items-end // 列或欄垂直的置底 水平對齊.row 加入: justify-content-start // 置左justify-content-center // 置中justify-content-end // 置右justify-content-around // 是讓該列內的欄平均排列在該列justify-content-between // 是讓列類的欄靠邊排列在該列 Spacing指元素的 margin 跟 padding 。 m：marginp：paddingt：topr：rightb：bottoml：leftx：-right和-lefty：-top 和 -bottom m：marginmt：margin-topmr：margin-rightmb：margin-bottomml：margin-leftmx：margin-right 和 margin-leftmy：margin-top 和 margin-bottom p：paddingpt：padding-toppr：padding-rightpb：padding-bottompl：padding-leftpx：padding-right 和 padding-leftpy：padding-top 和 padding-bottom Bootstrap 4 裡 Spacing 基本的單位就是 1rem。1rem = 16px，結合上述的代碼。就是代表要多少的內距或外距。 0：0 1rem = 0px1：0.25 1rem = 4px2：0.5 1rem = 8px3：1 1rem = 16px4：1.5 1rem = 24px5：3 1rem = 48pxauto: margin 設定為 auto e.g. mb-3 = margin-bottom：16pxpt-4 = padding-top：24pxm-1 = margin：4px; 使用 flexboxclass=&quot;d-flex flex-column&quot; flex-column：直排上到下排列內元素flex-row：橫排左至右排列內元素 表單class=&quot;form-control&quot; 卡片(Cards)Cards 是 Bootstrap 4 的新組件，使用 Flexbox 建構，有瀑布流樣式(Masonry-like)可供使用。卡片可支援各種內容，包括圖像、文字內容、清單、連結等。 ps. 瀑布流樣式(Masonry-like): 將卡片包在 .card-columns 中，就會讓卡片呈現瀑布式排列。 範例套用 Bootstrap 4 的 class Code12345678910HTML&lt;div class=&quot;box2 bg-danger m-5&quot;&gt;&lt;/div&gt;CSS.box2&#123; width: 100px; height: 100px;&#125; 長寬各 100px 的 #dc3545 色正方型，然後四邊各有 48px 的外距。 參考：https://medium.com/@weilihmen/bootstrap-初學介紹-靜態篇-f20500235b33https://bootstrap.hexschool.comhttps://getbootstrap.comhttps://cythilya.github.io/2015/04/07/bootstrap-grid-system/https://5xruby.tw/posts/bootstrap-4/https://ithelp.ithome.com.tw/articles/10228808?sc=iThomeRhttps://pjchender.blogspot.com/2017/06/bootstrap4-grid-system.html]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RWD 基本知識]]></title>
    <url>%2F2019%2F12%2F13%2FRWD-base%2F</url>
    <content type="text"><![CDATA[響應式網頁(RWD)Responsive web design，縮寫為 RWD。是一種設計方式，利用操控 CSS 的方法來改變網頁樣式，網頁內容就可以自由的縮放、移動，好因應各種不同瀏覽器解析度，讓使用者在瀏覽網頁時都可以有最好的瀏覽體驗。在 HTML 上沒有甚麼不同，其實也只有在 &lt;head&gt; 標籤裡加上 Viewport Meta Tag。&lt;meta name=&quot;viewport&quot; content=&quot;&quot;&gt; content 的值有 Width // 寬度Width-device-width // 寬度為裝置的寬度Initial-scale // 文檔的初始比例(單位是 %)Maximum-scale // 設定縮放大小 Code1234// 指定螢幕寬度為裝置寬度，畫面載入初始縮放比例 100%&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; &gt;// 以下設定可以防止使用者做畫面縮放，將畫面鎖在縮放比例 100%&lt;meta name=”viewport” content=”width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 主要是在 CSS 的撰寫，以下進行簡單的介紹：撰寫方式是用 media query @media 來定義套用的媒體類型和特性。 媒體類型（Media Type）：可用的類型包含 all (default), print, screen 和 speech。媒體特性（Media Feature）：常用的類型包含 width, height, aspect-ratio, orientation, resolution，這些類型常常需要給定一個區間，像是 min, max, min-width, max-width, min-aspect-ratio, max-aspect-ratio。 定義媒體類型及同時定義媒體類型和媒體特性Code1234567891011// 定義媒體類型@media screen, print &#123; /* Styles for screen and print devices */&#125;// 同時定義媒體類型和媒體特性，中間需用 and 連接@media screen and (max-width: 650px) &#123; body &#123; background: rebeccapurple; &#125;&#125; 或是直接寫特性Code1234567891011121314151617181920212223242526272829// max-width 以電腦瀏覽比較為主通常用 max-width 開始寫// 當解析度小於768px@media (max-width: 768px) &#123; body&#123; background: yellow; color:black; &#125; &#125;// 當解析度小於375px@media(max-width: 375px)&#123; body&#123; background: blue; color:white; &#125;// min-width 以行動瀏覽為主的網頁通常會用 min-width 開始寫// 當解析度大於376px@media(min-width:376px)&#123; body&#123; background: yellow; color:black; &#125;&#125;// 當解析度大於769px@media(min-width:769px)&#123; body&#123; background: green; color:yellow; &#125; 簡單範例Code123456789101112131415161718192021222324252627//HTML&lt;meta name=”viewport” content=”width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;body&gt; &lt;h1&gt;請縮放螢幕使網頁內容產生變化&lt;/h1&gt; &lt;p&gt;test&lt;/p&gt;&lt;/body&gt;//CSSbody&#123; background: green; color:yellow;&#125;@media (max-width: 768px) &#123; body&#123; background: yellow; color:black; &#125; &#125;@media(max-width: 375px)&#123; body&#123; background: blue; color:white; &#125;&#125; 寫 RWD 時注意的事子元素寬度設定盡量使用 % ，避免縮放網頁時產生出 X 軸。Code1234567891011121314151617// 限定網頁最大寬度，避免產生 X 軸.wrap &#123; max-width: 1024px; margin: 0 auto;&#125;// 子元素寬度單位用 % .box1&#123; width: 100%; height: 200px; background: green;&#125;.box2&#123; width: 35%; height: 100px; background: pink; float:left;&#125; 瀏覽器尺寸範例：Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546@media screen and (min-width:1024px)&#123; /*STYLES*/&#125;@media screen and (min-width: 1200px) &#123; // 如果使用者之視窗寬度 &gt;= 1200px，將會再載入這裡的 CSS。&#125;@media screen and (min-width: 768px) and (max-width: 979px) &#123; // 如果使用者之視窗寬度介於 768px ~ 979px，將會再載入這裡的 CSS。&#125;@media screen and (max-width: 767px) &#123; // 如果使用者之視窗寬度 &lt;= 768px，將會再載入這裡的 CSS。&#125;@media screen and (max-device-width: 480px) &#123; // 如果使用者之裝置寬度 &lt;= 480px，將會再載入這裡的 CSS。&#125;瀏覽器直立或橫放@media screen and (orientation:portrait)&#123; // 直立時套用&#125;@media screen and (orientation:landscape)&#123; // 橫放時套用&#125;retina 顯示器我們可以透過 min-resolution: 192dpi 和 -webkit-min-device-pixel-ratio: 2 來定義 retina 顯示器：// 120dpi - 720px,// 192dpi - 1200px@media screen and (min-resolution: 192dpi), (-webkit-min-device-pixel-ratio: 2) &#123; /* ... */&#125;@media screen and (min-resolution: 120dpi) and (min-width: 720px) &#123; // ...&#125; 參考：[CSS] Media Query響應式網頁(RWD)環境與 Media Query使用 Bootstrap 建立一個 RWD Template（Twitter Bootstrap in Responsive Web Design）]]></content>
      <categories>
        <category>RWD</category>
      </categories>
      <tags>
        <tag>RWD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基本介紹]]></title>
    <url>%2F2019%2F12%2F13%2F2019-12-13-css-base%2F</url>
    <content type="text"><![CDATA[#CSS 基本介紹 CSS是什麼 樣式：將規則與 HTML 元素連結，來規定特定元素應呈現的樣子。 有範圍性，不用下重複設定在多個標籤元素上。直接在最外圍的標籤上設定，例如 body、header。 盡量不要用 id 來設計樣式。 不要習慣寫死高度，利用 max-width、margin、padding 來做出空間。 Bootstrap 格線設計好用。 加入到 HTML 三種方式1.外部載入 CSS 檔案這是一個比較常用的方式，通常會將所有的 CSS 檔案集中寫在一起，然後另存為一個附檔名為 css 的檔案，然後在 HTML 文件中的 head 標籤內添加一個 link 標籤並且在 href 屬性內，指向到該 CSS 檔案的存放位置。 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/all.css&quot;/&gt; 2.將 CSS 內容寫在 style 標籤裡，並放在 head 標籤裡。 Code12345&lt;style&gt; .red&#123; color: red; &#125;&lt;/style&gt; 3.或是將 CSS 內容單獨的寫在每一個指定的網頁標籤 &lt;p style=”color:green”&gt;&lt;/p&gt; 規則包含兩個部分：選取器(選取元素)和宣告p { color: red; }選取器 宣告 h1, h2, h3 { color: red; } 選取多元素 * { } 選取頁面上所有的元素 #introduction {} 選取 id=”introduction” 的元素 .introduction {} 選取屬性 class=”introduction” 的元素 p.a {} 選取 class 屬性值為 a 的 &lt;p&gt; 元素 li&gt;a {} 選取 &lt;li&gt; 元素內的 &lt;a&gt; 元素，但排除頁面上其他的 &lt;a&gt; 元素 p a {} 選取任何在 &lt;p&gt; 元素之內的 &lt;a&gt; 元素，即使兩者之間還有堆疊其他元素 階層規範(若兩個規則同時套用到同一個元素上) 後來先贏：以最後一個的規則為主 指定程度：若一個選取器較其他的更具指定性，以較具指定性的為主 Code123h1 比 * 更具指定性p b 比 p 更具指定性p#intro 比 p 更具指定性 重要：可在任何屬性值後面加上 !important ，來表示此規則比套用到相同元素的其他規定更重要。 Code123p b &#123; color: blue !important; &#125; 繼承父元素的某些屬性會套用到大部分的子元素上。或在屬性中使用 inherit 值來強迫許多屬性從父元素來繼承屬性值。 Code12345678910body &#123; font-family: Arial ; color: #665544; padding: 10px; &#125;.page &#123; border: 1px solid #665544; background-color: #efefef; padding: inherit; &#125; &lt;body&gt; 元素的 font-family 或 color 屬性會繼承給子元素 class=”page” 的 元素，從套用到 &lt;body&gt; 元素的 CSS 規則中繼承了內距尺寸。 屬性種類顏色color: DarkCyan; 前景色 三種表示方式：1.color: DarkCyan; // name2.color: #ee3e80; // hex3.color: rgb(100,100,90); // rgb background-color: white; 背景 opacity: 0,5;background-color: rgba(100,100,90,0.5); 不透明度(CSS3 值介於 0.0 到 1.0 or rgba 表示) background-image: url(位置); 元素背景影像 文字font-family: Arial, Helvetica, Georgia 指定字型 font-size: 12px; 字體大小 表示方式：1.font-size: 12px;2.font-size: 200%; // 瀏覽器預設文字大小是 16px3.font-size: 1.3em; // ㄧ個 em 等於 m 字母的寬度 font-weight: normal or bold; 粗體 font-style: normal or italic or oblique; 斜體 text-transform: uppercase(大) or lowercase(小) or capitalize(每個字的第一個字變大寫); 大小寫 text-decoration: none or underline(底線) or overline(文字上方加線) or line-through(刪節線) or blink(動態閃爍); 底線和刪節線 line-height: 1.5em; 行距 direction: 靠左 ‘ltr’ 及靠右 ‘rtl’; 設定文字的方向 text-align: left or right or center or justify; (段落除了最後一行外，每一行都應該佔據容器方框的整個寬度) 對齊 text-shadow: 1px 2px #111111;(左右多遠,上下多遠,模糊量) 陰影(CSS3) 盒子模型(box model)由四個部分組合：margin(外距)、border(邊框)、padding(內距)、content(內容)。它控制著頁面各元素的寬與高，比如當我們設定了一個元素的寬高時，所設定的數值還要再加上 padding 和 border，最後才會是這個元素的實際尺寸。如果一個區塊層級的元素位在另一個區塊層級元素內，那麼外面的方框就被稱為 容器 元素或 父 元素。 width: 200px; 元素寬度：單位有：px, em, %，css 3 多了 vw(可視視窗高) vh(可視視窗寬)。 min-width max-width 限制寬度 height: 200px; 元素高度：同上。 min-height max-height 限制高度 ps.使用px：網頁上設定一個 100px*100px 的正方形，當我們縮放螢幕的時候，這個元素並不會隨著變動寬高。使用 %：使用 % 的時候，如果我們的元素內並沒有任何內容，即使設定為 100%，是不會顯示出任何東西。使用vh、vw：使用上和百分比很像，當填入 30vh 和 30vw 時，意思就是這個元素要占整個螢幕可視範圍的30%，很重要的是，這個區塊範圍會隨著瀏覽器的縮放而改變。設計 RWD 時，圖片大小可利用此單位。 margin: auto(瀏覽器自行設定) or %(與邊界元素有關) or px or em; 外距(兩個相連元素之間的間距)。 設定方式：1.margin:上 右 下 左; // 填入數值2.margin:上下 左右;3.margin:上 左右 下;4.margin:四邊同値;獨立設定：margin-top：與上方元素的距離margin-right：與右方元素的距離margin-bottom：與下方元素的距離margin-left：與左方元素的距離 padding: 同上，margin 改成 padding 即可。 內距(邊框跟內容之間的空間)，加入可提高閱讀性。 設定方式跟獨立設定同上。 border: 10px solid #000; //四邊(大小 樣式 顏色) 邊框 設定方式：1.border-width: 2px 1px 1px 2px; // 對應 上 右 下 左2.border-style: solid 單實線 dotted 方格點 dashed 短線 double 兩條實線 groove 刻入頁面 ridge 突出頁面 inset 嵌入頁面 hidden/none 無邊框3.border-color: red red red red; // 對應 上 右 下 左4.border-image: url(“圖片位置”) 11 11 11 11 stretch; stretch 延伸影像 repeat 重複影像 round 重複影像5.border-radius: 5px, 10px, px, 10px; // 圓角若 border-radius 設定跟方框高度一樣，就可以做出圓形。獨立設定：同 padding。 若要準確控制版面不破版，原本所設定的尺寸還需要再扣掉 border/padding，但是這樣每次設尺寸都要做計算，這時可以使用 box-sizing 此屬性，方便我們在設定 width、height 上更直觀。 box-sizing: content-box or border-box or inherit; content-box：預設值，元素實際寬高＝所設定的數值＋border＋padding。border-box：元素實際寬高＝所設定的數值(已包含border和padding)。inherit：繼承至父層的 broder-sizing 設定値。 Code123456789&#123; width: 300px; // 設定寬度 height: 100px; // 設定高度 border: 1px solid black; //設定框線樣式 background-color: pink; //設定背景 margin:20px; //設定外距 padding:20px; //設定內距 box-sizing: border-box; //設定border及padding值包含在長寬內&#125; display: inline 區塊轉為行內元素，與鄰近元素保持在同一行 block 行內元素轉為區塊，另起一行 inlien-block; 區塊元素像行內元素一樣流動，但保持區塊元素其他特性 none; 隱藏元素，頁面上看不到 更改行內/區塊狀態，將行內元素轉成區塊元素。 visibility: hidden 隱藏 隱藏元素，不顯示內容，但將原有位置空下(產生空白)。若不要有空白，用 display 屬性。 位置position: top right bottom left(長度、百分比、或是 auto) static 預設 absolute 絕對 relative 相對 fixed 元素在網頁上的定位。 ps.absolute(絕對): 放在瀏覽器內的某個位置 (依 top、bottom、left、和 right 的值而定)。當使用者將網頁往下拉時，元素也會跟著改變位置。ps: 網頁的四個邊界開始起算。relative(相對): 元素擺在相對於另一個元素的任何地方。要定位的元素加上 position:absolute 還有(top,left,right,bottom)及對應的值，並且在他的父元素加上 position:relative，那個元素就可在在它的父元素範圍內任意定位。fixed: 這代表元素會被放在瀏覽器內的某個位置 (依 top、bottom、left、和 right 的值而定)。當使用者將網頁往下拉時，元素的位置不會改變。 z-index: auto 預設值 數字 inherit 繼承自父層順序 用來決定元素重疊的順序，當兩個元素有重疊的情況時。z-index 值比較大個元素會被放在上面。 float: left、right、none; 定義 box 的浮動，常見是將文字繞著一個圖案顯現或區塊排版。最後記得要使用清除浮動，避免跑版。 clear: left、right、both、none; 清除用來抵銷 float 屬性的作用 某元素置中Code12345&#123; margin: 0 auto; // 元素置中 width: 200px; text-align: center; // 內容也置中&#125; overflow: auto 自動使用捲軸 visible 直接超出範圍，不使用捲軸 hidden 隱藏 scroll 捲軸 inherit 繼承自父元素 當 content 超出 box 時的處理。 游標樣式cursor: auto or crosshair pointer help wait url(“位置”);元素定位處理(排版)還有其他方便的作法，例如 Flex、Grid …FlexFlex 中分為外容器與內元件 flex 外容器屬性display: flex | inlien-flex; 一開始就要宣告為 flex 才開始用 flex-direction: row | row-reverse | column | column-reverse 決定內元件排序方向，改變主軸線方向 — or |，預設狀態： row; //水平由軸線左至右排row-reverse //水平由軸線右至左排column //垂直由軸線上至下排column-reverse //垂直由軸線下至上排 flex-wrap: nowrap | wrap | wrap-reverse 超出範圍時是否換行動的屬性 nowrap; //不換行wrap; //換行wrap-reverse; //換行時反轉 flex-flow: flex-direction 與 flex-wrap 的縮寫，在其前後帶上相對應的值即可 flex-flow: row nowrap; justify-content: flex-start; … 內元件的元素主軸對齊(間隔)，看是 flex-direction 是 row or column flex-start; //靠左對齊flex-end; //靠右對齊center; //水平置中對齊space-between; //平均分配內元件，分開對齊(左右不留空)space-around; //平均分配內元件，分開對齊(左右留空) 以 flex-direction: row 為例： align-items: stretch; … 相對於上面的屬性，交錯軸對齊設定 | flex-start; //靠軸線上端對齊flex-end; //靠軸線下端對齊center; //置軸線中心對齊stretch; //預設值，延伸內元件全部撐開至 Flexbox 高度baseline; //以所有內元件的基線作為對齊標準(左右留空) align-content: flex-start; … align-items 的多行版本，排列方式多一些 flex-start; //靠軸線上端對齊flex-end; //靠軸線下端對齊center; //置軸線中心對齊stretch; //預設值，延伸內元件全部撐開至 Flexbox 的高度space-between; //平均分配內元件，分開對齊(上下不留空)space-around; //平均分配內元件，分開對齊(上下留空) flex 內元件屬性flex-grow: 數字; 元件的伸展性，預設值為 0。 flex-shrink: 數字; 元件的收縮性，當空間分配還不足時的當前元件的收縮性，預設值為 0。 flex-basis: 單位值(px) | auto; 元件的基準值，以自己的基本小大為單位。 align-self：center | flex-start | flex-end | stretch | baseline; 調整內元件交錯軸的對齊設定(主軸不能另外設定)，也可以個別設定單一元件。 order: 數字; 重新定義元件的排列順序，依據數值的大小 Grid一樣分成內外容器。Grid 和 flex 最大不同之處，透過 grid template 來定義版型的結構，分別由 column 及 row 定義出直排與橫列的格線，內容再依隔線作安排。外容器display: grid | inline-grid | subgrid; 定義容器的顯示類型 grid-template-columns: … | …; 橫列 track-size: 可使用彈性的長度、百分比或分數 (分數的部分需使用 fr 單位)line-name: 可自行命名的名稱 grid-template-rows: … | …; 直行 track-size: 可使用彈性的長度、百分比或分數 (分數的部分需使用 fr 單位)line-name: 可自行命名的名稱 範例 Code12345678.wrap &#123; display: grid; grid-template-columns: 200px 50px auto 50px 200px; grid-template-rows: 25% 100px auto; height: 100vh; width: 940px; margin: 0 auto;&#125; grid-template-columns: repeat(2, 1fr 2fr) 100px; repeat({次數}, {格線…} | {格線…}) | {格線…} fr：空間單位repeat：重複隔線 grid-template-areas: 透過 area 定義區塊在 template 上的位置，配合 gird-area 內元素 grid-area：定義空間的名稱外元素 grid-template-areas：定義空間的位置 範例 Code12345678910111213141516171819202122232425262728.wrap &#123; display: grid; grid-template-columns: 200px 50px auto 50px 200px; grid-template-rows: 25% 100px auto; grid-template-areas: &quot;header header header header header&quot; &quot;side main main main main&quot; &quot;side footer footer footer footer&quot;; height: 100vh; width: 940px; margin: 0 auto;&#125;.item-a &#123; grid-area: header; background-color: purple;&#125;.item-b &#123; grid-area: main; background-color: orange;&#125;.item-c &#123; grid-area: side; background-color: green;&#125;.item-d &#123; grid-area: footer; background-color: gray;&#125; ps.空間不能分離且是唯一的，錯誤範例: “side main side” 其他更詳細說明，請參考以下網站。 補充說明：###CSS RESET各瀏覽器其實都有預設一些 CSS，我們稱之為瀏覽器默認樣式(User Agent Stylesheet)，為了增進瀏覽體驗，但是各家瀏覽器的默認樣式並不相同。因此寫一個網頁的時候，我們另外寫了 CSS 檔，而網頁顯示出來的畫面，實際上是瀏覽器默認樣式加上我們的 CSS 。也因而造成同一個網頁在不同的瀏覽器看到的畫面有點不一樣。為了處理這個問題，就有了 CSS RESET，它可以幫我們清除瀏覽器默認樣式，依照我們撰寫的 CSS 檔來顯示。這樣就可以統一樣式了。 目前公認是 meyerweb 的版本。 /* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: &apos;&apos;; content: none; } table { border-collapse: collapse; border-spacing: 0; } 參考：https://w3bits.com/css-box-model/https://wcc723.github.io/css/2017/07/21/css-flex/https://wcc723.github.io/css/2017/03/22/css-grid-layout/https://pjchender.blogspot.com/2015/04/css-3vh-vw.htmlhttps://blog.techbridge.cc/2017/02/03/css-grid-intro/https://gridbyexample.com/https://css-tricks.com/snippets/css/complete-guide-grid/https://developer.mozilla.org/zh-TW/docs/Web/CSShttps://ithelp.ithome.com.tw/articles/10214957https://medium.com/change-or-die/css-%E5%85%A5%E9%96%80%E7%AD%86%E8%A8%98-%E4%B8%80-box-model-box-sizing-56ddc49ac89e]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 操作 DOM]]></title>
    <url>%2F2019%2F12%2F12%2F2019-12-12-DOM%2F</url>
    <content type="text"><![CDATA[HTMLHypertext Markup Language），中文為「超文字標示語言」，是一種用來組織架構並呈現網頁內容的程式語言。網頁內容的組成，可能包含了段落、清單、圖片或表格…等。 JavaScript 操作 DOM 的一些方法DOM：文件物件模型(Document Object Model)， 瀏覽器幫 HTML 的元素節點轉換成 JavaScript 可以操作的物件。 選取元素Code1let element = document.querySelector(&apos;&lt;element-name&gt;&apos;); 新增元素節點Code1document.createElement(&quot;div&quot;); 在某元素後面加入元素Code1.appendChild() 移除該元素Code1.removeChild() 改變元素裡面的文字內容Code1.innerText() 改變元素文字及標籤內容Code1.innerHTML() 新增元素節點樣式Code1.classList.add(&apos;樣式&apos;); 刪除元素節點樣式Code1.classList.delete(&apos;樣式&apos;) 監聽元素事件Code1234element.addEventLister(&apos;事件名稱&apos;, function(e)&#123; // do something&#125;,&lt;boolean&gt;)true =&gt; 捕獲 ; false =&gt; 冒泡，不加參數的話，預設值是 false e.g. click 事件(e.target 點擊到的元素)Code12345678&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script&gt;document.getElementById(&quot;test&quot;).addEventListener(&quot;click&quot;, function( event ) &#123; // 在 “clicked div”顯示點擊次數 event.target.innerHTML = &quot;click count: &quot; + event.detail; &#125;, false);&lt;/script&gt; DOM 事件傳遞機制捕獲 根節點開始往下傳遞子節點然後到 target 冒泡 從 target 往上到子節點一路逆向傳回去根節點 DOM 事件傳遞的順序，先捕獲 -&gt; 自身 -&gt; 冒泡。 取消事件傳遞 Code1*加在哪邊，事件傳遞就停在那，不向上(或下)級傳遞*el.addEventListener(‘click’, (e) =&gt; { // e.eventPhase 回傳一個整數值以代表目前事件於事件流中的傳遞階段 console.log(‘el’, e.eventPhase); e.stopPropagation();}, true)Code1#### 取消預設行為 ```e.preventDefault() 取消瀏覽器的預設行為 Code123456// 超連結使用(不會新開分頁或是跳轉）el_link.addEventListener(&apos;click&apos;, (e) =&gt; &#123; e.preventDefault();&#125;, false)// &lt;form&gt; 的 submit - 阻止送出表單// &lt;input&gt; 的 keypress 事件 - 阻止輸入按鍵 事件傳遞應用事件代理(Delegation)利用 DOM 事件的冒泡特性，將子層元素的監聽事件綁定在父層元素上，好處有：1.如果有很多子元素，就不用一一綁定監聽事件。2.動態新增進來的子元素，因為也是會冒泡到上層，就不怕沒綁定到監聽。 元素操作範例印出 9*9Code1234567891011121314151617181920(function() &#123; const chart = document.querySelector(&apos;#chart&apos;); for (let i = 2; i &lt;= 9; i++) &#123; const DIV = document.createElement(&apos;div&apos;); // 新增 DIV 節點 DIV.classList.add(&apos;col-md-4&apos;); // 新增 DIV 樣式 chart.appendChild(DIV); // id=chart 的元素增加子節點 DIV // chart.append 將字串插入到網頁元素 const UL = document.createElement(&apos;ul&apos;); UL.classList.add(&apos;chart-list&apos;, &apos;list-unstyled&apos;, &apos;bg-light&apos;); DIV.appendChild(UL); let str = `&lt;li class=&quot;chart-num&quot;&gt;$&#123; i &#125;&lt;/li&gt;`;// 2 ~ 9 // 組開頭數字 2~9 字串 //console.log(&apos;外層for&apos;, str); for (let j = 1; j &lt;= 9; j++) &#123; str += `&lt;li class=&quot;h4&quot;&gt;$&#123; i &#125; x $&#123; j &#125; = $&#123; i*j &#125;&lt;/li&gt;`; // 2 x 1 ~ 9 x 9 //console.log(&apos;內層for&apos;, str); &#125; //console.log(&apos;結果&apos;, str); UL.innerHTML = str; // 將字串插入到網頁元素 &#125; &#125;()); //立即呼叫函式 IIFE 印出正方形Code1234567891011121314function square(size)&#123; const chart = document.querySelector(&apos;#chart1&apos;); for (let i = 1; i &lt;= size; i++) &#123; // 印出第i列 for (let j = 1; j &lt;= size; j++) &#123; // 第i列有size個* const sp = document.createElement(&apos;span&apos;); sp.classList.add(&apos;col-md-4&apos;) chart.appendChild(sp); // 增加 span 元素 let str = `*`; sp.innerHTML = str; // 新增元素內容 &#125; const Br = document.createElement(&apos;br&apos;); chart.appendChild(Br); // 增加斷行元素 &#125; &#125;; 印出斜一邊的三角形Code1234567891011121314function sidetriangle(size) &#123; const chart = document.querySelector(&apos;#chart2&apos;); for (let i = 1; i &lt;= size; i++) &#123; // 印出第i列 for (let j = 1; j &lt;= i; j++) &#123; // 第i列有i個* const sp = document.createElement(&apos;span&apos;); sp.classList.add(&apos;col-md-4&apos;) chart.appendChild(sp); // 增加 span 元素 let str = `*`; sp.innerHTML = str; // 新增元素內容 &#125; const Br = document.createElement(&apos;br&apos;); chart.appendChild(Br); // 增加斷行元素 &#125;&#125;; 參考：MDNDOM 的事件傳遞機制：捕獲與冒泡https://yakimhsu.com/project/project_w10_review_DOM&amp;EventListener.html]]></content>
      <categories>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 基本介紹]]></title>
    <url>%2F2019%2F12%2F11%2F2019-12-12-Git%2F</url>
    <content type="text"><![CDATA[簡單記錄一下 Git 學習過程 Git Git 是一個分散式版本控制軟體，可藉由它產生一個儲存庫( git Repository)。 可在自己本機電腦跟遠端伺服器儲存及管理檔案，並做同步處理。 紀錄管理有使用 Git 的目錄內的檔案增刪、檔案內容的修改。 有圖形化介面可以使用，例如：SourceTree。 終端機指令介紹在操作 Git 之前，先來介紹一下終端機的基本指令 ls 查看目錄中的檔案列表 ls -la 列出隱藏文件 cd ~ 前往主目錄 pwd 查看目前所在目錄位置 mkdir test 建立 test 的子目錄 cd test 切換到 test 目錄 cd .. 回到上層目錄 touch index.html 新增 html 檔,若目錄內已有檔案時,會修改檔案時間 cp 複製文件 mv 移動檔案 rm index.html 刪除檔案 rm -R 刪除資料夾與其內所有檔案 安裝Git到官方網站根據自己的作業系統下載https://git-scm.com/downloads 或是透過 Homebrew 來下載https://brew.sh/index_zh-tw.html Code1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 複製以上內容，到終端機視窗貼上並執行。安裝完後，再複製以下內容， Code1$ brew install git 到終端機視窗貼上並執行。 使用者設定剛開始使用時 Git ，首先要設定名稱跟 e-mail 信箱 Code12$ git config --global user.name &quot;your_name&quot;$ git config --global user.email &quot;your_email&quot; Git 區塊Git 有三個檔案存放區塊 如圖所示，分為工作目錄 (未 add )，初始狀態。暫存區 (已 add ，未 commit )儲存區 (已 commit ) Git 指令(終端機)git init “要板控的專案目錄” 初始化專案，開始版控 git add .要放入存放區的檔案 (ex. git add .gitignore ) git add . 當前目錄所新增及修改的檔案加到暫放區(若是在根目錄執行，大致上等於 git add -A) git add -A 整個專案目錄所有的修改都加入到暫放區 git status 看暫放區狀態 git commit -m “提交訊息(註解)” 加入註解後，將專案目錄儲存到儲存庫 git log —oneline 看訊息 git blame index.html 查看檔案內容是誰修改(e.g. index.html) Git 分支git branch ‘分支名稱’ 新增分支 dog(分支可當成貼上標籤) git branch -d ‘分支名或id’ 刪除分支，若參數為 -D ，則是強制刪除 git branch 查看分支 名稱前有 * 的是 head 所在 git branch -f master 版本號碼 將 master 移至該版本號碼 git checkout ‘分支名稱或版本id’ 切換到該分支或該版本 git checkout -b dog 建立 dog 分支並切換過去 git merga ‘分支名稱’ 合併該分支 git rebase ‘分支名稱’(另一種合併方式 ) 改變 base (不會產生合併節點) git reset commit_id(變回該版本) 回到某個版本，原本內容會回到工作目錄–mixed 檔案丟回工作目錄–soft 檔案丟回暫存區–hard 直接刪掉 git reflog 看 log git reset commit_id^ 回到該版本的前一個狀態 幾個 ^ 等於回前幾個 git reset HEAD~2 回到 HEAD 的前2個狀態 git tag 1.0.0 commit_id 貼上標籤 git revert 撤消一個commit 同時建立一個新的 遠端資料庫操作(e.g. GitHub)ps.先到 GitHub 新增一個儲存庫 git remote add origin “遠端 git 網址” 連接遠端儲存庫。origin 代表遠端節點，名稱可修改。 git remote -v 查看遠端 Git 的目的地 git push origin master 把本地的 master 分支推送到 origin 這個遠端節點並在遠端形成一個 master 分支 git pull origin master 到 origin 這個遠端節點, 抓 master 分支的內容,並在本地電腦建立一個 origin/master 分支,同時與本地的 master 分支進行合併 git fetch origin master 到 origin 這個遠端節點, 抓 master 分支的內容,並在本地電腦建立一個 origin/master 分支 git clone “遠端 Git 網址” 把遠端 Git 網址的內容複製ㄧ份到本地端電腦 Git 情況處理1.遠端內容比本機上的新Git push 時發生以下錯誤： error: failed to push some refs to ‘https://github.com/xxxx/xxx.git&#39;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 這段訊息的意思是線上版本的內容比你電腦裡這份還要新，所以 Git 不讓你推上去。可用 git pull origin master —rebase (內容抓下來之後請使用 Rebase 方式合併。)盡量不要用 git push -f origin master 會把自己的檔推上去蓋掉他人的,並以自己的為主。ps.多人的話,盡量開自己的分支來做 2.不想在 Git 內放機密檔案$ touch .gitignore (建立Git 忽略檔案, 然後去編輯 gitignore. 已經存在的黨無效) 內容可放nom-debug.log npm除錯紀錄node_modules 專案依賴關係.DS_Store OSX資料夾屬性.tmp 暫時性檔案 ~ 不想再用版控把 .git 目錄刪除就可以 參考為你自己學 GitGit: 如何從特定 commit 切新的分支？]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本陣列操作]]></title>
    <url>%2F2019%2F12%2F10%2F2019-12-10-%E5%9F%BA%E6%9C%AC%E9%99%A3%E5%88%97%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[介紹一下陣列基本操作的幾個方法建立陣列javascript123const arr = [1,2,3,4,5]; const arr = new Array(1, 2, 3, 4, 5); const arr = Array(1,2,3,4,5); 陣列長度javascript1console.log(arr.length); // 5 設定長度javascript1const arr = new Array(5); 空陣列javascript1const arr = []; 讀取其中一個元素，索引從零開始，對應第一個元素javascript1console.log(arr[0]); // 1 設定陣列長度可以操作陣列內元素，長度若為零。則輸入空陣列javascript12arr.length = 0;console.log(arr); // [] Array.from() 可建立一個新的 Array 實體1.從字串 javascript1Array.from('Hi'); // ["h", "i"] 2.從集合：集合會將集合內重複的元素剔除，可作分類使用 javascript123var s = new Set(['hi', 1, 1, 2]); Array.from(s);console.log(s); // &#123;"hi", 1, 2&#125; 迭代(讀取每一個值，然後用同樣的方式處理每一個值)for 迴圈取陣列元素javascript123456789const arr = [1,2,3,4,5];for (let i = 0; i &lt; arr.length; i++) &#123;console.log(arr[i]); // 依序輸出 1 2 3 4 5 &#125;// 另一種寫法let arr = [1, 2, 3, 4, 5];for (let index in arr) &#123; console.log(arr[index]); 依序輸出 1 2 3 4 5&#125; foreach：將陣列內每個元素，都傳入並執行指定函式一次。javascript123456789// 取陣列中大於 3 的數字const arr = [1, 2, 3, 4, 5];let arr1 = [];arr.forEach((value) =&gt; &#123;if (value &gt; 3)&#123; arr1.push(value);&#125;&#125;);console.log(arr3); // [4,5] 方法push()：新增元素javascript12const arr = [1,2,3,4,5] arr.push(6); // [1, 2, 3, 4, 5, 6] pop()：取出陣列最後一個元素並從陣列移除javascript123const arr = [1,2,3,4,5];let el = arr.pop(); // el = 5console.log(arr); // [1,2,3,4] concat()：合併兩個陣列，並把新的陣列返回javascript123var a1 = [1, 2];var a2 = a1.concat(['a', 'b']);console.log(a2); // 1,2,a,b join()：把所有的陣列元素合併成字串javascript123var a = ['Hello', 'world'];console.log(a.join('-')); // "Hello-world"console.log(a.join('')); // "Helloworld" reverse()：反轉陣列元素的順序至適當的位置javascript123const arr = [1,2,3,4,5];arr.reverse();console.log(arr); // [5, 4, 3, 2, 1] ps.反轉字串應用javascript1234const str = 'Hello';// split 將字串以指定的分隔符號來分割 str1 = str.split('').reverse().join('');console.log(str1); // olleH shift()：取回陣列的第一個元素並移除javascript1234const arr = [1,2,3,4,5];let a = arr.shift();console.log(a) // 1console.log(arr); // [2, 3, 4, 5] unshift()：在陣列的開頭處加入一個以上的元素javascript123const arr = [1,2,3,4,5];arr.unshift(6) console.log(arr); // [6, 1, 2, 3, 4, 5] slice(start_index, upto_index)：回傳部分陣列javascript123const arr = [1,2,3,4,5];arr.slice(1,4) // arr[1] 到 arr[3] 之間的元素console.log(arr); // [2, 3, 4] splice(start, deleteCount, item1, … )：刪除既有元素／或加入新元素來改變一個陣列的內容start：開始位置deleteCount：刪除幾個元素(0 就是不刪除)item1：要加入的元素 javascript12345678const arr = [1,2,3,4,5];let removed = arr.splice(1, 0, 3)console.log(removed); // []console.log(arr); // [1, 3, 2, 3, 4, 5]let removed2 = arr.splice(1, 2, 3)console.log(removed2); // [3, 2]console.log(arr); // [1, 3, 3, 4, 5] sort()：排序陣列的元素，預設的排序順序是根據字串的 Unicode 編碼位置javascript123const arr = ['bob', 'alice', 'jack'];arr.sort(); console.log(arr); // ["alice", "bob", "jack"] ps.也可以用函式來決定如何排序(陣列數字排列要用這種方式)javascript1234567891011const arra = [2,6,1,8,10,32];// 數字排列小到大 arra.sort(function(a, b)&#123; return a - b; &#125;);console.log(arra); // [1, 2, 6, 8, 10, 32]// 數字排列大到小 arra.sort(function(a, b)&#123; return b - a; &#125;);console.log(arra); // [32, 10, 8, 6, 2, 1] ps.陣列數字找大小：用展開運算子將陣列展開成個別值就可以用函式快速找出javascript12345// 陣列數字找大小const arra = [2,6,1,8,10,32];let max = Math.max(...arra);let min = Math.min(...arra);console.log(max, min); // 32, 1 indexOf()：尋找陣列中是否有符合的元素，回傳 -1，表示沒有，回傳正整數表示在那個位置javascript12const arr = [1,2,3,4,5];console.log(arr.indexOf(3)); // 2 ps.jQuery 用法javascript12const arr = [1,2,3,4,5];console.log($.inArray(2, arr)); // 1 includes：陣列中尋找指定元素，回傳 true(找到)或 false(沒找到)javascript12const arr = [1,2,3,4,5];console.log(arr.includes(2)); // true filter()：回傳符合條件的元素，得到一個新陣列javascript12345const arr = [1,2,3,4,5];let arr1 = arr.filter((value) =&gt; &#123; return value &gt; 3; &#125;);console.log(arr1); // [4,5] indexOf 與 $.map 使用，尋找是否有符合的物件javascript12345678910const people = [ &#123; name: 'Peter', age: 10 &#125;, &#123; name: 'John', age: 3 &#125;, &#123; name: 'Nina', age: 15 &#125;];//find object in listlet result = $.map(people, function(item, index) &#123; return item.name&#125;).indexOf('Nina');console.log(result); //2 map()：原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合成為一個新陣列，常用對陣列元素做加工javascript12345const arr = ['a', 'b', 'c'];let arr1 = arr.map((value) =&gt; &#123; return value.toUpperCase() ; &#125;);console.log(arr1); // ["A", "B", "C"] every()：檢查陣列是否全部符合條件，僅會回傳一個值 true or falsejavascript12345const arr = [1,2,3,4,5];let arr1 = arr.every((value) =&gt; &#123; return value &gt;= 1; &#125;);console.log(arr1); // true some()：檢查陣列元素其中是否有符合條件，僅會回傳一個值 true or falsejavascript12345const arr = [1,2,3,4,5];let arr1 = arr.some((value) =&gt; &#123; return value === 3; &#125;);console.log(arr1); // true reduce()：陣列變成個別值，傳入函式內處理。數值加總是常見做法javascript1234567const arr = [1,2,3,4,5];// 處理每個元素後等待回傳結果，第一次處理時代入初始值 0let result = arr.reduce((prev, value) =&gt; &#123;// 與之前的數值加總，回傳後代入下一輪的處理 return prev + value; &#125;, 0); // 初始值為零console.log(result); // 15 ps.陣列扁平化，將複雜的陣列變成一維javascript123456789101112131415const myArr = [ [ 1, 2 ], [ 3, 4, 5 ], [ 6, 7, 8 ]];// 將所有元素都與之前代入的陣列相接起來，第一次處理時代入初始值空陣列let newArr = myArr.reduce(function(arr, element) &#123; // ex: [ 1, 2 ].concat([ 3, 4, 5 ]) return arr.concat(element);&#125;, []);console.log(newArr); // [ 1, 2, 3, 4, 5, 6, 7, 8 ]// 1.將空陣列與 [ 1, 2 ] 相接起來後回傳// 2.將被代入的 [ 1, 2 ] 與 [ 3, 4, 5 ] 相接起來後回傳// 3.將被代入的 [ 1, 2, 3, 4, 5 ] 與 [ 6, 7, 8 ] 相接起來後回傳 ps.對陣列的內容進行統計javascript1234567891011121314151617181920212223const myArr = [ 'C/C++', 'JavaScript', 'Ruby', 'Java', 'Objective-C', 'JavaScript', 'PHP'];// 計算出每種語言出現過幾次let langStatistics = myArr.reduce(function(langs, langName) &#123; // hasOwnProperty() 回傳物件是否有該屬性的布林值。 if (langs.hasOwnProperty(langName)) &#123; langs[langName]++ &#125; else &#123; langs[langName] = 1; &#125; return langs;&#125;, &#123;&#125;);console.log(langStatistics);// &#123; 'C/C++': 1, 'JavaScript': 2, 'Ruby': 1, 'Java': 1, 'Objective-C': 1, 'PHP': 1 &#125; ps. Object 的形式的處理javascript12345678910111213141516171819const data = &#123; 'Fred': 1, 'Leon': 2, 'Wesley': 3, 'Chuck': 4, 'Denny': 5&#125;;// 使用 Object.keys() 取得包含所有 key 的陣列let result = Object.keys(data).reduce(function(prev, name) &#123; // 利用 key 取得原始物件中的值，然後加總 return data[name] + prev;&#125;, 0);console.log(result); // 15// Object.keys()：回傳一個由指定物件所有可列舉之屬性(key)組成的陣列Object.keys(data) // ["Fred", "Leon", "Wesley", "Chuck", "Denny"]data[Fred] // 1 map() 和 reduce() 結合使用javascript1234567891011const arr = [1,2,3,4,5,6,7,8,9,10];let result = arr.map((value) =&gt; &#123; if (value &gt; 5) &#123; return 5; &#125; return value; &#125;).reduce((prev, value) =&gt; &#123; return prev + value; &#125;, 0); // 初始值為零console.log(result); // 40 參考資料https://www.hexschool.com/2017/09/01/2017-09-01-javascript-for/http://fred-zone.blogspot.com/2017/01/javascript-mapreduce.htmlhttps://cythilya.github.io/2017/05/08/javascript-find-item-in-an-array/https://developer.mozilla.org/zh-TW/]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS偽類與偽元素]]></title>
    <url>%2F2019%2F06%2F05%2F2019-06-05-CSS%2F</url>
    <content type="text"><![CDATA[偽元素 (pseudo element) 和偽類 (pseudo class) 差在哪有時候 CSS 裡會出現單冒號 : 跟雙冒號 :: 的符號，單冒號開頭的是偽類 (pseudo class) ，雙冒號開頭的是偽元素 (pseudo element) 。 一般常見的偽類有: 動態：:link、:hover、:active、:focus、:visited 元素狀態：:disabled、:enabled、:checked 結構：:root、:nth-child、:nth-last-child、:nth-of-type、:nth-last-of-type、:first-child、:last-child、:first-of-type、:last-of-type、:only-child、:only-of-type、:empty 偽元素有: ::first-line：選取第一行 ::first-letter：選取第一個字 ::before：從選取元素的前面加入元素 ::after：從選取元素的後面加入元素 ::selection：選取文字反白後 ps.現在單一冒號 : 也可以代表偽元素，但要注意瀏覽器是否支援。 補充SCSS 的 &amp; 符號是scss的语法，代表上一層選擇器(元素) 有時會看到類似寫法 Code12345678.bordered &#123; &amp;.float &#123; float: left; &#125; .top &#123; margin: 5px; &#125;&#125; 其實上面寫法等同於 Code123456.bordered.float &#123; float: left; &#125;.bordered .top &#123; margin: 5px;&#125; .bordered.float 是串聯選擇器，作用在同一標籤上.bordered .top 是後代選擇器，作用在不同標籤上 有時 CSS 中有定義一些 pseudo-classes (或稱偽類、準類別)，被使用來為元素增加一些特效，如 :hover, :link, :visited, :before, :after 等這些以冒號(:)開頭的類別名稱。例如把滑鼠移到某個網頁連結時，連結會變色的 CSS 語法： Code1234567a &#123; font-weight: bold; text-decoration: none;&#125;a :hover &#123; color:#FF00FF;&#125; 上述其實還是一種巢狀的結構，只是都作用到同一個元素(例如範例的 a 元素)上。這樣情況就能夠用對 :hover 使用 ＆ 符號來代表其作用的父選取器，所以上述的 CSS 範例的 Sass 就可以寫成： Code1234567a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; color:#FF00FF; &#125;&#125; 參考來源：oxxostudioCSS 偽類 child 和 of-type]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown語法]]></title>
    <url>%2F2019%2F05%2F29%2F2019-05-29-Markdown%E8%AA%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown Markdown 是一種輕量級標記式語言它有純文字標記的特性，讓編寫的可讀性提升不少。目前已有不少網站都使用 Markdown 來撰寫文件或是在網站上發表文章。 現在來介紹幾個常用的語法: 粗體語法***bold***顯示畫面bold 標題字語法# This is an tag顯示畫面 This is an tag列表語法顯示畫面 item 1 item 2 item 2a item 2b 編號列表語法顯示畫面 Item 1 Item 2 Item 3 Item 3a Item 3b CheckBox括號中的 x 就代表此項目是有勾選的，它並不會主動紀錄勾選過的內容，所以使用時要注意確認。 - [x] This is a complete item- [ ] This is an incomplete item 顯示畫面 This is a complete item This is an incomplete item 區塊區塊分為小區塊跟大區塊，通常用於一段相關內容的撰寫，一小段文字或是註釋可用小區塊來表示，內容較多又不想跟一般段落內容混在一起的話，則會用大區塊來表示。小區塊語法：Code1`Format one word or one line` 大區塊語法：Code1code (4 spaces indent) 顯示畫面： Format one word or one line code (4 spaces indent) 程式碼只要使用三個反引號加上語言簡稱就可以了。高亮程式碼顯示語法 Javascript123var n=1;var b=2,c=3;eval('a'+n+'=b*c'); 圖片插入圖片語法![GITHUB](_圖片網址 &quot;圖片名稱&quot;_)Code1&#123;% asset_img Steve.jpg This is an image %&#125; 階層式區塊階層式區塊在表現結構或功能關係上是相當好用的呈現形式語法： > Quote one sentences>&gt;Quote two sentences>&gt;Quote two sentences>&gt;&gt;Quote three sentences 顯示結果： Quote one sentences Quote two sentencesQuote two sentences Quote three sentences ImagesFormat: Links語法http://github.com - automatic![GitHub](http://github.com) 顯示http://github.com - automatic!GitHub Inline codeI think you should use an&lt;addr&gt; element here instead. Tables語法 First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column 顯示 First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column 參考來源：Markdown - 易編易讀，優雅的寫文吧！ - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天Mastering Markdown · GitHub GuidesMarkdown文件]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript eval()的用法]]></title>
    <url>%2F2019%2F05%2F29%2F2019-05-29-JavaScript-eval%2F</url>
    <content type="text"><![CDATA[eval() 是個滿好用的函式，用途也多種，常常會使用到。 eval 是 evaluates 。例如：Javascript123var n=1;var b=2,c=3;eval('a'+n+'=b*c'); 上面結果會變成 a1=b*c ，就是變數 a1 的結果為 6。 由以上可知，eval() 是把一組字串，當作指令來執行，並得出結果。實作時，在訂單處理上應用較廣，例如以下是份簡單訂單： 數量 單價 小計 Q1 P1 T1 Q2 P2 T2 Q3 P3 T3 用編號來進行不同筆數訂單欄位命名，而不是每個欄位獨立命名，顯示，在輸入數量及單價後，小計要能自動計算。 假設這份表單名為 order，所以： document.order.T1.value=document.order.Q1.value*document.order.P1.value;document.order.T2.value=document.order.Q2.value*document.order.P2.value;document.order.T3.value=document.order.Q3.value*document.order.P3.value; 你是不是會想用 for 來跑迴圈？可是，T1、;Q1 這些欄位名稱一直在變，怎麼跑迴圈呢？這時，eval() 就派上用場了，eval() 把「唸的內容」當結果執行，這個例子怎麼唸呢？ 「第一個 T 的值等於第一個 Q 的值乘以第一個 P 的值」，換成 Javascript12345eval()：var form=document.order;for (var i=1;i&lt;=3;i++)&#123; eval('form.T'+i+'value=form.Q'+i+'value(form.P'+i+'value');&#125; 把 eval() 裡的字串，i 的值分別用 1,2,3 套入，結果和前面寫一大串三行的效果一模一樣。 參考來源：icodding愛程式: JavaScript 的 eval() 用法介紹]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new postbash1$ hexo new "My New Post" More info: Writing Run serverbash1$ hexo server More info: Server Generate static filesbash1$ hexo generate More info: Generating Deploy to remote sitesbash1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
