<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 Node.js 設計 RESTful API 來串接 mongoDB]]></title>
    <url>%2F2020%2F04%2F15%2Fnodejs-mongodb-restfulapi%2F</url>
    <content type="text"><![CDATA[使用 Node.js 與 RESTful API 架構來串接 mongoDB 並部署到 server網站組成通常是前端加後端、資料庫，簡單來說，前端主要是畫面加上操作介面，包含了一些前端語言及框架，後端則處理使用者請求控制回應，例如登入，後台管理…等等，後端語言常見的有 PHP、Java、ASP.NET、Node.js、Python…等等。資料庫則有 MySQL、MSSQL、MongoDB…。 因前端不斷的演進，畫面處理需快速變化，傳送資料方式也大都改用 Web API 的方式來提供服務。所以後端(server)就負責建立 API，透過串接 API 處理資料。 這邊就要來使用 Node.js 搭配 express 架構 RESTful API，連接 MongoDB，並部署到 server。 MongoDB是開源的 NoSQL 資料庫，不需先制定每張資料表的結構、畫出 ER Model，因此不管是用來做個人專案，還是用來處理較大量資料都可以。 MongoDB 是用 Key-value 的方式來儲存資料： Code1234&#123; name: &quot;john&quot;, job: &quot;farmer&quot;&#125; 另外 MongoDB 不是 JSON 格式，而是 BSON。它的 key 和 value 是有區分大小寫。但 MongoDB 大都是用 JSON 格式來儲存資料。 ps.BSON(Binary JSON)，是 JSON 的擴充，因此可使用 Binary data 等。 MongoDB 跟傳統資料庫大致上對應的關係： DB MongoDB MySQL 資料名稱 Document Row 資料存放區名稱 Collection Table 資料庫名稱 Database Database RESTful APIREST(Resource Representational State Transfer 具象狀態變化傳輸)，API(Application Programming Interface 應用程式介面)。 RESTful API 可以理解成具有 Rest 架構的 Web API，是一種設計風格。意思大致上是，由發送的 HTTP 請求中所包含的資訊，就可以容易解讀出這請求會收到什麼類型的資料。用淺顯易懂的方式來解釋，就是只看 API 的格式就可以看得懂。 由於 API 設計方式跟 HTTP 請求及資料庫資料操作有關，因此就簡略說明一下： 常見的 HTTP 請求方式：GET：取得資料POST：新增一筆新的資料(如果存在會新增一筆新的)PUT：更新一筆資料，如果存在這筆資就會覆蓋過去PATCH：部分更新資料DELETE：刪除資料 資料庫基本操作 CRUD：Create(新增)Read(讀取)Update(更新)Delete(刪除) 常見的 HTTP method 正好會對應到資料庫基本操作。 假設有一組待辦事項的 API，或許會用以下方式來設計： 獲得資料GET /getData新增資料POST /createData刪除資料DELETE /deleteData/1 以 REST 風格來開發 RESTful API： 獲得資料GET /data新增資料POST /data刪除資料DELETE /data/1 兩者差異是在於 RESTful API 充分地使用了 HTTP Protocol Method，達到： 1.直觀簡潔的資源 URI2.並且善用 HTTP Verb3.達到對資源的操作4.並使用 Web 所接受的資料類型: JSON, XML, YAML 等，最常見的是 JSON。 前置工作1.建立 heroku 上的 mongoDB 資料庫 2.heroku 建立新 App 3.安裝 mlab 套件 要填寫信用卡資料(才能用 Add-ons) 首先到我們要安裝插件的應用程式頁面，點選「Configure Add-ons」 在搜尋列打上「mlab」，並安裝 4.建立使用者 5.記得連線 URL mlab 建立後，可在畫面上找到。 格式：&quot;mongodb://dbuser:dbpass@host1:port1,host2:port2/dbname&quot; 6. 接下來就是程式處理方面。 建立 nodejs server先建立專案資料夾 npm init npm install express --save 建立 index.js Code1234567891011121314// 引用 expressconst express = require(&apos;express&apos;);const server = express();// 預設 portconst port = process.env.PORT || 3000// 建立 get method 顯示 index.html 內容server.get(&apos;/&apos;, (req, res) =&gt; &#123; // __dirname 回傳被執行 js 檔所在資料夾的絕對路徑 res.sendFile(__dirname + &apos;/index.html&apos;)&#125;)// 監聽 portserver.listen(port, () =&gt; console.log(`Listening on $&#123;port&#125;`)) 建立 index.html Code1234567891011&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Welcome&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; package.json 加上 Code123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node index.js&quot; // 加此行 &#125;, 測試一下，終端機下執行 npm start，在瀏覽器網址輸入 http://localhost:3000/ 。看畫面是否成功出現 welcome 字樣。 連線 mongodb1.安裝 mongodb npm install mongodb --save index.js 加上以下內容： Code12345678910111213// 引用const MongoClient = require(&apos;mongodb&apos;).MongoClient;// mongoDB 連線位置(可看 heroku 的 mlab 頁面有資訊)const url = &apos;mongodb://&lt;username&gt;:&lt;password&gt;@&lt;host1&gt;:&lt;port1&gt;/&lt;dbName&gt;&apos;;// 連線 mongoDBMongoClient.connect(url, function (err, db) &#123; if (err) throw err; const dbo = db.db(&quot;&lt;dbName&gt;&quot;) console.log(&apos;mongoDB in running&apos;) db.close()&#125;); 測試一下，終端機下執行 npm start，終端機畫面上是否顯示 Listening on 3000 字樣。 若產生以下字樣 (node:39803) DeprecationWarning: current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor. 修改連線內容 Code12345678910// 連線 mongoDB// 加上以下設定//&#123; useNewUrlParser: true, useUnifiedTopology: true &#125;MongoClient.connect(url, &#123; useNewUrlParser: true, useUnifiedTopology: true &#125;, function (err, db) &#123; // 連線資料庫 const dbo = db.db(&quot;&lt;dbName&gt;&quot;) console.log(&apos;mongoDB in running&apos;) // 關閉連線 db.close()&#125;); MongoDB 加上一筆資料修改 index.js Code1234567891011121314151617// 連線 mongoDBMongoClient.connect(url, &#123; useNewUrlParser: true, useUnifiedTopology: true &#125;, function (err, db) &#123; if (err) throw err; // 連線資料庫 const dbo = db.db(&quot;&lt;dbName&gt;&quot;) // console.log(&apos;mongoDB in running&apos;) // // 關閉連線 // db.close() // 建立一筆資料 const myobj = &#123; name: &quot;jw&quot;, time: &quot;2020/04/14/15:00&quot;, content: &quot;hello world&quot; &#125;; // mongoDB 的操作方式 dbo.collection(&quot;comments&quot;).insertOne(myobj, function (err, res) &#123; if (err) throw err; console.log(&quot;1 document inserted&quot;); db.close(); &#125;);&#125;); 執行 npm start，畫面上會顯示 1 document inserted。 heroku 的 mlab 頁面上會有新增的資料。 Get API-取得資料index.js Code123456789//GET API 從 http://localhost:3000/comments 取得資料server.get(&apos;/comments&apos;, (req, res) =&gt; &#123; // 回傳 comments 的所有資料 db.collection(&apos;comments&apos;).find().toArray((err, result) =&gt; &#123; if (err) return console.log(err) // 顯示取得資料在頁面上 res.send(&#123; data: result &#125;) &#125;)&#125;) 終端機輸入 npm start，打開瀏覽器 http://localhost:3000/comments， 可以看到畫面顯示資料。 POST API-新增資料下載 body-parser 套件，來處理資料格式，將其轉型別成 JSON。 npm install body-parser --save index.js 加上 Code12345678910111213141516171819202122232425const bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.json());// POST API 路徑為/comments expressjs 取參數的方法之一 req.bodyserver.post(&apos;/comments&apos;, (req, res) =&gt; &#123; // 顯示 clinet 端傳送過來的 JSON console.log(req.body); db.collection(&apos;comments&apos;).save(req.body, (err, result) =&gt; &#123; if (err) return console.log(err) console.log(&apos;saved to database&apos;) res.send(req.body); &#125;);&#125;)// modify server.listen(3000, () =&gt; &#123;&#125;);/* 將之前的監聽 server.listen(port, () =&gt; console.log(`Listening on $&#123;port&#125;`)) 註解掉，改寫至 MongoClient.connect() 裡 */MongoClient.connect(url, &#123; useNewUrlParser: true, useUnifiedTopology: true &#125;, (err, client) =&gt; &#123; if (err) return console.log(err) db = client.db(&apos;&lt;dbName&gt;&apos;) server.listen(port, () =&gt; &#123; console.log(&apos;listening on 3000&apos;) &#125;)&#125;) 執行 npm start，打開瀏覽器輸入網址 localhost:3000，在 console 輸入： JavaSript fetch post Code1234567891011121314fetch(&apos;http://localhost:3000/comments&apos;, &#123; method: &apos;post&apos;, headers: &#123; &apos;Accept&apos;: &apos;application/json, text/plain, */*&apos;, &apos;Content-Type&apos;: &apos;application/json&apos; &#125;, // 傳給 server 的 JSON body: JSON.stringify(&#123; &quot;name&quot;: &quot;jw&quot;, &quot;time&quot;:&quot;2020/04/13-15:10:01&quot;, &quot;content&quot;: &quot;Hello&quot; &#125;)&#125;).then(res=&gt;res.json()) .then(res =&gt; console.log(res)) ps. 顯示 (node:3970) DeprecationWarning: collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead. 修改 save() 為提示中的函式 insertOne()…等等 DELETE API-刪除資料利用 網址:id 來帶參數，方便維運 API。若要使用 MongoDB 預設的 _id 當作查詢刪除，需要使用 ObjectID 處理來 value，但如果使用其他物件來作查詢，就不需使用 ObjectID。 index.js Code123456789101112131415161718const ObjectID = require(&apos;mongodb&apos;).ObjectID;// DELETE APIserver.delete(&apos;/comments/:id&apos;, (req, res) =&gt; &#123; // use _id need use ObjectID(value) const obj = &#123; _id: ObjectID(req.params.id) &#125;; // 顯示刪除 _id console.log(obj) if (!obj) &#123; res.sendStatus(403); &#125; db.collection(&quot;comments&quot;).deleteOne(obj, function (err, obj) &#123; if (err) throw err; console.log(&quot;1 document deleted&quot;); // 回傳訊息 res.send(&apos;delete success&apos;); &#125;);&#125;) ps. 顯示 (node:3826) DeprecationWarning: collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead. 修改 remove() 為提示中的函式 deleteOne()…等 PUT API-更新(UPDATE)資料用 updateOne(obj, newvalues, function(err, obj){}) 來更新資料，前面兩個參數分別帶查詢條件及更新資料。 index.js Code1234567891011121314server.put(&apos;/comments/:id&apos;, (req, res) =&gt; &#123; // 顯示 id 及 修改內容 console.log(req.params.id, req.body); if (!req.body) &#123; res.sendStatus(403); &#125; const newvalues = &#123; $set: req.body &#125;; const obj = &#123; _id: ObjectID(req.params.id) &#125;; db.collection(&quot;comments&quot;).updateOne(obj, newvalues, function (err, obj) &#123; if (err) throw err; console.log(&quot;1 document update&quot;); res.send(&apos;update success&apos;); &#125;);&#125;) 建立 config.json可以將連線字串、帳密…環境變數等，放在這再引用，方便修改管理。 config.json Code123&#123; &quot;DB_URL&quot; : &quot;&quot;mongodb://dbuser:dbpass@host1:port1,host2:port2/dbname&quot;&quot;&#125; index.js 加上 const { DB_URL: url } = require(&#39;./config.json&#39;); postman 測試處理完 RESTful API 部分後，可以使用 postman 來測試。 GET % asset_img postman_get.png This is an image %} POST(記得依照標頭輸入設定來調整) PUT(記得依照標頭輸入設定來調整) DELETE 部署到 Heroku部署到 server 上，可方便使用 API。 終端機輸入： heroku config set Code1$ heroku config:set PROD_MONGODB=mongodb://dbuser:dbpass@host1:port1,host2:port2/dbname 2.登入 heroku heroku login 3.建立 GIT git initgit add .git commit -m &quot;nodejs&quot; 4.設定連結的 heroku 遠端主機 heroku git:remote -a (Heroku 上 的 App 名稱) 5.push remote git push heroku master heroku open 打開瀏覽器，輸入 heroku 的 app 路徑加上 /comments。 接著處理前端及畫面互動就可以做其他運用了。 參考：https://iandays.com/2018/10/11/nodejsapi/https://blog.johlmike.com/2016/08/05/heroku-cha-jian-mlab-mongodb-zi-liao-ku/https://blog.johlmike.com/2016/07/12/mongoose-node-js-上連接-mongodb/#more-453https://ithelp.ithome.com.tw/articles/10186483https://dotblogs.com.tw/felixblog/2019/12/11/171324https://medium.com/%E4%BC%81%E9%B5%9D%E4%B9%9F%E6%87%82%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/express-restfulapi%E8%B5%B7%E6%89%8B%E6%95%99%E5%AD%B83-77206cd64ebbhttps://i5ting.github.io/node-http/https://progressbar.tw/posts/53https://medium.com/itsems-frontend/api-是什麼-restful-api-又是什麼-a001a85ab638https://ithelp.ithome.com.tw/articles/10157431https://ithelp.ithome.com.tw/articles/10157674https://noob.tw/mongodb/]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>MongoDB</tag>
        <tag>RESTful</tag>
        <tag>heroku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postman 好用 API 測試工具]]></title>
    <url>%2F2020%2F04%2F14%2Fpostman%2F</url>
    <content type="text"><![CDATA[Postman模擬 HTTP Request 來測試 API 的好用工具，包含幾種 HTTP 請求方式： GET 、POST、PUT、DELETE。 安裝安裝版下載網址https://www.postman.com/downloads/ Chrome 線上應用程式https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=zh-TW 可以選擇註冊於否，皆可正常使用。 畫面基本使用欄位 Headers設定請求中的內容是使用何種編碼方式，包含了 Key 和 Value 两部分。 Key：大都使用 Content-TypeValue：application/x-www-form-urlencoded：瀏覽器的 form，就是在 url 後面加上 key=val。 multipart/form-data：加上 enctype 屬性，送出訊息後會用 boundary 分割不同的字段，後面再接要送出的欄位與值。 application/json：JSON 格式。{ “name”: “john”} Method 使用GET取得資料 POST新增資料（如果存在會再新增一筆新的，以資料庫來說，就是ID不一樣。) headers 設定傳送資料編碼方式 PUT更新一筆資料，如果資料存在就會覆蓋過去 使用方式，跟 POST 差不多。把 method 選擇 PUT ，Body 輸入資料即可。 DELETE刪除資料 PATCH針對已經存在的資料欄位去做部分更新 參考：https://ithelp.ithome.com.tw/articles/10201503https://ithelp.ithome.com.tw/articles/10201528https://progressbar.tw/posts/53]]></content>
      <categories>
        <category>API</category>
      </categories>
      <tags>
        <tag>postman</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket 介紹]]></title>
    <url>%2F2020%2F04%2F09%2FWebSocket-base%2F</url>
    <content type="text"><![CDATA[WebSocket 介紹WebSocket 是網路協定的一種，只需要連線一次。Client 與 Server 便能保持連線進行雙向傳輸溝通，不必一直發送 Request 保持溝通。 請求網址通常是： ws://example.com //SSL 加密後 wss://example.com 以下開始建立 WebSocket 連線測試，分別建立 Server 跟 Client 端。 Server 端建立連接環境使用 node.js 來寫後端程式。安裝好 node.js 後，建立專案資料夾後執行： npm init 然後下載兩個套件來使用: // Web 框架 npm install express --save // 處理 WebSocket 協定 npm install ws --save 新增一個 server.js 檔，內容如下： Code12345678910111213141516171819202122232425//import express 和 ws 套件const express = require(&apos;express&apos;)const SocketServer = require(&apos;ws&apos;).Server//指定開啟的 portconst PORT = process.env.PORT || 3000//建立 express 的物件，並監聽 3000 port ，開啟後在 console 中提示const server = express() .listen(PORT, () =&gt; console.log(`Listening on $&#123;PORT&#125;`))//將 express 交給 SocketServer 開啟 WebSocket 的服務const wss = new SocketServer(&#123; server &#125;)//當 WebSocket 從外部連結時執行wss.on(&apos;connection&apos;, ws =&gt; &#123; //連結時執行此 console 提示 console.log(&apos;Client connected&apos;) //當 WebSocket 的連線關閉時執行 ws.on(&apos;close&apos;, () =&gt; &#123; console.log(&apos;Close connected&apos;) &#125;)&#125;) 執行 server.js 檔。測試檔案是否 ok。cmd 環境專案資料夾下輸入： node server.js 若成功開啟，console 會出現提示 Listening on 3000 ps. 注意 package.json 裡的 “main”: “server.js”, 接收發送訊息(接收 Clinet 訊息處理後回傳)開啟 WebSocket 後， Server 端使用 send 發送訊息，接收則是如同在 connection 內監聽 close 一樣，只是加入對 message 設定監聽，並接收一個參數 data(Client 端發送的訊息)： Code12345678910111213wss.on(&apos;connection&apos;, ws =&gt; &#123; console.log(&apos;Client connected&apos;) //對 message 設定監聽，接收從 Client 發送的訊息 ws.on(&apos;message&apos;, data =&gt; &#123; //data 為 Client 發送的訊息，現在將訊息原封不動發送出去 ws.send(data) &#125;) ws.on(&apos;close&apos;, () =&gt; &#123; console.log(&apos;Close connected&apos;) &#125;)&#125;) Server 端直接發送資料給 Clinet 端(用 setInterval )// setInterval() 則是固定延遲了某段時間之後，才去執行對應的程式碼，然後 “不斷循環”。 發送訊息改寫： Code123456789101112131415161718wss.on(&apos;connection&apos;, ws =&gt; &#123; console.log(&apos;Client connected&apos;) //固定送最新時間給 Client const sendNowTime = setInterval(()=&gt;&#123; ws.send(String(new Date())) &#125;,1000) ws.on(&apos;message&apos;, data =&gt; &#123; ws.send(data) &#125;) ws.on(&apos;close&apos;, () =&gt; &#123; //連線中斷時停止 setInterval clearInterval(sendNowTime) console.log(&apos;Close connected&apos;) &#125;)&#125;) 多人連線環境( ws 套件使用 clients )當某個 Client 發送訊息時，同時讓 Server 告知所有其他連接中的 Client，Server 所收到的訊息，也同時接收到 Server 回傳的資料。類似廣播功能。 改寫監聽 message 部分， 加入 Clients 發送的訊息 Code12345678910111213141516171819wss.on(&apos;connection&apos;, ws =&gt; &#123; console.log(&apos;Client connected&apos;) ws.on(&apos;message&apos;, data =&gt; &#123; //取得所有連接中的 client let clients = wss.clients //做迴圈，發送訊息至每個 client clients.forEach(client =&gt; &#123; client.send(data) //傳送時間 //client.send(new Date().toTimeString()); &#125;) &#125;) ws.on(&apos;close&apos;, () =&gt; &#123; console.log(&apos;Close connected&apos;) &#125;)&#125;) Client 端建立連接環境新增一個專案資料夾，新增 index.js，內容如下： Code123456789101112//使用 WebSocket 網址連結 Serverlet ws = new WebSocket(&apos;ws://localhost:3000&apos;)//開啟後執行的動作，指定一個 function 會在連結 WebSocket 後執行ws.onopen = () =&gt; &#123; console.log(&apos;open connection&apos;)&#125;//關閉後執行的動作，指定一個 function 會在連結中斷後執行ws.onclose = () =&gt; &#123; console.log(&apos;close connection&apos;)&#125; 接著新增 index.html，內容如下： Code123456// 引用 index.js&lt;html&gt; &lt;body&gt; &lt;script src=&apos;./index.js&apos;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 接收發送訊息( Client 發送訊息給 Server 處理後得到回傳資料)Client 端用 onmessage 處理接收，用 send 送出訊息： Code1234567891011121314let ws = new WebSocket(&apos;ws://localhost:3000&apos;)ws.onopen = () =&gt; &#123; console.log(&apos;open connection&apos;)&#125;ws.onclose = () =&gt; &#123; console.log(&apos;close connection&apos;)&#125;//接收 Server 發送的訊息，Server 回傳的資料會在 event 的 data 屬性ws.onmessage = event =&gt; &#123; console.log(event)&#125; 測試連結是否成功server 端訊息(cmd 環境下) 用瀏覽器開啟 index.html，連結 server 端。打開 console，會顯示 open connection 字樣，輸入 ws 看訊息。 列出 WebSocket 的物件有哪些屬性， Client 是用 onmessage 屬性接收由 Server 發送的資料。 server 端接收訊息後，是否回傳雙向連線環境建立完後，開啟瀏覽器 index.html 。然後在 console 環境中，輸入 ws.send(&#39;hello&#39;)，來測試。Server 是否有接收到資料(console 環境內看)。 將 WebSocket 部署至 Heroku利用 Git 的方式上傳至 Heroku Heroku 註冊並開啟新 app註冊網址 註冊後登入，從右上 New 選單中， Create new app 建立。 安裝 Heroku CLIHeroku CLI 到上面網站，依照本身電腦系統下載後安裝。 建立 Git 環境切換到要上傳的專案資料夾下，輸入以下指令： // 初始化資料夾 git init // 打包檔案 git add . // 寫註解 git commit -m &quot;upload&quot; // 登入 Heroku，開啟登入頁面，輸入帳密 heroku login // 設定連結的 heroku 遠端主機heroku git:remote -a (Heroku 上 的 App 名稱) e.g. heroku git:remote -a xxx // 上傳至 heroku git push heroku master 上傳前程式調整(上述的範例)package.jsonCode12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, // 加上此行，node 後面要對應 main 屬性的值 &quot;start&quot;: &quot;node server.js&quot;&#125;, server.js頁面加上 WebSocket test!! 字樣 Code12345678910111213141516171819202122232425262728293031加上//引用&apos;http&apos;模組const http = require(&apos;http&apos;);// 建立一個server並指定他的頁面資訊，並監聽 port ，開啟後在 console 中提示const server = http.createServer((req, res) =&gt; &#123; // 進入網站首頁顯示 index if (req.url == &apos;/&apos;) &#123; // 設定 response header res.writeHead(200, &#123; &apos;Context-Type&apos;: &apos;text/html&apos; &#125;); // 回應內容 res.write(&apos;&lt;h1&gt;WebSocket test!!&lt;/h1&gt;&apos;); // 送出 response res.end(); // 不是的話顯示 404 例如 /abc/ &#125; else &#123; res.writeHead(200, &#123; &apos;Context-Type&apos;: &apos;text/html&apos; &#125;); res.write(&apos;&lt;h1&gt;404&lt;/h1&gt;&apos;); res.end(); &#125;&#125;).listen(PORT, () =&gt; console.log(`Listening on $&#123;PORT&#125;`))// 註解以下程式// 建立 express 的物件，並監聽 port ，開啟後在 console 中提示// const server = express().listen(PORT, () =&gt; console.log(`Listening on $&#123;PORT&#125;`)) index.js將原本連結的網址調整成 Heroku 給的網站 let ws = new WebSocket(&#39;ws://appname.herokuapp.com/&#39;) 然後在瀏覽器開啟 index.html，打開 console。看是否有 open connection 字樣，確認是否成功。 ps:因為 WebSocket 只連線一次就可以雙向傳輸，因此開發人員工具的 Network 看不到 Request 的資料，但是傳遞過程可以透過第一次要求連接時的 Request 中觀察。 關於 WebSocket 傳送資料時，除了字串外還可以使用 USVString、ArrayBuffer、Blod、ArrayBufferView …，另外傳送 JSON 時，記得在 send 中做 JSON.stringify ，接收到時再用 JSON.parse 轉成物件處理。 參考：Heroku | 搭配 Git 在 Heroku 上部署網站的手把手教學JavaScript | WebSocket 讓前後端沒有距離https://www.npmjs.com/package/ws六角學院課程]]></content>
      <categories>
        <category>WebSocket</category>
        <category>Heroku</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>Heroku</tag>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hamburger_menu 介紹]]></title>
    <url>%2F2020%2F03%2F26%2Fhamburger-menu%2F</url>
    <content type="text"><![CDATA[hamburger_menu 漢堡式選單常運用在小尺寸螢幕的機器上，可以保持畫面簡單、選單設計彈性等等優點。 但有時會產生操作上的問題，例如不夠直覺、操作麻煩等問題。應該依照實際情況跟頁籤式選單交互或配合使用。 這裏介紹一下，如何實作漢堡式選單。這裡是將選單列或導覽列切換成漢堡式選單，固定在畫面左上角，可以依照情況調整。 首先處理 HTML 部分 Code1234567891011121314&lt;body&gt; &lt;!--選單--&gt;&lt;ul class=&quot;menu-s&quot;&gt; &lt;li&gt;&lt;a href=&quot;#profile&quot;&gt;profile&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#resume&quot;&gt;resume&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#skill&quot;&gt;skills&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#portfolio&quot;&gt;portfolio&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;contact&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--圖示--&gt;&lt;a href=&quot;#&quot; class=&quot;showmenu&quot;&gt; menu&lt;/a&gt;&lt;/body&gt; 接著是 CSS Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 漢堡選單// 圖示，一開始隱藏 display: none;.showmenu &#123; color: #69CA62; display: none; width: 50px; height: 50px; position: fixed; top: 30px; left: 25px; // 置於其他元素上 z-index: 9; cursor: pointer; .fa-bars &#123; font-size: 35px; &#125;&#125;// 選單.menu-s &#123; position: fixed; // display: none; width: 100%; // border-bottom: 1px solid #777; // padding: 10px 20px; text-transform: uppercase; // background-color: rgba(255, 255, 255, 0.8); // 置於其他元素上 z-index: 9; list-style-type: none; li &#123; line-height: 2em; &#125; a &#123; color: #69CA62; text-decoration: none; &#125;&#125;// 當螢幕尺寸小於 768px 時@media (max-width: 768px) &#123; .menu-s &#123; /* 選單出現*/ display: block; /*隱藏選單開始*/ max-height: 0px; overflow: hidden; /*隱藏選單結束*/ transition: max-height 2.3s; margin-top: 1px; /*絕對定位疊在網頁上*/ position: fixed; z-index: 9; /*header 80px+1px boder 線條*/ top: 81px; left: 0; right: 0; // background: #69CA62; &#125; // .menu-s li&#123; // border-bottom: 1px dashed #69CA62; // &#125; .menu-s li a&#123; transition: all 0.2s; &#125; .menu-s li a:hover&#123; background: gray; color: #fff; &#125; // 顯示圖示 .showmenu&#123; display: block; float: right; margin: 1em; &#125; /*jQ點擊後動態在 body 加上 class 影響選單高度*/ .menu-show .menu-s &#123; max-height: 500px &#125;&#125; 最後是 jQuery Code123456789$(document).ready(function () &#123; $(&apos;.showmenu&apos;).on(&apos;click&apos;, function (e) &#123; // 讓原來 &lt;a&gt; 效果失效 e.preventDefault(); $(&apos;body&apos;).toggleClass(&apos;menu-show&apos;); &#125;);&#125;);/* toggleClass()可以用來為匹配的元素進行新增或是刪除CSS類別。實際運作時有點類似開關一樣。如果某個類別存在，那就刪除他，若是不存在那就新增。 */ 以上是程式碼部分，下列網址是 demo。 https://codepen.io/jw103/pen/xxGQPOZ?editors=1111 另外也可以使用 Bootstrap 4 的模板來做。 參考：https://a-cart.com.tw/blog/blog_detail/204https://w3c.hexschool.com/blog/5054d6fe]]></content>
      <categories>
        <category>JavaSricpt</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>hamburger_menu</tag>
        <tag>JavaSricpt</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base64 轉檔加快圖片載入]]></title>
    <url>%2F2020%2F03%2F19%2Fbase64image%2F</url>
    <content type="text"><![CDATA[base64可將圖片轉成字串形式再引用，以加快網頁載入速度。適合容量較小的圖檔。 轉檔網站： https://www.base64-image.de 將圖片拖曳網頁上或是選取圖片檔案，轉檔後。按下 show code 按鈕，會顯示引用方式。即可引用。 參考：https://cythilya.github.io/2018/07/26/base64-images/https://sofree.cc/base64-images/]]></content>
      <tags>
        <tag>image</tag>
        <tag>efficacy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[簡單介紹 maskmap 查詢網站]]></title>
    <url>%2F2020%2F02%2F21%2Fmaskmap%2F</url>
    <content type="text"><![CDATA[簡單介紹口罩查詢地圖製作因為看到網路上有相關網站製作的教學，就試著做了一個簡易的查詢網站。 建立模板是使用教學提供的，沒有做什麼變動。使用 vue create 來建立專案 Vue CLI 4.2使用 vue create 來建立專案 套件leafletjs用來建立免費地圖 OSM 的地標資訊 npm install --save leaflet 記得載入 css 樣式 Code1234567&lt;link rel=&apos;stylesheet&apos; href=&apos;https://unpkg.com/leaflet@1.5.1/dist/leaflet.css&apos;&gt;or&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.6.0/dist/leaflet.css&quot; integrity=&quot;sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==&quot; crossorigin=&quot;&quot;/&gt; 載入套件 在要使用的檔案 &lt;script&gt;&lt;/script&gt; 標籤內 import L from &#39;leaflet&#39; bootstrap處理 css 樣式 npm install --save bootstrap@4.0.0-beta.3 安裝完後檔案路徑node_modules/bootstrap/scss/bootstrap 載入套件 在要使用的檔案 &lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 標籤內 @import &#39;bootstrap/scss/bootstrap&#39;; axios vue-axios處理 ajax 及 API 資料部分 npm install --save axios vue-axios 載入 在 main.js 加入 Code1234import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos; Vue.use(VueAxios, axios) jQuerynpm install — save jquery popper.js 載入 在要使用的檔案 &lt;script&gt;&lt;/script&gt; 標籤內 import $ from &quot;jquery&quot;; webpack 中設定必須要在 webpack 執行時就去載入 jQuery ，修改./build/webpack.base.conf.js，加入以下程式碼： Code12345678910111213var webpack = require(&apos;webpack&apos;)接著在同一份檔案當中加入plugin設定module.exports = &#123; entry: &#123;&#125;, output: &#123;&#125;, resolve: &#123;&#125;, module: &#123;&#125;, plugins: [new webpack.ProvidePlugin(&#123; jQuery: &apos;jquery&apos;, $: &apos;jquery&apos;, jquery: &apos;jquery&apos;&#125;)]&#125; 台灣縣市鄉鎮 JSON以下網址可下載台灣縣市鄉鎮資訊 https://github.com/donma/TaiwanAddressCityAreaRoadChineseEnglishJSON 載入 在檔案的 &lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 標籤內，加上 import cityName from &#39;./assets/CityCountyData.json&#39; 藥局資訊 APIhttps://raw.githubusercontent.com/kiang/pharmacies/master/json/points.json leafletjs 基本操作建立地圖、圖標、訊息…等等Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;div class=&quot;col-sm-9&quot;&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;// 載入 leaflet 套件import L from &apos;leaflet&apos;export default &#123; name: &apos;home&apos;, data: () =&gt; (&#123; osmMap: &#123;&#125;, &#125; &#125;),mounted () &#123;// 新增並顯示地圖this.osmMap = L.map(&apos;map&apos;, &#123; center: [25.03, 121.55], zoom: 15 &#125;)// 載入圖層到地圖(不然地圖會是空白) L.tileLayer(urlTemplate, options).addTo(map) L.tileLayer(&apos;https://&#123;s&#125;.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png?&#123;foo&#125;&apos;, &#123; foo: &apos;bar&apos;, attribution: &apos;Map data &amp;copy; &lt;a href=&quot;https://www.openstreetmap.org/&quot;&gt;OpenStreetMap&lt;/a&gt; contributors, &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/2.0/&quot;&gt;CC-BY-SA&lt;/a&gt;&apos;, maxZoom: 18 &#125;).addTo(this.osmMap) // 加上圖標 // L.marker([25.0085455, 121.4594333]).addTo(this.osmMap) // 加上圖標與訊息 // L.marker([ // geometry.coordinates[1], // geometry.coordinates[0] // ]).addTo(this.osmMap).bindPopup( // `&lt;strong&gt;$&#123;properties.name&#125;&lt;/strong&gt; &lt;br&gt; // 口罩剩餘：&lt;strong&gt;成人 - $&#123;properties.mask_adult ? `$&#123;properties.mask_adult&#125; 個` : &apos;未取得資料&apos;&#125;/ 兒童 - $&#123;properties.mask_child ? `$&#123;properties.mask_child&#125; 個` : &apos;未取得資料&apos;&#125;&lt;/strong&gt;&lt;br&gt; // 地址: &lt;a href=&quot;https://www.google.com.tw/maps/place/$&#123;properties.address&#125;&quot; target=&quot;_blank&quot;&gt;$&#123;properties.address&#125;&lt;/a&gt;&lt;br&gt; // 電話: $&#123;properties.phone&#125;&lt;br&gt; // &lt;small&gt;最後更新時間: $&#123;properties.updated&#125;&lt;/small&gt;`, &#123; closeOnClick: false &#125;).openPopup() // 多邊形 // L.polygon([ // [22.992, 120.289], // [22.982, 120.299], // [22.970, 120.267], // [22.990, 120.267] // ]).addTo(this.osmMap) // 圓形 // L.circle( // [22.988, 120.220], // 圓心座標 // 1000, // 半徑（公尺） // &#123; // color: &apos;red&apos;, // 線條顏色 // fillColor: &apos;#f03&apos;, // 填充顏色 // fillOpacity: 0.5 // 透明度 // &#125; // ).addTo(this.osmMap) // 獨立訊息 // L.popup() // .setLatLng([23.010, 120.289]) // .setContent(&apos;獨立的訊息方塊。&apos;) // .openOn(this.osmMap) // 連接到指定點 //this.osmMap.panTo([geometry.coordinates[1], geometry.coordinates[0]]); &#125;&lt;/script&gt; 刪除地標OSM 是以圖層的概念來組成，地標會以圖層類型累加，因此地標數量過多會影響效能。所以在切換查詢地點時，最好要清除其他不需要顯示的地標。 Code1234567removeMarker () &#123; this.osmMap.eachLayer((layer) =&gt; &#123; if (layer instanceof L.Marker) &#123; this.osmMap.removeLayer(layer) &#125; &#125;) &#125;, 改變地標樣式Code1234567891011121314const greenIcon = L.icon(&#123; iconUrl: &apos;https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png&apos;, iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowUrl: &apos;https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png&apos;, shadowSize: [41, 41], shadowAnchor: [12, 41] &#125;) const &#123; properties, geometry &#125; = item L.marker([ geometry.coordinates[1], geometry.coordinates[0] ], &#123; icon: greenIcon &#125;).addTo(this.osmMap) 其他程式載入藥局資訊Code12345const api = &apos;https://raw.githubusercontent.com/kiang/pharmacies/master/json/points.json&apos; this.$http.get(api).then((Response) =&gt; &#123; // console.log(Response) this.data = Response.data.features &#125;) 其他程式碼部分可參考 https://github.com/Wcc723/wheremask 個人實作網站(有做小地方調整)https://jw310.github.io/maskmap/#/ 參考：https://www.openstreetmap.org/https://leafletjs.com/https://leafletjs.com/examples/quick-start/https://blog.gtwang.org/web-development/leaflet-open-source-javascript-library-for-mobile-friendly-interactive-maps/https://www.youtube.com/watch?v=pUizu62dlnYhttps://www.youtube.com/watch?v=7CXnNMVMXeo&amp;t=2s六角學院]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>Leafletjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM 介紹]]></title>
    <url>%2F2020%2F02%2F03%2FNPM%2F</url>
    <content type="text"><![CDATA[NPMnpm（全稱 Node Package Manager，即「node包管理器」）是Node.js 預設的、以 JavaScript 編寫的軟體套件管理系統。 專案使用 npm到專案資料夾下，輸入以下指令 $npm init 會新增 package.json 檔案紀錄套件安裝情況。 安裝套件 $sudo npm install express —save ps. mac 有時要加 sudo 指令npm -v ：觀看 NPM 版本 npm init ：新增 package.json npm install [模組名稱][參數]：安裝 NPM 模組，會根據 package.json 去下載安裝套件，放在 node_modules 資料夾。 安裝位置常用屬性如下： -g：全域安裝，安裝資料夾位置 /usr/local/lib/node_modules。 –save：安裝模組及紀錄在 package.json 的 “dependencies” 中，並產生 node_modules 資料夾。 –save-dev：安裝模組並寫入 package.json 的“devDependencies”。 npm start(npm run start)：執行 package.json 裡的 scripts 中的 start 指令(express)。 npm list：顯示安裝的 NPM 列表。 npm uninstall [模組名稱]：刪除專案裡的 NPM。 版本號編碼 1.12.0 -1 主要版本號 -12 次要版本號 -0 bug 修正 推薦套件nodemon 套件：它會監視你的程式碼有無的任何更改並自動重新啟動服務，這時只要刷新你的瀏覽器就能看到改動，此外 nodemon 使用 npm 進行安裝，只需使用 nodemon 取代 node 執行你的程式碼，就能輕鬆的開發 node.js。 npm install nodemon -g 安裝於專案資料夾中 npm install --save-dev nodemon // 執行，網頁重新整理就會立即看出結果 nodemon index.js 補充clone 別人的專案後，發現 package.json 有dependencies NPM 列表，但沒有 node_modules 資料夾時，該下什麼指令來安裝該專案的 NPM 列表？ npm install 參考：https://medium.com/az-下筆記/webpack-前端打包工具-1-前置-c9380f688c1bhttps://tw.alphacamp.co/blog/npm-node-package-managerhttps://medium.com/@hugh_Program_learning_diary_Js/javascript-進階-npm-abf96671c915]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nodejs 簡單介紹]]></title>
    <url>%2F2020%2F01%2F21%2Fnodejs-base%2F</url>
    <content type="text"><![CDATA[Node.js 簡單介紹能夠在伺服器端運行 JavaScript 的開放原始碼、跨平台 JavaScript 執行環境。用 Google 的 v8 引擎開發。 安裝到以下網站按照自己的作業系統下載，安裝 https://nodejs.org/en/download/ 要確認是否安裝成功的話，到終端機或命令提示字元下輸入 node –version看是否有顯示安裝版本。 modulemodule 是一些由 Javascript 編寫而成的功能集合, 它分別放在不同的 Javascript 檔案，可被匯入、應用。 分為三大類 1.Core Modules (原生模組)2.Local Modules (自建模組)3.Third Party Modules (第三方模組) 常用原生模組有：http：建立並使用 http server 的一些類別，方法，及事件。url：解析 url 的方法。querystring：處理由 client 端傳來 querystring 的方法。path：處理檔案或資料夾路徑的方法。fs：檔案的存取及操作的類別，方法及事件。util：提供程序者使用的效能函式。 自建模組基本上一個 Javascript 檔就是一個模組。 Code1234567let data = 2;module.exports = data; // 要載入的資料// 也可提供物件型態module.exports = &#123; a: 2; &#125; 如何載入const module = require(&#39;module_name&#39;); e.g. Code123456const http = require(&apos;http&apos;); let server = http.createServer(function(req, res)&#123; // ...&#125;); server.listen(8080); 載入其他自建模組 有兩個 js 檔，分別為 app 及 data。由 app.js 載入 data.js 的 data。 Code123456app.jsconst content = require(&apos;./data&apos;) // 載入模組同層下的 jslet a = 1;console.log(a);console.log(content); Code12345data.jslet data = 2;module.exports = data; // 要載入的資料 另一種模組呼叫方式(不能跟 module.exports 混用，module.exports 會覆寫 exports 的東西)。 Code123456app.jsvar content = require(&apos;./data&apos;) // 載入模組同層下的 jsvar a = 1;console.log(a);console.log(content); Code123456data.jsexports.data = 2;exports.bark = function() &#123; return &apos;bark!!&apos; &#125; node.js 核心模組 http 使用Code1234567const http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; // 開啟 web 伺服器 response.writeHead(200, &#123; &quot;context-Type&quot;: &quot;text/plain&quot;&#125;); response.write(&apos;hello&apos;); response.end(); console.log(request.url) // 可以撈到使用者造訪的網站的網址&#125;).listen(8080); node.js 核心模組 path 使用Code1234567891011121314const path = require(&apos;path&apos;);// 抓目錄路徑console.log(path.dirname(&apos;xx/yy/zz.js&apos;)) // xx/yy// 路徑合併console.log(path.join(__driname,’/xx’)); // 將檔案路徑跟 /xx 合併// 抓檔名console.log(path.basename(&apos;xx/yy/zz.js&apos;)); // zz.js// 抓副檔名console.log(path.extname(&apos;xx/yy/zz.js&apos;)); // .js// 分析路徑console.log(path.parse(&apos;xx/yy/zz.js&apos;)); // &#123; root: &apos;/&apos;, dir: &apos;/xx/yy&apos;, base: &apos;zz.js&apos; ext: &apos;.js&apos; name: &apos;zz&apos;&#125;__dirname // 取得當下資料夾的目錄__filename // 取得當下資料的檔名 node.js 核心模組 fs 使用非同步讀取fs.readFile(fileName [,options], callback) fileName: 檔案的完整路徑及檔名，格式字串。options: options 可能是一個物件或字串，包含”編碼”及”flag”。這裡預設的編碼是 utf8 , flag 是 “r”。可不加。call back: 是帶兩個參數的 function，err 及 file data，當我們執行 readFile 完成時, 要做的事, 例如: 回傳 file data。 e.g. test.txt Code1Hello! app.js Code123456const fs = require(&apos;fs&apos;); fs.readFile(&apos;test.txt&apos;, function (err, data) &#123; if (err) throw err; console.log(data.toString());&#125;); 同步讀取檔案Code123const fs = require(&apos;fs&apos;); let data = fs.readFileSync(&apos;test.txt&apos;, &apos;utf8&apos;);console.log(data); 寫入檔案如果檔案存在，會覆寫原本檔案資料；否則會自動新增檔案並寫入資料。 fs.writeFile(filename, data[, options], callback) fileName: 檔案的完整路徑及檔名，格式字串。data: 要寫入的檔案內容。options: options 可能是一個物件或字串，包含”編碼”及”flag”。這裡預設的編碼是 utf8 , flag是 “w”。call back: 只帶一個錯誤參數err的function，當我們執行writeFile完成時, 要做的事。例如: 寫入成功的訊息顯示；失敗時，丟出err。 Code12345678const fs = require(&apos;fs&apos;); fs.writeFile(&apos;test.txt&apos;, &apos;您好嗎?&apos;, function (err) &#123; if (err) console.log(err); else console.log(&apos;Write operation complete.&apos;);&#125;); 新增內容Code12345678const fs = require(&apos;fs&apos;); fs.appendFile(&apos;test.txt&apos;, &apos;我很好！&apos;, function (err) &#123; if (err) console.log(err); else console.log(&apos;Append operation complete.&apos;);&#125;); 開啟檔案fs.open(path, flags[, mode], callback) path: 檔案的完整路徑及檔名，格式字串。flag: 用 flag 代表操作行為。mode: mode 代表文件的權限，預設為 0666 代表可讀可寫。call back: 是帶兩個參數的function，err及file data，當我們執行open完成時, 要做的事, 例如: 打開成功的訊息顯示；失敗時，丟出err。 Code123456const fs = require(&apos;fs&apos;); fs.open(&apos;test.txt&apos;, &apos;r+&apos;, function (err,fd) &#123; if (err) throw err; console.log(&apos;success!&apos;);&#125;); 開啟時讀取fs.read(fd, buffer, offset, length, position, callback) fd: 透過 fs.open() 方法返回的文件描述符。buffer: 數據寫入的緩衝區。offset: 緩衝區寫入的寫入偏移量。length: 要從文件中讀取的字元數。position: 文件讀取的起始位置，如果 position 的值為null，則會從當前文件游標的位置讀取。callback: 回呼函式，有三個參數err, bytesRead, buffer。err 為錯誤訊息， bytesRead 表示讀取的字元數，buffer 為緩衝區對象。 Code1234567891011121314151617181920212223242526const fs = require(&apos;fs&apos;); fs.open(&apos;test.txt&apos;, &apos;r&apos;, function (err, fd) &#123; if (err) &#123; return console.error(err); &#125; let buffr = new Buffer(1024); fs.read(fd, buffr, 0, buffr.length, 0, function (err, bytes) &#123; if (err) throw err; // Print only read bytes to avoid junk. if (bytes &gt; 0) &#123; console.log(bytes+&quot; 字元被讀取&quot;); console.log(buffr.slice(0, bytes).toString()); &#125; // Close the opened file. fs.close(fd, function (err) &#123; if (err) throw err; &#125;); &#125;);&#125;); 刪除檔案fs.unlink(path, callback); path: 檔案路徑。callback: 只帶一個錯誤參數err的function，當我們執行unlink完成時, 要做的事。例如: 刪除成功的訊息顯示；失敗時，丟出err。 Code12345const fs = require(&apos;fs&apos;); fs.unlink(&apos;test.txt&apos;, function () &#123; console.log(&apos;已經刪除檔案!&apos;);&#125;); 網址規則 router 路由https://www.google.com/search?q=google&amp;oq=google&amp;aqs=chrome..69i57j0l2j69i60l3.6463j0j7&amp;sourceid=chrome&amp;ie=UTF-8 http：網路協定、https 加密協定www(子網域):根據服務不同來設定不同的。例 mail、cloud 之類。domain(主網域)：google.com路徑：/search，用「/」作為層級或不同目錄的區隔，可能包含目錄、頁面或檔案名稱?：以「?」為開頭與前面的部分分開，後面的內容稱為參數。彼此之間不具階層關係。參數(query)：q，參數之間以「&amp;」分隔，參數名稱與值之間再以「=」分開。 Web 應用框架(處理底層問題): express整合 資料庫—firebase—mongo—mysql 安裝npm initnpm install express —save 開啟 Web 伺服器建立一個 app.js 檔 Code12345678910111213141516cosnt express = require(&apos;express&apos;); // 載入模組const app = express(); // 取得功能app.get(&apos;/&apos;,function(req, res)&#123; // 首頁 //res.send(&apos;1234&apos;); res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hi!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;)&#125;)app.get(&apos;/user&apos;,function(req, res)&#123; // user 頁面 //res.send(&apos;1234&apos;); res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;2&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;)&#125;)// 監聽var port = process.env.PORT || 3000; app.listen(port); 路由設計Code123456789app.get(&apos;/user/edit-profile&apos;,function(req,res)&#123; // res.send(&apos;1234&apos;); res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;profile&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;)&#125;)app.get(&apos;/user/edit-photo&apos;,function(req,res)&#123; // res.send(&apos;1234&apos;); res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;photo&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;)&#125;) 取得指定路徑 params (物件資料)Code12345678910111213141516171819202122232425var express = require(&apos;express&apos;);var app = express();app.get(&apos;/user/:name/&apos;,function(req,res)&#123; // :name 取得 name 資料(隨機輸入) var myName = req.params.name;//app.get(&apos;/user/:name/:data&apos;,function(req,res)&#123; // 輸入 user/tom/1081024 // 回傳 &#123;name: &apos;1234&apos;, data: ’1081024&apos;&#125;//var myName = req.params; console.log(myName); if(myName !== &apos;tom&apos;)&#123; res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&apos;+&apos;查無此人&apos;+&apos;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;) // 網頁輸出 &#125;else&#123; res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&apos;+myName+&apos;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;) &#125; &#125;)app.get(&apos;/user/edit-photo&apos;,function(req,res)&#123; // res.send(&apos;1234&apos;); res.send(&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;photo&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;)&#125;)// 監聽 portvar port = process.env.PORT || 3000;app.listen(port); 參考：Node.JS - 30 天入門學習筆記系列六角學院課程]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 介紹]]></title>
    <url>%2F2020%2F01%2F16%2Fwebpack-base%2F</url>
    <content type="text"><![CDATA[webpackwebpack 在處理整個專案時，它會在內部建立一個依賴的關係圖，裡面記錄著每個頁面所需要用到的模組，並將每個模組綑綁成一個或多個來使用。簡單來說就是可以幫我們打包所有用到的 JavaScript 、SASS … 等檔案，編譯後讓瀏覽器可讀取。另一個工具 gulp 跟 webpack 的差異在一個是協助自動化，另外一個是協助前端打包的。gulp 比較偏向命令式的編寫設定，也就是說所有的編譯動作的邏輯都要自己編寫，webpack 就偏向設定。 安裝首先需要用 npm 安裝 webpack 與 webpack-dev-server, 如果你第一次裝，可以用 -g 安裝，以便在任何地方都可以使用該指令： webpack //打包工具webpack-dev-server //即時產生一個 server 看執行結果 npm install -g webpack webpack-dev-server 接著安裝指令包 npm install webpack-cli -g 專案使用1.建立專案資料夾 2.建立 NPM (參照 NPM 文件，記得移動到專案資料夾的目錄) npm init 按照資訊設定，產生 package.json 內容會像以下 Code123456789101112131415&#123; &quot;name&quot;: &quot;my-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;this is my project&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot; &quot;url&quot;: &quot;http://github.com/npm/npm.git&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 若想快速設定可用 npm init -y。設定結束後，會產生 package.json(設定紀錄檔)。 scripts 屬性可以自訂指令名稱及執行指令，設定完後，輸入 npm run 指令名稱 就可以執行了。 建議可在 package.json 加入以下 webpack-dev-server scripts Code123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --devtool eval --progress --colors --content-base build&quot; &#125;, –devtool eval: 將把 source 加到我的 code–progress 與 –colors： 反應現今程序執行狀況–content-base build： 將 build 裡的 index.html 作為啟始頁 安裝 webpack 套件在專案資料夾裡：npm install webpack webpack-cli --save-dev 3.用 NPM 安裝要使用的套件。安裝後的套件資訊，也會記錄在package.json 內。 紀錄的訊息會像是： 開發的時候會用到的套件 Code12345&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.18.0&quot; &quot;babel-eslint&quot;: &quot;^10.0.1&quot;, &quot;eslint&quot;: &quot;^5.16.0&quot;,&#125;, 上線發佈後依然需要用到的套件 Code12345&quot;dependencies&quot;: &#123; &quot;axios&quot;: &quot;^0.19.0&quot;, &quot;bootstrap&quot;: &quot;^4.3.1&quot;, &quot;jquery&quot;: &quot;^3.4.1&quot;,&#125;, package.json 可以手動加入也可自動加入。要自動加入的指令是 --save-dev ，在套件安裝時加上。 e.g.npm install webpack webpack-cli --save-dev 4.建立 webpack.config.js 檔案，用來當作 webpack 的設定檔，檔名也不能亂取。 檔案內容： Code12345678910111213const path = require(&apos;path&apos;);module.exports = &#123; //webpack打包的路徑及對象， index.js entry: &#123; index: &apos;./index.js&apos; &#125;, output: &#123; //這裡是打包後的檔案名稱 filename: &apos;bundle.js&apos;, //打包後的路徑，這裡使用 path 模組的 resolve() 取得絕對位置，也就是目前專案的根目錄 path: path.resolve(&apos;./&apos;), &#125; &#125;; 使用 loader告訴 webpack，該如何處理匯入的檔案(編譯打包)，通常是 Javascript 但 webpack 不限於處理 Javascript，其他像是 Sass，圖片等也可處理，只要提供可處理的 loader。loader 的設定會寫在 module 的 rules 中。 Code123456789101112131415module.exports = &#123; //如果有一個以上的檔案需要打包，可以傳陣列給entry entry: [&apos;./index.js&apos;, &apos;./app.jsx&apos;], output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;./&apos;), &#125;, //將loader的設定寫在module的rules屬性中 module: &#123; //rules的值是一個陣列可以存放多個loader物件 rules: [ &#123; test: /.jsx$/, exclude: /node_modules/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-react&apos;] &#125; &#125; &#125; ] &#125;&#125;; loader 物件屬性 test：指定編譯檔案的副檔名為何，用正規表達式來尋找結尾處為.jsx的檔案。 exclude：指定不編譯的路徑。 use：指定用來編譯符合副檔名條件的loader，這個物件裡面還有兩個屬性： loader：指定進行編譯的套件option：指定 loader 套件中的 presets 是什麼 其他 loader 對應：CSSCSS：style-loader、css-loaderSASS：sass-loader、node-sass 安裝：npm install --save-dev autoprefixer css-loader node-sass postcss-loader precss sass-loader style-loader 設定 Code12345678910// webpack.config.jsmodule: &#123; rules: [ &#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125; ]&#125; 使用 Code12// ./src/index.jsimport &apos;./styles/style.scss&apos; PICfile-loader、url-loader npm install --save-dev url-loader 設定 Code123456789101112131415161718192021222324252627// webpack.config.jsmodule:&#123; rules:[ // url loader (for image) &#123; test: /\.(jpe?g|png|gif|svg)$/, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 40000 /* 小於 40kB 的圖片轉成 base64 */ &#125; &#125; ] &#125; ], [ // file-loader &#123; test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ &apos;file-loader&apos; ] &#125; ]&#125; 使用 Code123456789101112131415// ./src/image-viewer.jsimport midImgUrl from &apos;./../assets/mid.jpeg&apos;import minImgUrl from &apos;./../assets/min.jpeg&apos;// midImg 會是被壓縮過的檔案名稱const midImg = document.createElement(&apos;img&apos;)midImg.src = midImgUrldocument.body.appendChild(midImg)// minImg 是被注入在 bundle.js 中，可以直接使用const minImg = document.createElement(&apos;img&apos;)minImg.src = minImgUrldocument.body.appendChild(minImg)export &#123;midImg, minImg&#125; ES6 轉譯 ES5babel-loader、babel-core、babel-preset-env npm install --save-dev @babel/core @babel/preset-env @babel/preset-react babel-loader 設定 Code12345678910111213141516171819202122232425262728// webpack.config.jsmodule: &#123; rules: [ // babel-loader &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [ [ &apos;@babel/preset-env&apos;, &#123; useBuiltIns: &apos;entry&apos;, // targets: &quot;&gt; 0.25%, not dead&quot; targets: &#123; chrome: &apos;69&apos; &#125; &#125; ] ] // End of presets &#125; // End of options &#125; &#125; // End of Babel ];&#125; 開啟本機伺服器在 webpack.config.js 中增加 devserver 的一些設定，例如要開啟的 port，如果沒有特別設定的話，port 的預設值為 8080，以下為了區隔所以設定 9000 Code123456789101112131415161718192021const path = require(&apos;path&apos;);module.exports = &#123; entry: [&apos;./index.js&apos;, &apos;./app.jsx&apos;], output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;./&apos;), &#125;, //將loader的設定寫在module的rules屬性中 module: &#123; //rules的值是一個陣列可以存放多個loader物件 rules: [ &#123; test: /.jsx$/, exclude: /node_modules/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-react&apos;, &apos;@babel/preset-env&apos;] &#125; &#125; &#125;, &#123; test: /.js$/, exclude: /node_modules/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-env&apos;] &#125; &#125; &#125; ] &#125;, //增加一個給devserver的設定 devServer: &#123; //指定開啟port為9000 port: 9000 &#125;&#125;; Plugin透過 clean-webpack-plugin 可以每次打包前都清除特定資料夾。 安裝 $ npm install clean-webpack-plugin --save-dev Code123456789101112// webpack.config.jsconst path = require(&apos;path&apos;)const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new CleanWebpackPlugin([&apos;dist&apos;]), // ... ]&#125; 指令(命令提示字元下 or 終端機輸入)看版本webpack -v 打包webpack -p or npm run start 開啟本機伺服器webpack-dev-server 執行完後，打開瀏覽器輸入 http://localhost:9000 ，關閉 webpack-dev-server 開啟的 port，在命令提示字元的畫面上輸入 Ctrl+C。 參考：https://webpack.js.org/concepts/#entryhttps://ithelp.ithome.com.tw/articles/10200329https://ithelp.ithome.com.tw/articles/10200459?sc=ptWebpack 學習筆記（Webpack Note）]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 簡單介紹]]></title>
    <url>%2F2020%2F01%2F16%2FjQuery-base%2F</url>
    <content type="text"><![CDATA[jQuery 簡單介紹JavaScript 的 Library，jQuery 主要是用在 DOM 文件操作，包含快速選取元素(Element)與執行事件，例如隱藏元素、顯示元素等等。此外 jQuery 的核心程式還加強了非同步傳輸(AJAX)以及事件(Event)的功能。 使用 jQueryjQuery 用 $(selector).action() 格式，指派元素到指定的事件。詳細來說， $(selector) 會呼叫 jQuery 選取 selector 元素，並指派它到稱作 .action() 事件。回傳值是 Array。可以直接用 for 或是 foreach 迴圈去處理。 e.g. $(&quot;div&quot;).addClass(&quot;special&quot;); 範例是將先前所選取到的 &lt;div&gt; 元素都加上一個名為 “special” 的 class。 記號 $ 是被當成 jQuery 的縮寫。等同， jQuery(&quot;div&quot;).addClass(&quot;special&quot;); 另一個例子 Code123456$(document).ready(function()&#123; // 等所有的 HTML 都載入，且 DOM 都以建構完成執行 &#123; &#125; 內容，將所有 function(); // 放入裡面是常見做法 alert(&quot;Hello World!&quot;); $(&quot;#blackBox&quot;).hide();&#125;); 上面這段 jQuery 程式碼，會執行與這段原生 JavaScript 程式碼相同的事情： Code1234window.onload = function() &#123; alert( &quot;Hello World!&quot; ); document.getElementById(&quot;blackBox&quot;).style.display = &quot;none&quot;;&#125;; 選取元素選取所有 &lt;div&gt; 元素$(&quot;div&quot;) 選取 id 為 menu 的元素$(&quot;#menu&quot;) 選取 class 為 content 的元素$(&quot;.content&quot;) 選取 id 為 body 的 &lt;div&gt;$(&quot;div#body&quot;) 選取 class 為 content 的 &lt;div&gt; 所包住的所有內層的 &lt;p&gt;$(&quot;div.content p&quot;) 取得第index個子節點: eq(index)$(&#39;ul&#39;).children.eq(3).text(); //取得第三個子節點 利用屬性內容找節點$(&quot;input[name=&#39;A&#39;]&quot;); //找出 name 屬性為 ‘A’ 的 input 操作元素讀取和修改一個元素的HTML內容: html()若是多個元素，只能讀取第一個元素的內容 讀取 &lt;p&gt; 元素的內容 $(&quot;p&quot;).html(); 修改 &lt;p&gt; 元素的內容 $(&quot;p&quot;).html(&quot;Hello &lt;b&gt;world&lt;/b&gt;!&quot;); 讀取和修改一個元素的純文本內容: text()讀取 Element 的文本內容 $(&quot;Element&quot;).text(); 修改 Element 的文本內容，Element 的 content 是 Hello &lt;b&gt;world&lt;/b&gt;! 是文字格式，不是標籤元素 $(&quot;Element&quot;).text(&quot;Hello &lt;b&gt;world&lt;/b&gt;!&quot;); 讀取和修改一個表單元素的 value 值: val()若是多個元素，只能讀取第一個元素的內容。要使用 for 或 each 來讀取多個。 讀取 Code12345// 讀取每一個被 checked 的值$(&apos;input:checkbox[name=size]:checked&apos;).each(function() &#123; alert($(this).val()); &#125;); 修改 $(&quot;Element&quot;).val(value); 元素節點末端加入純文字或 HTML 語法(增加元素): appendCode12// 選取所有有 target 屬性的 `&lt;a&gt;`，並且在其節點下加入一段文字。$(&quot;a[target]&quot;).append(&quot;(Opens in New Window)&quot;); 元素節點前端加上純文字或 HTML 語法(增加元素): prepend()$(div).prepend(&quot;first&quot;); 修改 css 屬性: css.css(&#39;border&#39;,&#39;3px solid red&#39;) or Code1234$(&quot;#body&quot;).css(&#123; border: &quot;1px solid green&quot;, height: &quot;40px&quot; &#125;); class的新增: addClass()$(&quot;#test&quot;).addClass(&quot;aaa&quot;); class的移除: removeClass()$(&quot;#test&quot;).removeClass(&quot;aaa&quot;); 移除多個 $(&quot;#test&quot;).removeClass(&quot;aaa bbb&quot;); 事件事件寫法有兩種 $(selector).click(function(){}) or $(selector).on(&#39;click&#39;, function(){}) or // 動態綁定$(selector).on(&#39;click&#39;, selector, function(){ }) ps. 補充有說明兩種的不同 點選元素: clickCode1234567891011121314151617//當 user 點選 id 為 open 的連結時，顯示 id 為 menu 的區塊，並回傳 false 避免瀏覽器真的換頁。$(&quot;a#open&quot;).click(function() &#123; $(&quot;#menu&quot;).show(); return false; &#125;);html&lt;style type=&quot;text/css&quot;&gt; #menu &#123;display: none&#125; &lt;/style&gt; &lt;a id=&quot;open&quot; href=&quot;#&quot;&gt;menu&lt;/a&gt; &lt;ul id=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;a&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;b&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;c&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 失焦並且內容改變: change() 聚焦: focus()Code123$(&quot;input&quot;).focus(function()&#123; $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;#FFFFCC&quot;);&#125;); 失焦(滑鼠游標移開): blur()Code123$(&quot;input&quot;).blur(function()&#123; $(&quot;input&quot;).css(&quot;background-color&quot;,&quot;#D6D6FF&quot;);&#125;); 加上鍵值: keyup()Code1234567(&apos;#target&apos;).keyup(function(event) &#123;if (event.keyCode == &apos;13&apos;) &#123; event.preventDefault(); ... &#125; ...&#125;) 表單送出: submitCode12345678910111213141516//在網頁上的表單送出時加入一個判斷，如果 username 這個欄位是空值的話，就顯示 help 這個區塊內的文字。$(&quot;form&quot;).submit(function() &#123; if ($(&quot;input#username&quot;).val() == &quot;&quot;) $(&quot;span.help&quot;).show(); &#125;);html&lt;style type=&quot;text/css&quot;&gt; .help &#123;display: none&#125; &lt;/style&gt; &lt;form&gt; &lt;label for=&quot;username&quot;&gt;請輸入姓名&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt; &lt;span class=&quot;help&quot;&gt;此欄位為必填&lt;/span&gt; &lt;/form&gt; 布幕動態效果: slideDownCode123456789101112$(&quot;#menu&quot;).slideDown(&quot;fast&quot;);html&lt;style type=&quot;text/css&quot;&gt; #menu &#123;display: none&#125; &lt;/style&gt; &lt;ul id=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;a&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;b&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;c&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; animate 函數Code1234567891011//將所有的 &lt;div&gt; 漸變為寬 300px、文字與邊界寬 20px$(&quot;div&quot;).animate(&#123; width: &apos;300px&apos;, padding: &apos;20px&apos; &#125;, &apos;slow&apos;); HTML&lt;div style=&quot;width: 100px; border: solid 1px red;&quot;&gt; Hello world! &lt;/div&gt; 顯示: show()$(&#39;.target&#39;).show(); //顯示target 隱藏: hide()Code1234567891011121314/*所有的 &lt;div&gt; 以 0.5 秒的動態效果隱藏後，再以 0.5 秒的動態效果顯示。hide() 的第二個參數就是一個 callback 函數，其中 $(this) 是原本程式所處理的各個元素。*/$(&quot;div&quot;).hide(500, function()&#123; // $(this) 是每一個別的 &lt;div&gt; $(this).show(500); &#125;); HTML&lt;div style=&quot;width: 100px; border: solid 1px red;&quot;&gt; Hello world! &lt;/div&gt; &lt;div style=&quot;width: 100px; border: solid 1px red;&quot;&gt; jsGears.com! &lt;/div&gt; 切換: toggle()toggle() 方法用於綁定兩個或多個事件處理器函式，以響應被選元素的輪流的 click 事件。該方法也可用於切換被選元素的 hide() 與 show() 方法。 Code123456789// 切換背景色$(&quot;p&quot;).toggle( function()&#123; $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;green&quot;);&#125;, function()&#123; $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;red&quot;);&#125;, function()&#123; $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);&#125;); Code12345678910111213// 按下 Hello 元素第一次會文字會是綠，第二次會是藍色$(&apos;#mydiv&apos;).toggle( function()&#123; $(this).css(&#123;&quot;color&quot;: &quot;green&quot;&#125;); &#125;, function()&#123; $(this).css(&#123;&quot;color&quot;: &quot;blue&quot;&#125;); &#125;,);html &lt;div id=&quot;mydiv&quot;&gt;Hello&lt;/div&gt; AjaxajaxCode12345678$.ajax(&#123;type: &quot;GET&quot;, //指定method url: &apos;ajax/test.html&apos;, success: function(data) &#123; $(&apos;.result&apos;).html(data); alert(&apos;Load was performed.&apos;); &#125;&#125;); 取得 HTML: load()$(&quot;#htmDoc&quot;).load(&quot;test.html&quot;); 取得 XML 格式的資料Code1234$.get(&quot;test.xml&quot;,function(xml)&#123;var text = $(&quot;title&quot;,xml).text();$(&quot;#xmlDoc&quot;).html(text);&#125;); 取得 TXT 格式的資料Code123$.get(&quot;test.txt&quot;,function(txt)&#123;alert(txt);&#125;); 取得 JSON 格式的資料: getJSON()Code123456789101112131415161718$.getJSON(&quot;test.json&quot;, function(data)&#123; for (var idx in data) $(&quot;#menu&quot;).append(&quot;&lt;li&gt;&quot; + data[idx] + &quot;&lt;/li&gt;&quot;); &#125;); HTML&lt;ul id=&quot;menu&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;/ul&gt; test.json[ &quot;Hello world!&quot;, &quot;jsGears.com!&quot; ] 連續使用函數如果想將所有的 &lt;div&gt; 隱藏，並修改文字顏色，再用布幕動態效果顯示出來的話，可用下方程式碼處理： Code123$(&quot;div&quot;).hide(); $(&quot;div&quot;).css(&quot;color&quot;, &quot;green&quot;); $(&quot;div&quot;).slideDown(); 上方三行程式碼可簡化成 $(&quot;div&quot;).hide().css(&quot;color&quot;, &quot;blue&quot;).slideDown(); 另一個範例： 選取第三個 &lt;li&gt; 加上 5px 的紅色邊框，並在 &lt;li&gt; 裡面加上文字 A$(&#39;li:nth-child(3)&#39;).css(&#39;border&#39;,&#39;5px solid red&#39;).append(&#39;A&#39;); jQuery plugin 應用 下載 jQuery 的 js 和要使用的 plugin 打開 HTML 檔，在 &lt;header&gt; 加上 &lt;link&gt;，分別為套件的 *.css 與自己的 *.css 檔 e.g. &lt;link rel=&quot;stylesheet&quot; href=&quot;css/flexslider.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&gt; 在 body 加上官網上給的使用語法 在 &lt;/body&gt; 之前 加上 jquery.min.js、套件的*.js檔與套件使用的 js 語法。 e.g. &lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.slim.min.js&quot; integrity=&quot;sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; 依照套件的教學及範例，基本上就可以使用了。 document ready 事件有時，在網頁下載完成後，要立即執行一些程式的話。可以用 window.onload 來處理，或是直接在 &lt;body&gt; 標籤上加入 onload 的事件處理函式。 jQuery 提供了 .ready() 來處理這類情況。 e.g. Code1234// 網頁下載完成後立即執行 alert()$(document).ready(function() &#123; alert(&apos;Hello&apos;); &#125;); jQuery 的 document ready 事件是模擬 W3C DOM 標準的 DOMContentLoaded 事件，DOMContentLoaded 和 window.onlad 的差異在於前者是在 DOM 文件下載完成後觸發，而後者是文件和所有文件內的元件，包含圖檔等等全部下載完成後才會觸發。因此通常 window.onload 的發生時間要比 DOMContentLoaded 晚一點。 而 DOMContentLoaded 和 window.onload 的另一個差異在於 window.onload 並沒有辦法多次指定不同的函數來執行，最後指定的那個函數會複寫掉先前的。但 jQuery 的 document ready 函數並不會有覆寫的情況發生。 document ready 函數也有更精簡的寫法，如下： Code123$(document).ready(function() &#123; alert(&apos;Hello&apos;); &#125;); 可改寫成 Code123$(function() &#123; alert(&apos;Hello&apos;); &#125;); 別名jQuery 本身提供一個函式來避免 $() 的衝突，使用 jQuery 函式前，加上 jQuery.noConflict(); Code1234jQuery.noConflict();$(document).ready(function() &#123; alert(&apos;Hello&apos;); &#125;); 或是另外設定名稱 Code1234const $j = jQuery.noConflict();$j(document).ready(function() &#123; alert(&apos;Hello&apos;); &#125;); 補充.click(function()) 及.on(‘clcik’,function())，這兩者間到底有什麼不一樣？Code12345&lt;ul&gt; &lt;li&gt;&lt;span&gt;click me&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;click me&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;click me&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; .click(function())若是使用$(&#39;li span&#39;).click(function(){alert(&#39;hi&#39;)});的話，它只對於你現在 HTML 上所指定的全部元素進行事件綁定，如果你在後來透過 jQuery 或其他方式所增加的元素都不會出現在這個事件所綁定的範圍裡，所以 .click 是沒有辦法幫助你做到動態的事件綁定。 .on基本上 .click 能做到的事情，透過.on(‘click’)的方式一樣都能做到，但是 .on() 能做到動態事件綁定，以上述的例子而言，我們可能會寫 $(&#39;li span&#39;).on(&#39;click&#39;,function(){alert(&#39;hi&#39;)});這時你會發現，在動態事件這種方式會跟上述的.click事件處理方式一樣沒反應，那到底 .on() 要怎麼做到動態事件綁定？.on()方法有提供第二個參數「childSelector」$(&#39;li&#39;).on(&#39;click&#39;,&#39;span&#39;,function(){alert(&#39;hi&#39;)}); childSelector 的原理就是事件冒泡 event bubbling ，在你點擊子元素 span 時，子元素 span 一樣是在父元素 li 裡面，所以你樣是有點擊到父元素 li，而事件的傳遞會從子元素先發生接著向父元素傳遞，但是實際上我們這邊事件一樣是綁定在父元素 li 上，所以它會再去而找到相對應的子元素，來進行事件處理。這兩者間最大的差異，大概就在動態事件處理上，當然還有像是一些小差異像是 .on() 所佔用的記憶體會比.click還少.on() 為Namespaced Events，可以做到事件命名的管理。 一般來說，如果不會用到 append … 等這些插入元件控制用的語法。使用第三個程式寫法就行了，不需要用到 on 處理。在某些情況下，on 最好還是少用。不得已非要用到的情況才去使用它會比較好。 blur 事件會觸發兩次jQuery 解決使用 blur 事件時，會觸發兩次的問題 (好像用 focus 事件也會)。因為在綁定 onblur 事件的時候都會被觸發兩次，原因不明…..網路上有找到解法，但好像不是用 on 來綁，是用一般的 blur(無法動態綁定)，若是 dom 都是動態產生的，這個沒法用。 可用此方式試試 e.g. $(&#39;#gradeUpdate&#39;).blur() 改成這樣就可以了 $(&#39;#gradeUpdate&#39;)[0].blur() 參考：https://jquery.com/https://www.j2h.tw/bbs/bbs16/511.htmlhttps://developer.mozilla.org/zh-TW/docs/Glossary/jQueryhttps://ithelp.ithome.com.tw/articles/10197512http://greenkm.blogspot.com/2016/03/jquery_8.htmlhttps://jjnnykimo.pixnet.net/blog/post/21585448https://felixx.pixnet.net/blog/post/36966403http://shioulo.eu5.org/node/256https://sweeteason.pixnet.net/blog/post/42677633-jquery-%E8%A7%A3%E6%B1%BA%E4%BD%BF%E7%94%A8-blur-%E4%BA%8B%E4%BB%B6%E6%99%82%EF%BC%8C%E6%9C%83%E8%A7%B8%E7%99%BC%E5%85%A9%E6%AC%A1%E7%9A%84%E5%95%8Fhttp://skaih.logdown.com/posts/712464-jquery-click-on-the-where-differenthttps://ithelp.ithome.com.tw/questions/10191601https://www.w3cplus.com/blog/134.html]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass 基本介紹]]></title>
    <url>%2F2020%2F01%2F16%2FSass-base%2F</url>
    <content type="text"><![CDATA[SassSass(Syntactically Awesome StyleSheets) 是種 CSS 的擴充，經過編譯(compiled) 成 CSS 檔，讓瀏覽器可讀取。解決了專案 CSS 遇到的重複、可維護性差等問題。bootstrap 也有使用 Sass。 格式寫法 SCSS用大括號跟分號來區分段落，多數人使用，與 CSS 語法相近。 e.g. Code1234567891011121314151617181920&lt;ul class=menu&gt; &lt;li&gt;&lt;a href=&apos;#&apos;&gt;1234&lt;/a&gt;&lt;/li&gt;.menu &#123; li &#123; font-size: 30px; a &#123; color: red; &#125; &#125; &#125;compiler:.menu li &#123; font-size: 30px;&#125;.menu li a &#123; color: red;&#125; SASS使用排縮跟斷行來區分。 e.g. Code12345678&lt;ul class=menu&gt; &lt;li&gt;&lt;a href=&apos;#&apos;&gt;1234&lt;/a&gt;&lt;/li&gt;.menu li font-size: 30px a color: red Sass 轉成 CSS 方式(透過編譯)編譯順序是從上到下 軟體編譯 https://sass-lang.com/install 安裝 Sass Prepros：免再安裝其它軟體即可編譯 Jade/SASS1.下載：https://prepros.io2.安裝好之後就拖曳網站資料夾(根目錄)到 prepros 拖曳後產生兩個欄位，左邊是網站資料夾，右邊是 檔案清單、Log、FTP、軟體設置，最重要的就是 Log，他會顯示SASS紀錄，當SASS無法轉成CSS時，他會有紀錄，方便看程式是否哪邊有問題?3.而且他會在資料夾產生一個 prepros-6.config，如後續沒有要用到 SASS，網站完成後可以刪掉，如果要再用 SASS 輸出成 CSS 要再重新拖曳檔案到 prepros 讓他讀取該資料夾繼續編譯 SASS。4.新增 Scss 和 css 資料夾：開始寫 SCSS 之前，先在網站資料夾新增 Scss 和 CSS 資料夾，SCSS檔案存在同名資料夾，SCSS 檔案儲存時，電腦桌面會出現編譯成功的小視窗，CSS 資料夾會出現一個 CSS的檔案。 打包：gulp / webpack編輯器內建插件編譯VSCode 套件：Live Sass compiler 在 vscode 安裝 Live Sass compiler 插件。 產生專案資料夾，在專案資料夾內新增 Scss 資料夾。新增一個 all.scss 文件。程式視窗下方，會啟用 Live Sass compiler 程式。有 Watch Sass 字樣。寫完 Scss 後，點擊 Watch Sass 字樣，會產生 all.css 跟 all.css.map 至預設的資料夾內，且每一次儲存檔案都會自動編譯一次。想要停止即時編譯的狀態，點擊視窗下方的「Watching…」即可停止。 預設的情況編譯產生的 CSS 將會被放置在與 SCSS 檔案同層的資料夾內，要指定 CSS 輸出路徑或輸出形式，可依照以下的步驟來設定。 指定輸出CSS的路徑於檔案總管內另外新增一層名為 css 的資料夾，接著進入 VSCode 的喜好設定 -&gt; 設定，可直接將以下的程式碼複製並貼到區塊存檔： Code12345&quot;liveSassCompile.settings.formats&quot;:[ &#123;&quot;savePath&quot;: &quot;/css&quot; &#125; ] LiveSassCompile.settings.formats：可用於調整 Live Sass Compiler 外掛相關的屬性設定。savePath：輸出後的 CSS 檔存放資料夾。 更改輸出樣式Live Sass Compiler 支援以下四種輸出樣式： expanded(預設) compact compressed (去除檔案所有空格及縮排) // 常見 nested將以下的程式碼貼入設定檔，並存檔。 Code12345678&#123; &quot;liveSassCompile.settings.formats&quot;:[ &#123; &quot;format&quot;: &quot;compressed&quot;, &quot;savePath&quot;: &quot;/css&quot; &#125; ]&#125; Sass 使用巢狀(nesting)透過巢狀式的結構也可以清楚的知道元素上下層的關聯性。 e.g. Code12345678910.box&#123; width: 100%; margin: 0 auto; .title&#123; padding: 10px; p&#123; color: rgba(255, 0, 0, 1);; &#125; &#125;&#125; 編譯成 CSS 就會變成 Code12345678910.box&#123; width: 100%; margin: 0 auto;&#125;.box .title&#123; padding: 10px;&#125;.box .title p&#123; color: rgba(255, 0, 0, 1);;&#125; 還有一個方便的功能是使用 &amp; 符號來代替父層(上層) Code123456.box&#123; color: rgba(0, 0, 0, 1); &amp;:hover&#123; color: red; &#125;&#125; 編譯後 Code123456.box&#123; color: rgba(0, 0, 0, 1);&#125;.box:hover&#123; color: rgba(255, 0, 0, 1);&#125; 變數(Variable)$ 來表示變數，變數可以用來儲存值，方便重複利用。時常需要設定的 CSS 可設為變數。 $變數名: 樣式; e.g. Code12345$box-shadow: 10px 10px 5px rgba(0, 0, 0, 1);.box&#123; box-shadow: $box-shadow;&#125; 變數也能拿來做運算，格式有 數字：10、1px、3em字串：’test’、”../images/big/“顏色：red、#000000、rgba(255,255,255,0.9)布林：true、false空值：null Code1234$num:5px;.container&#123; margin:$num*2 $num;&#125; 集合變數 Code12345678910$themes: ( //key, value &apos;primary&apos;: blue; &apos;danger&apos;: red; &apos;secondary&apos;: orange;);.box-primary &#123; background-color: map-get($themes, &apos;primary&apos;); &#125; 混合(mixin)函式可以使用在重複多行的樣式上面，像是 CSS 的一些新屬性就可能需要加上瀏覽器前綴，這個部分就可以透過函式來完成，要特別注意的是：@mixin需要配合 @include 來使用@mixin來設定要使用的樣式、@include則是套用樣式 Code12345678910@mixin css3-border-radius() &#123; -ms-border-radius: 5px; -moz-border-radius: 5px; -webkit-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; &#125;.box &#123;@include css3-border-radius();&#125; 編譯後 Code1234567.box &#123; -ms-border-radius: 5px; -moz-border-radius: 5px; -webkit-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125; 函式也可以搭配參數使用讓使用上更加靈活。 Code12345678910@mixin css3-border-radius($i) &#123; -ms-border-radius: $i; -moz-border-radius: $i; -webkit-border-radius: $i; -o-border-radius: $i; border-radius: $i; &#125;.box &#123;@include css3-border-radius(3px);&#125; 導入(import)在檔案中加入其他SCSS或CSS檔案，最後編譯時會一併編譯。假如我想在某個SCSS檔案裡面匯入 head、main、footer 等 SCSS 的檔案就可以使用下面這段程式碼 @import &quot;head.scss&quot;;@import &quot;main.scss&quot;;@import &quot;footer.scss&quot;; 繼承(Extend)@extend 主要是用在合併相同程式碼，假如有很多段相同的程式碼就可以使用 @extend 進行合併，只要加上站位符號 % 就能讓被繼承的 CSS 類消失。 Code123456789101112131415%box &#123; border: 1px solid rgba(0, 0, 0, 1); padding: 10px; color: rgba(0, 0, 0, 1);&#125;.success &#123; @extend %box; border-color: rbga(0, 128, 0, 1);&#125;.danger &#123; @extend %box; border-color: rgba(255, 0, 0, 1);&#125; 編譯後 Code12345678910111213.success, .danger&#123; border: 1px solid black; padding: 10px; color: black;&#125;.success&#123; border-color: rgba(0, 128, 0, 1);&#125;.danger&#123; border-color: rgba(255, 0, 0, 1);&#125; 函式(Functions)SCSS 中也有 @function 可以使用，像是 @if、@for，可以查看內建函式的清單 Code12345678910.box &#123; background-color: $i; &#125;&#125;@for $i from 1 through 5 &#123; // 包含 5 有 1-5 .box-#($i) &#123; background-color: $i; &#125;&#125; @for@for $i from 1 to 5{}@for $i from 1 through 5{} 先用 @for 啟用此功能，再來用 $ 設立一個變數i(可自訂但通常慣用 i )，再來 from 1 to 5 的意思是，$i 這個變數，從 1 開始逐步替換到 4(不包含 5 )，若要需要包含 5，用 through，所以就會寫成 @for $i from 1 through 5{}，這樣才 $i 才是從 1逐步的替換到 5，然後在 @for 最後面的大括弧內寫上要替換的對象(選擇器)以及條件(語法)，如下： Code12345@for $i from 1 through 5&#123; .box#&#123;$i&#125;&#123; background:darken(red,$i*5%); &#125;&#125; 假設這個簡單的案例是有五個 .box，從 .box1 ~ .box5，然後分別用 darken 來加深他們的 background 顏色，首先先在 .box 後面緊接著 #{$i}，讓他變成 .box#{$i}，變數 $i一定要先用 {} 包起來，然後在前面再加一個 # 字，這樣 .box 就會被逐步的迭代成 .box1、.box2到 .box5 了。 一個簡單的 @for 就可以一次給五個 class 效果，接著看後面的 background，我們給它的值是利用 darken 功能，再來後面接條件 (red,$i*5%)，寫成background:darken(red,$i*5%);，利用 @for 的迭代功能，就可以把 background 分別改成 darken(red,$5%、10%、15%、20%、25%);。 @each迭代變數內容 e.g. Code1234567$list: (orange, purple, melon);@each $item in $list &#123;.#&#123;$item&#125; &#123; background: $item; &#125;&#125; Code12345@each $key, $value in $themes &#123; .box-#($key) &#123; background-color: $value; &#125;&#125; 註解(Comment)只要在程式碼開頭加上兩條斜線 // 就可以加入註解。 @mixin 整理 CSS 應用將 CSS 功能寫成 @mixin 再 @include 到使用該功能的標籤元素。 e.g. 圖片取代文字Code12345@mixin hide-text&#123; text-indent: 110%; white-space: nowrap; overflow:hidden; &#125; 用 CSS 畫各方向的三角形用 CSS 畫圓Code1234567891011@mixin circle($size,$bgcolor) &#123; border-radiu: 50%; height: $size; width: $size; font-size: $size/3; background: $bgcolor;&#125;.box &#123; @include circle(30px,#fff)&#125; @mixin + import 應用CSS 分類、整合_variable.SCSS //變數整理_reset.SCSS //樣式清空，bootstrap 用 normalize.css(會保有瀏覽器預設樣式)_mixin.SCSS CSS 功能_main.SCSS 合成 all.scss (內容 @import 上述 .SCSS 檔) Code12345@import &quot;variable&quot;;@import &quot;normalize&quot;;@import &quot;mixin&quot;; //or @import &quot;mixin/mixin&quot;;// 主要CSS@import &quot;main&quot;; @mixin + RWD響應式處理 @media RWD @mixin + content Code12345678910111213141516171819202122232425262728293031323334353637@mixin desktop-below&#123; @media (max-width: 1023px)&#123; @content &#125;&#125;@mixin pad&#123; @media (max-width: 768px)&#123; @content &#125;&#125;.header &#123; width: 500px; @include pad&#123; width: 13px; // pad&#123;content 內容)&#125; font-size: 20px; &#125;;&#125;@mixin mobile&#123; @media (max-width: 568px)&#123; @content &#125;&#125;.header &#123; width: 500px; @include pad&#123; width: 13px; // pad&#123;content 內容)&#125; font-size: 20px; &#125;; @include mobile&#123; font-size: 8px; &#125;;&#125; SASS 設計模式簡單介紹SMACSS結構分類：Base、Layout、Module、State、Theme。命名規則：id 與 class 受限制地使用、名稱使用 dash 分隔。結構的分類存在模糊界線。 OOCSSObject Oriented CSS，範例是 Bootstrap。 結構(header)與樣式(header-shadow)分離 Code123456789101112html&lt;div class=&quot;header header-shadow&quot;&gt;&lt;/div&gt;css.header &#123; width: 200px; height: 100px;&#125;.header-shadow &#123; box-shadow: 10px 10px 10px #000;&#125; Code1&lt;button class=&quot;pure-button pure-button-primary&quot;&gt;btn&lt;/button&gt; 容器與內容分離 BEM由 Yandex 團隊提出來命名 Class 名稱的設計模式，BEM 的意思是區塊(Block)、元素(Element)、修飾符(Modifier)。以元件觀念進行開發，具有重用性。 Code1234&lt;ul class=&quot;menu&quot;&gt; &lt;li class=&quot;item active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 變成 Code123456&lt;div class=&quot;product&quot;&gt; &lt;div class=&quot;menu&quot;&gt; &lt;li class=&quot;menu__item menu__item--active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;menu__item&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/div&gt;&lt;/div&gt; .block{} //區塊 (Block).block__element{} //元素(Element).block--modifier{} //修飾符(Modifier) 區塊 (Block)我們在設計網站時，一定會設計幾個區塊(Block)出來，如下圖表頭裡面有 LOGO 、選單、搜尋框、登入視窗等等，這樣才能方便移動整個區塊到對應位置，這時候我們就會用 class 命名他們區塊對應的語意，例如.menu、.logo、.search、.auth。 元素 (Element)再來我們深入 menu 的區塊，你可以看到下圖選單內有四個元素，如果這些元素設定是會綁定在這個區塊上時，就可以在區塊的 class 後面加上雙下底線 __ 來辨識他是該區塊底下的元素，class 就會設計為 .menu__item{}。PS：除了HTML tag外，如果是一個 CSS 組件也可把它視為元素 (Element) 。 修飾符（Modifier）修飾符（Modifier）的觀念和 SMACSS 的 State Rules 很相似。當區塊或元素因為狀態而改變時，就在後面加上雙中線–來辨識它是修飾符，像是下圖選單的部份，當被點選時為了要讓使用者了解該元素有被點選，所以就會用 javascript 動態加入 class 為 .menu__item--active，所以如果我們要判斷這個 class 是屬於元素還是修飾符的設定，就只要看 class 最後面是雙中線 -- 還是雙下底線 __ 就知道他是屬於哪一種了。 BEM + SassCode1234567891011121314.list&#123;&#125;.list__title&#123;&#125;.list__img&#123;&#125;.list__img—changebg&#123;&#125;.list &#123; &amp;__title &#123; &#125; &amp;__img &#123; height: 50px; &amp;—changing &#123; &#125; &#125; CSS 命名.bookList { } 比較好懂.bookList-title { } //bookList 下的 title.bookList_title { } //跟 .bookList-title {} 一樣，保持一致就好。 拋棄語意命名方式，改以工具性質來命名。容易重複利用.list{}.list_title{}顏色，不要直接用顏色來命名.textcolor {color: green;}利用格線系統來命名.col_3 {} ps.Sass的檔名如果在最前面加上 _ 就不會被轉譯工具輸出成CSS檔案(例如：_base.scss)，可用時單純匯入、整合 Sass 檔 reset.csshttps://meyerweb.com/eric/tools/css/reset/CSS 前掛上這一段「Reset CSS」的語法，樣式會全部清空，處理各大瀏覽器的差異。用 @import 來引用 reset.css。 normalize.css 會保有瀏覽器預設樣式。 參考：https://blog.techbridge.cc/2017/06/30/sass-scss-tutorial-introduction/https://ithelp.ithome.com.tw/articles/10132821https://ithelp.ithome.com.tw/articles/10203396?sc=iThelpRhttps://medium.com/@enshenghuang/%E4%BD%BF%E7%94%A8vscode%E5%A4%96%E6%8E%9B%E8%87%AA%E5%8B%95%E7%B7%A8%E8%AD%AFsass-scss-9ff768d23b48https://www.hexschool.com/courses/sass.htmlhttps://cythilya.github.io/2018/06/05/css-methodologies/https://cythilya.github.io/2018/05/22/bem/]]></content>
      <categories>
        <category>Sass</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>Sass</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 基本介紹]]></title>
    <url>%2F2020%2F01%2F15%2FHTML-base%2F</url>
    <content type="text"><![CDATA[HTML 基本介紹超文本標記語言（英語：HyperText Markup Language，簡稱：HTML）是一種用於建立網頁的標準標記語言。HTML是一種基礎技術，常與CSS、JavaScript一起被眾多網站用於設計網頁、網頁應用程式以及行動應用程式的使用者介面[3]。網頁瀏覽器可以讀取HTML檔案，並將其彩現成視覺化網頁。HTML描述了一個網站的結構語意隨著線索的呈現，使之成為一種標記語言而非程式語言。目前已經到了 5.0 版。標籤元素使用標籤元素來呈現網頁內容，通常為 “區塊級” 或是 “行內”。瀏覽器預設以在元素前後換行(另起一行)的方式，表現區塊級元素。視覺上會呈現為一排縱向堆疊的方塊。行內元素是與鄰近元素保持在同一行。 元素組成可以加入屬性及屬性值，可以同時有多種屬性及值，每個標籤都可以有 id 及 class 屬性。 id=”名稱”：識別單一元素用，可利用 id 來跟特定元素互動，名稱不能相同。class=”名稱”：識別同類別元素，可利用 class 來跟同類別元素互動，多元素可以同一個 class 類別。 屬性也可以自訂，使用方式為 date-* 。 e.g. data-timezone=&quot;Europe/London&quot; 利用 getAttribute 方法可取出值。 let timezone = tz.getAttribute(&#39;data-timezone&#39;); 標籤種類網頁頁面資訊版本宣告(HTML5)&lt;!DOCTPYE html&gt; 網頁語系&lt;html lang=&quot;en&quot;&gt; 網頁資訊&lt;head&gt;&lt;/head&gt; 裡面通常包含 &lt;meta&gt; &lt;meta&gt; 提供網頁內容資訊給瀏覽器或搜尋引擎通常有以下屬性： 用來寫網頁的簡短描述 name=&quot;description&quot; content=&quot;網頁簡短描述&quot; 放置網頁關鍵字 name=&quot;keywords&quot; content=&quot;網頁關鍵字&quot; 內容種類及編碼 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html&quot;; charset=&quot;uft-8″&gt; 使用語言 &lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-TW&quot;&gt; 自動更新時間 &lt;meta http-equiv=&quot;Refresh&quot; content=&quot;time&quot;&gt; 避免瀏覽器儲存快取 &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no cache&quot;&gt; 瀏覽器頂端或該頁面標題列&lt;title&gt;&lt;/title&gt; 連結外部資源&lt;link&gt;ps. 一般有 rel、type、href 屬性。 rel=”stylesheet”：連結樣式。type=”text/css”：連接類型。(不一定要加上)href=”URL”：連結位置。crossorigin＝”anonymous”：屬性是否使用CORS(不一定要加)，anonymous：發起跨域請求，但不發送認證訊息。 e.g. Code1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T&quot; crossorigin=&quot;anonymous&quot;&gt; script 外部引用&lt;script src=&quot;/path/to/your.js&quot;&gt;&lt;/script&gt;ps. 另外可加上 async 、 defer 屬性(必須搭配 src)。 async：下載後會先執行，但執行此 js 同時也繼續載入頁面及執行其他 js。defer：要整個頁面都下載及分析完成後才會執行，非常類似於把 js 放在頁尾的情況。integrity: 驗證完整性。 e.g. Code1&lt;script defer src=&quot;https://use.fontawesome.com/releases/v5.0.8/js/solid.js&quot; integrity=&quot;sha384-+Ga2s7YBbhOD6nie0DzrZpJes+b2K1xkpKxTFFcx59QmVPaSA8c7pycsNaFwUK6l&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; 網頁內容標籤body 標籤包含的元素會顯示在瀏覽器視窗，標籤組成有分成語意及無語意，來描述頁面資料及結構，視覺效果用 CSS 處理。&lt;body&gt;&lt;/body&gt; div 區塊標籤，可當做無語意的 &lt;header&gt;、&lt;article&gt;，無明顯含義的區塊或為了排版目的&lt;div&gt;&lt;/div&gt; span 行內標籤，可當做無語意的 &lt;strong&gt;、&lt;em&gt;。將文字與元素群組組在行內中。&lt;span&gt;&lt;/span&gt; 樣式標籤，使用 css 樣式(內部宣告用)。&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; 語意標籤用來排版及了解網頁區塊的設計目的，語意標籤和 &lt;div&gt;、&lt;span&gt; 在排版上具有完全一樣的特性，雖可用 &lt;div&gt;、&lt;span&gt; 來快速排版，但最好用以下語意標籤來替代。使用 HTML5 語意化標籤的優點有可以快速抓到網頁架構和每個區塊的位置，對於 SEO 優化有幫助。 HTML5 語意標籤(大多是區塊標籤)&lt;header&gt;：網頁的標頭，通常放置網站標題。&lt;nav&gt;：網頁的選單、導覽。&lt;main&gt;：網頁的主要內容。&lt;aside&gt;：網頁的側欄、附加內容。&lt;article&gt;：一篇文章內容。&lt;section&gt;：自訂的區塊，例如數篇摘要組成的空間。&lt;footer&gt;：網頁的頁尾，通常放置聯絡方式、著作權宣告等等。&lt;mark&gt;：強調一小塊內容。&lt;time&gt;：顯示日期時間。 //不是區塊&lt;mark&gt;：如黃色螢光筆的方式畫出重點，強調內容。 //不是區塊&lt;details&gt;：描述文章的細節。 //不是區塊&lt;figure&gt;、&lt;figcaption&gt;：&lt;figure&gt;用於圖像，&lt;figcaption&gt;用於圖像標題。&lt;hgroup&gt;：當內容有主標題及次標題等多個標題的狀況下使用。&lt;cite&gt;：引用其他文獻或作品(例如書籍、歌曲、電影、繪畫、雕塑等）的標題。 ps.也可當做屬性用 //不是區塊 e.g. 首先是使用 &lt;div&gt; 可能的網頁結構，除了基本元素之外，主內容展示一篇文章和側欄，頁尾則顯示網頁最後更新的時間： Code123456789&lt;div class=&quot;header&quot;&gt;&lt;/div&gt;&lt;div class=&quot;nav&quot;&gt;&lt;/div&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;article&quot;&gt;&lt;/div&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt; Updated on &lt;span class=&quot;time&quot;&gt;&lt;/span&gt;&lt;/div&gt; 接著改用語意標籤，語意標籤和 &lt;div&gt;、&lt;span&gt; 一樣，沒有預設樣式。 Code123456789&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;main&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/main&gt;&lt;footer&gt; Updated on &lt;time&gt;&lt;/time&gt;&lt;/footer&gt; 空白：原始碼可用空白字元來排版，因為瀏覽器有空白壓縮功能，兩個或以上的空白字元，瀏覽器畫面上只會顯示一個空白，原始碼內的斷行也視為單一空白字元。 標題 //區塊標籤&lt;h1&gt;&lt;/h1&gt; ~ &lt;h6&gt;&lt;/h6&gt; 段落 //區塊標籤&lt;p&gt;&lt;/p&gt; 粗體&lt;b&gt;&lt;/b&gt; 斜體&lt;i&gt;&lt;/i&gt; 上標&lt;sup&gt;&lt;/sup&gt; 下標&lt;sub&gt;&lt;/sub&gt; 斷行&lt;br&gt; 水平線 //區塊標籤&lt;hr&gt; 加強，通常標記為重要&lt;strong&gt;&lt;/strong&gt; 斜體，強調元素內容&lt;em&gt;&lt;/em&gt; 編號清單 //區塊標籤Code1234&lt;ol&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ol&gt; 項目清單 //區塊標籤Code1234&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt; 定義清單 //區塊標籤Code1234&lt;dl&gt; &lt;dt&gt;a&lt;/dt&gt; //被定義名詞 &lt;dd&gt;bb&lt;/dd&gt; // 定義&lt;/ul&gt; 巢狀清單Code12345678&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;ul&gt; &lt;li&gt;cc&lt;/li&gt; &lt;li&gt;dd&lt;/li&gt; &lt;/ul&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt; 將內容縮排，通常作為引述 區塊標籤&lt;blockquote&gt;&lt;/blockquote&gt; 引號&lt;q&gt;&lt;/q&gt; ps.&lt;blockquote&gt;及&lt;q&gt;通常會加上 cite=”url” 屬性標明來源。 縮寫及縮略字&lt;abbr&gt;&lt;/abbr&gt; ps. 可加上 title 屬性來註記全名 email or 地址 //區塊標籤&lt;address&gt;&lt;/address&gt; 插入字，會加上底線&lt;ins&gt;&lt;/ins&gt; 刪節線，元素內容會加上刪節線&lt;del&gt;&lt;/del&gt; 元素內容加上刪節線，標示不正確但不刪除的內容&lt;s&gt;&lt;/s&gt; 畫 canvas //區塊標籤&lt;canvas&gt;&lt;/canvas&gt; 置中，標籤內元素會置中&lt;center&gt;&lt;/center&gt; 顯示標籤內資料的原始格式&lt;pre&gt;&lt;/pre&gt; 旁註標記Code1234&lt;ruby&gt; 漢 &lt;rt&gt; ㄏㄢˋ &lt;/rt&gt; 漢 字的上面會標示 ㄏㄢˋ 漢 &lt;rr&gt; ㄏㄢˋ &lt;/rr&gt; 漢 字的旁邊會標示 ㄏㄢˋ&lt;/ruby&gt; 插入圖片&lt;img src=&quot;圖片位置&quot; alt=&quot;沒有圖片時的替代文字&quot; title=&quot;圖片資訊&quot;&gt; HTML5 用法 可放置一張以上的圖 Code12345&lt;figure&gt; &lt;img src=&quot;圖片位置&quot; alt=&quot;沒有圖片時的替代文字&quot; &gt; &lt;br&gt;&lt;figcaption&gt;圖片說明&lt;/figcaption&gt;&lt;/figure&gt; 超連結&lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;連結名稱&lt;/a&gt; ps. href：可用絕對或相對路徑target=”_blank”：連結另開新視窗title=”提示”：加入滑鼠游標提示href=”#id：連結到同網頁的某個部份href=”url#id”：連結到另一個網頁的某個部份href=”mailto:aa@example.org“：Email 連結 絕對路徑/img/logo.png 根目錄下的圖片page.html 同層目錄中的 html 檔 相對路徑 (通常用在自己的網站中)./css/all.css 同層目錄中的 css 資料夾裡的 css 檔../img/logo.png 上層目錄中的 img 資料夾裡的圖檔 音訊&lt;audio src=&quot;url&quot;&gt;&lt;/audio&gt; 屬性： control 提供撥放控制鈕preload=”none or auto or metadata” 頁面載入時是否載入視訊control 提供撥放控制鈕autoplay 自動播放loop 結束後從頭播放 多重音訊 HTML5 Code1234&lt;audio&gt;&lt;source src=&quot;檔案路徑&quot; type=&quot;視訊格式&quot; &gt;&lt;source src=&quot;檔案路徑&quot; type=&quot;視訊格式&quot; &gt;&lt;/audio&gt; 播放視訊(HTML5) //區塊標籤&lt;video src=&quot;url&quot;&gt;&lt;/video&gt;ps.video 標籤的屬性不需要值，屬性存在選項就會開啟，如果不存在選項就關閉。 屬性： src=”檔案路徑”height=”200”width=”100”preload=”none or auto or metadata” 頁面載入時是否載入視訊control 提供撥放控制鈕autoplay 自動播放loop 結束後從頭播放poster=”圖片位置” 視訊下載時或播放前所顯示的影像 放數個視訊 Code12345&lt;video&gt;&lt;source src=&quot;檔案路徑&quot; type=&quot;視訊格式&quot; code=&quot;編碼&quot; &gt;&lt;source src=&quot;檔案路徑&quot; type=&quot;視訊格式&quot; code=&quot;編碼&quot; &gt;&lt;source src=&quot;檔案路徑&quot; type=&quot;視訊格式&quot; code=&quot;編碼&quot; &gt;&lt;/video&gt; 表格：不要用來排版，只要顯示資料就好。用 CSS 處理排版。Code123456789101112131415161718192021222324252627&lt;table&gt; &lt;thead&gt; &lt;!--表頭--&gt; &lt;tr&gt; &lt;!--列的起始 row - - - column(行,欄) | | | --&gt; &lt;th&gt;Month&lt;/th&gt; &lt;!--表格標題--&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!--內容--&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;!--表格內容--&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;February&lt;/td&gt; &lt;td&gt;$80&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;!--註腳--&gt; &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt; &lt;td&gt;$180&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;td colspan=&quot;2&quot;&gt;$180&lt;/td&gt; 資料超過一欄 (跨欄)&lt;td rowspan=&quot;2&quot;&gt;$180&lt;/td&gt; 資料超過一列 (跨列) 表單&lt;form action=&quot;按下後接收送出資訊的url&quot; method=&quot;get or post&quot; id=&quot;a&quot;&gt;&lt;/from&gt; get：搜尋框 or 只想從伺服器取得資料(普通資料)。post：上傳檔案 or 表單很長 or 有敏感資料(密碼) or 資料加到資料庫或從資料庫刪除。 name 跟 value 屬性欄位的值有些會傳給伺服器任何文字輸入欄位可以使用 placeholder 屬性，placeholder=”顯示在欄位內的文字” e.g. Code123456789101112131415161718192021222324252627&lt;form action=&quot;按下後接收送出資訊的url&quot; method=&quot;get or post&quot; id=&quot;a&quot;&gt; &lt;p&gt;username 文字輸入 &lt;input type=&quot;text&quot; name=&quot;username&quot; maxlength=&quot;限制字元數&quot;&gt; &lt;/p&gt; &lt;!--多行文字輸入欄位標籤--&gt; &lt;textarea name=&quot;Content&quot;&gt;&lt;/textarea&gt; &lt;!--密碼輸入--&gt; &lt;input type=&quot;password&quot; name=&quot;username&quot; maxlength=&quot;限制字元數&quot;&gt; &lt;!--單選--&gt; &lt;input type=&quot;radio&quot; name=&quot;username&quot; value=&quot;傳到伺服器的值，每個單選鈕都不應相同&quot; checked=&quot;checked(預先選好)&quot;&gt; &lt;!--勾選(可取消)--&gt; &lt;input type=&quot;checkbox&quot; name=&quot;username&quot; value=&quot;傳到伺服器的值，每個單選鈕都不應相同&quot; checked=&quot;checked(預先選好)&quot;&gt; &lt;!--下拉式選單 (若都沒 selected 屬性的話，會顯示第一個選項)--&gt; &lt;select name=&quot;Location&quot; size=&quot;3&quot; multiple=&quot;multiple(可多選)&quot;&gt; &lt;option value=&quot;Taipei&quot; selected=&quot;selected(預先選好)&quot;&gt;台北&lt;/option&gt; &lt;option value=&quot;Taoyuan&quot;&gt;桃園&lt;/option&gt; &lt;/select&gt; &lt;!--檔案輸入 (method 必須使用 post)--&gt; &lt;input type=&quot;file&quot; name=&quot;username&quot;&gt; &lt;!--送出按鈕 (name 跟 value 欄位可用可不用)--&gt; &lt;input type=&quot;submit&quot; name=&quot;username&quot; value=&quot;顯示按鈕文字&quot;&gt; 影像按鈕 &lt;input type=&quot;image&quot; src=&quot;url&quot;&gt;&lt;/from&gt;&lt;input type=&quot;hidden&quot; name=&quot;&quot; value=&quot;&quot;&gt; 隱藏控制項，用隱藏欄位來記錄資訊 ps.表單驗證HTML5 有驗證功能，加入 required 屬性(不需要值)，由瀏覽器來做。)，HTML5 才有(不支援 HTML5 的瀏覽器會當作文字框)。 日期輸入&lt;input type=&quot;date&quot; name=&quot;date&quot;&gt;EMAIL 輸入&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;URL 輸入&lt;input type=&quot;url&quot; name=&quot;website&quot;&gt;搜尋輸入&lt;input type=&quot;search&quot; name=&quot;search&quot;&gt; label 協助使用者在點選到該標籤時，可以透過 for 的屬性值，去連動具有相同 id 屬性值的標籤。或是直接將 &lt;input&gt; 元素包圍起來。&lt;label for=&quot;某id值&quot;&gt;&lt;/label&gt; e.g. Code123&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;booktype&quot; value=&quot;1&quot; id=&quot;booktype1&quot; checked &gt;&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;booktype&quot; value=&quot;2&quot; id=&quot;booktype2&quot; checked &gt;&lt;label for=&quot;booktype1&quot;&gt;html 書&lt;/label&gt; 按鈕(可添加圖片)&lt;button type=&quot;button&quot;&gt;&lt;img src=&quot;url&quot; alt=&quot;&quot;&gt;&lt;/button&gt; iframe 顯示別的 url 的網頁內容在本身網頁的某區塊上&lt;iframe src=&quot;url&quot; height=&quot;20&quot; width=&quot;10&quot;&gt;&lt;/iframe&gt; 註解&lt;!----&gt; 符號顯示&amp;lt; &lt;&amp;gt; &gt;&amp;amp; &amp;&amp;copy; 版權符號&amp;reg; 註冊商標&amp;nbsp; 空白 //在畫面上出現多個空白 補充使用編輯器小技巧(emmet)： 若檔案為 *.HTML 的話，在開啟檔案後，打 ! ，可產生出以下標籤。 Code1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;``` + 打 link:css：快速產生 `&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;`+ 打 lorem300，可以產生 300個假字。+ 使用 `標籤名稱.class名稱*數量&gt;要包覆的標籤1+要包覆的標籤2` 方式，按下 enter，可以快速產生標籤。e.g.`div.test*2&gt;p+img`產生 Code123### 簡單網頁範例： &lt;!DOCTYPE html&gt; Document h1{color:red} 標題1 標題2 標題3 標題4 標題一 lorem js後的標題 123` 參考：https://zh.wikipedia.org/wiki/HTMLhttp://cychiang719.blogspot.com/2008/08/html.htmlhttp://n.sfs.tw/content/index/10323https://ithelp.ithome.com.tw/articles/10160131http://www.dlps.tc.edu.tw/html_teach/]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[記錄一下 AJAX 操作的幾個方法]]></title>
    <url>%2F2019%2F12%2F15%2FAJAX-base%2F</url>
    <content type="text"><![CDATA[AJAX(Asynchronous JavaScript and XML)的縮寫間單來說是與伺服器進行非同步通訊，可用來自伺服器的資料更新網頁元素，綜合了多項技術的瀏覽器端網頁開發技術。可以增進使用者的操作體驗。 以下介紹幾種使用方法： JavaScript XHR透過 XMLHttpRequest(XHR) 物件作為實作。它能夠在 client 端對 server 端送出 http request，使用的資料格式是 XML(這也變成時代眼淚，現今大多使用 JSON，它的格式像是 JS 中的物件)，用 XMLHttpRequest() 取到的結果會是字串，要額外透過 JSON.parse() 轉成 JSON 才可以使用。 Ps.目前較少用，難以閱讀及撰寫，我們大多都會使用框架來處理這段，如 jQuery, Axio… 程式碼大概長這樣： Code1234567891011121314151617181920212223242526272829303132333435363738function reqOnload () &#123; // 資料轉成 JSON 格式 const data = JSON.parse(this.responseText); console.log(data)&#125;function reqError (err) &#123; console.log(&apos;錯誤&apos;, err)&#125;// 宣告一個 XHR 的物件var Req = new XMLHttpRequest(); // 定義連線方式 true: 非同步 , false: 同步Req.open(&apos;get&apos;, &apos;https://randomuser.me/api/&apos;, true);// 送出請求Req.send();// 如果成功就執行 reqOnload()Req.onload = reqOnload; // 失敗就 reqError()Req.onerror = reqError;//POST(Form)var xhr = new XMLHttpRequest();xhr.open(&apos;post&apos;, &apos;http://xxx&apos;, true);xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);xhr.send(&apos;name=Bob&amp;password=123456&apos;);//POST(JSON)var account = &#123; name: &apos;Bob&apos;, password:&apos;123456&apos;&#125;var xhr = new XMLHttpRequest();xhr.open(&apos;post&apos;, &apos;https://xxx&apos;, true);xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/json&apos;);var data = JSON.stringify(account);xhr.send(data); XMLHttpRequest 有各種狀態碼(readyState)，能夠知道當前進行到什麼狀態。 0 : 已經產生 XMLHttpRequest，但還沒連結到要取得的網址。1 : 用了 open() ，但還沒傳送資料過去2 : 用了 send()3 : loading 資料4 : 撈回資料了，數據已接收完全 jQueryCode123456789101112131415161718$.ajax(&#123; url: &quot;http://xxx&quot;, // 傳送至Server的資料，必須為物件格式 data : &#123; datafromtestFile : $(&quot;#input&quot;).val(), &#125;, type: &quot;GET&quot;, // 傳回 JSON dataType: &apos;json&apos;, // 成功時執行函式 success: function(data) &#123; // 取得的遠端資料 console.log(data); &#125;, error: function(error) &#123; console.log(&quot;error:&quot;, error); &#125;&#125;); FetchES6 原生方法 ，是搭配 Promise(Promise 的基本用法)來執行請求網站和請求後獲取 Response 的處理。then 作為下一步，catch 作為錯誤回應 (404, 500…)。回傳的為 ReadableStream 物件，需要使用不同資料類型使用對應方法，才能正確取得資料物件。 Code1234567891011fetch(&apos;http://abc.com/&apos;, &#123;method: &apos;GET&apos;&#125;).then((response) =&gt; &#123; // 這裡會得到一個 ReadableStream 的物件 console.log(response); // 可以透過 blob(), json(), text() 轉成可用的資訊 return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log(&apos;錯誤:&apos;, err);&#125;); text()：改為 response.text()，取得的資料格式將會是純字串。blob()：將資料轉為 blob 物件，像是圖片就可以做這樣的轉換(指的是圖片檔案本身)。 範例： Code123456789101112// unsplash 上的圖片let url = &apos;https://images.unsplash.com/photo-1513313778780-9ae4807465f0?auto=format&amp;fit=crop&amp;w=634&amp;q=80&apos;fetch(url) .then((response) =&gt; &#123; return response.blob(); &#125;) .then((imageBlob) =&gt; &#123; let img = document.createElement(&apos;IMG&apos;) document.querySelector(&apos;.newImg&apos;).appendChild(img); // 將 blog 物件轉為 url img.src = URL.createObjectURL(imageBlob); &#125;) 用 Fetch 做 post 時，需做一些調整。將 body 所送出的資料轉純字串後才能送出。 Code12345678910111213141516171819let url = &apos;https://hexschool-tutorial.herokuapp.com/api/signup&apos;;fetch(url, &#123; method: &apos;POST&apos;, // headers 加入 json 格式 headers: &#123; &apos;Content-Type&apos;: &apos;application/json&apos; &#125;, // body 將 json 轉字串送出 body: JSON.stringify(&#123; email: &apos;lovef1232e@hexschool.com&apos;, password: &apos;12345678&apos; &#125;)&#125;).then((response) =&gt; &#123; return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log(&apos;錯誤:&apos;, err);&#125;) 使用 Fetch 需要注意，只要是伺服器有正確回應，不管是什麼狀態碼，就算是 404 也會將 response 傳入 then 之後的 function 繼續執行，而不會進到 catch。 此時可以透過 response 中的 ok 來判斷狀態碼是否正常，如果是 true 則表示狀態碼在於 200~299 之間。 所以可以多加個判斷 Code1234567891011121314fetch(&apos;http://abc.com/&apos;, &#123;method: &apos;get&apos;&#125;).then((response) =&gt; &#123; if (!response.ok) &#123; throw new Error(response.statusText); &#125; // 這裡會得到一個 ReadableStream 的物件 console.log(response); // 可以透過 blob(), json(), text() 轉成可用的資訊 return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log(&apos;錯誤:&apos;, err);&#125;); axios1.依賴 ES6 Promise，若不支援請使用 Polyfill2.支援 Promise API3.可取消請求 (Promise 無法)4.自動轉換 JSON5.axios 實體建立，可統一套用 Config、管理 API 安裝$ npm install axios Code12345678910111213141516171819202122232425// GETaxios.get(&apos;http://user/12345&apos;).then(res =&gt;&#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;)// POSTaxios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;).finally(() =&gt; &#123; /* 不論失敗成功皆會執行 */ &#125;); 管理 API 方式 開新檔 api.js Code12345678910111213141516171819202122232425262728import axios from &apos;axios&apos;;// User相關的 apiconst userRequest = axios.create(&#123; baseURL: &apos;https://api/user/&apos;&#125;);// 文章相關的 apiconst articleRequest = axios.create(&#123; baseURL: &apos;https://api/article/&apos;&#125;);// 搜尋相關的 apiconst searchRequest = axios.create(&#123; baseURL: &apos;https://api/search/&apos;&#125;);// User 相關的 apiexport const apiUserLogin = data =&gt; userRequest.post(&apos;/signIn&apos;, data);export const apiUserLogout = data =&gt; userRequest.post(&apos;/signOut&apos;, data);export const apiUserSignUp = data =&gt; userRequest.post(&apos;/signUp&apos;, data);// 文章相關的 apiexport const apiArticleItem = () =&gt; articleRequest.get(&apos;/ArticleItem&apos;);export const apiArticleMsg = data =&gt; articleRequest.post(&apos;/ArticleMsg&apos;, data);export const apiArticleLink = data =&gt; articleRequest.post(&apos;/ArticleLink&apos;, data);// 搜尋相關的 apiexport const apiSearch = data =&gt; searchRequest.get(`/Search?searchdata=$&#123;data&#125;`);export const apiSearchType = () =&gt; searchRequest.get(`/SearchType`); 如果需要用到的話，就 import Code1234567891011121314// import api.jsimport &#123; apiUserLogin, apiUserLogout, apiUserSignUp &#125; from &quot;api.js&quot;; // 使用 LoginapiUserLogin(&#123; email: &quot;mike@gmail.com&quot;, password: &quot;123456789&quot;&#125;).then(res=&gt; &#123; console.log(res);&#125;).catch(err=&gt; &#123; console.log(err);&#125;) 參考：axios 默認值 &amp; 建立實體 &amp; 錯誤偵測鐵人賽：ES6 原生 Fetch 遠端資料方法使用Axios你的API都怎麼管理？Day21 AJAX(1): 科普 &amp; XHRDay22 AJAX(2): Fetchaxios 基本使用 &amp; Config使用 fetch 來進行 Ajax 呼叫axios小筆記：一些特殊用法]]></content>
      <categories>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap 簡單介紹]]></title>
    <url>%2F2019%2F12%2F14%2Fbootstrap-base%2F</url>
    <content type="text"><![CDATA[Bootstrap前端框架，含HTML、CSS及JS等內容的框架，可以快速開發出一個網頁版型(包含響應式網頁)。簡單介紹一下樣式寫法：文字對齊text-justify、text-center 置右text-right 字體font-weight-bold 大小寫text-capitalize 文字顏色綠class=&quot;text-success&quot; 去除文字類別效果class=&quot;text-decoration-none&quot; 背景色bg-primary 背景梯度(Background gradient)顏色漸層bg-gradient-warning 邊界四邊都有border 只有上邊界border-top 沒有邊界border-0 除上邊界沒有其他三邊有border-top-0 邊界顏色class=&quot;border border-primary&quot; 邊界角度(Border-radius)四周都圓角class=&quot;rounded&quot; 圓形rounded-circle 無圓角rounded-0 上方圓角rounded-top 清除浮動(Clearfix)class=&quot;clearfix&quot; display 屬性設定class=&quot;d-block&quot; // display: block class=&quot;d-inline&quot; // display: inline Code1234&lt;div class=&quot;bg-danger m-5 p-2 text-light d-inline&quot;&gt;d-inline&lt;/div&gt;&lt;div class=&quot;bg-warning m-5 p-2 text-secondary d-inline&quot;&gt;d-inline&lt;/div&gt;&lt;span class=&quot;bg-danger m-5 p-2 text-light d-block&quot;&gt;text-danger&lt;/span&gt;&lt;span class=&quot;bg-warning m-5 p-2 text-secondary d-block&quot;&gt;text-secondary&lt;/span&gt; 隱藏元素也不佔空間class=&quot;d-none&quot; 顯示陰影class=&quot;shadow&quot; Close icon x&lt;button type=&quot;button&quot; class=&quot;close&quot; arialabel=&quot;Close&quot;&gt; 詳細樣式、元件、模板請參考網站 https://getbootstrap.com/docs/4.0/utilities 網格系統Bootstrap 的 Grid System。規則如下：結構依序為如下：container -&gt; row -&gt; column所有的「row」都要放在「container」之下，「col-\」(column) 要放在「row」之下。column 為最小單位的方格，且有間格將彼此格開。由「row」校正 colume 左右多出來的左右 padding。基本上一個 row 放置 12 個 column，若有一個 row 超過 12 個 column，則會斷行放置多出來的 column。* Container 提供方式來置中你的內容，當你的容器寬度是固定的使用 .container 如果想要滿版則使用 .container-fluid。 Column命名規則：phone (576px~767px) = .col-xs-* // 預設斷點 為數字 1~12Small grid (≧768px) = .col-sm-\ // 平板Medium grid (≧992px) = .col-md-* // 電腦Large grid (≧1200px) = .col-lg-* // 電腦(大型).col-md-offset-* // 位移 ps. 調整不同視圖下的欄寬度，在 Bootstrap 4 中 .col-xs-* 已消失，取而代之的 .col-* 在語意上代表的差別是「從最小設備到最大設備都相同的網格」。 只要在 row 中，直接加入 col 後，就會自動將 row 的 div 等分，比方要作三等份，以前需寫 col-md-4 ，但現在只要 col 重覆三次，無需再特別註明裝罝與數量，還可以混用，將 col 後再加數量。 範例一 Code1234567&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt;a&lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt;b&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;c&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 範例二 Code1234567891011&lt;div class=&quot;wrap&quot;&gt; or &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-8&quot;&gt;col-sm-8&lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt;col-sm-4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm&quot;&gt;col-sm&lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt;col-sm&lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt;col-sm&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 螢幕尺寸大小上調整不同寬度同一 column 加上多的 class 來調整版面： Code1234567&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-4 col-md-8&quot;&gt;.col-sm-4 .col-md-8&lt;/div&gt; &lt;div class=&quot;col-sm-8 col-md-4&quot;&gt;.col-sm-8 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- 當螢幕尺寸為 md 以上時會有 8:4 來顯示 當螢幕尺寸為 sm 時會以 4:8 來顯示 當螢幕尺寸小於 sm 時會換行顯示 --&gt; 隨著內容變動寬度使用 col-{breakpoint}-auto 同時搭配上 水平對齊 可以讓 column 的寬度隨著內容而改變。 間距拿掉.row 加入: no-gutters e.g.&lt;div class=&quot;row no-gutters&quot;&gt; 垂直對齊.row 或 .col 加入: align-items-start // 列或欄垂直的置頂align-items-center // 列或欄垂直的置中align-items-end // 列或欄垂直的置底 水平對齊.row 加入: justify-content-start // 置左justify-content-center // 置中justify-content-end // 置右justify-content-around // 是讓該列內的欄平均排列在該列justify-content-between // 是讓列類的欄靠邊排列在該列 Spacing指元素的 margin 跟 padding 。 m：marginp：paddingt：topr：rightb：bottoml：leftx：-right和-lefty：-top 和 -bottom m：marginmt：margin-topmr：margin-rightmb：margin-bottomml：margin-leftmx：margin-right 和 margin-leftmy：margin-top 和 margin-bottom p：paddingpt：padding-toppr：padding-rightpb：padding-bottompl：padding-leftpx：padding-right 和 padding-leftpy：padding-top 和 padding-bottom Bootstrap 4 裡 Spacing 基本的單位就是 1rem。1rem = 16px，結合上述的代碼。就是代表要多少的內距或外距。 0：0 1rem = 0px1：0.25 1rem = 4px2：0.5 1rem = 8px3：1 1rem = 16px4：1.5 1rem = 24px5：3 1rem = 48pxauto: margin 設定為 auto e.g. mb-3 = margin-bottom：16pxpt-4 = padding-top：24pxm-1 = margin：4px; 使用 flexboxclass=&quot;d-flex flex-column&quot; flex-column：直排上到下排列內元素flex-row：橫排左至右排列內元素 表單class=&quot;form-control&quot; 卡片(Cards)Cards 是 Bootstrap 4 的新組件，使用 Flexbox 建構，有瀑布流樣式(Masonry-like)可供使用。卡片可支援各種內容，包括圖像、文字內容、清單、連結等。 ps. 瀑布流樣式(Masonry-like): 將卡片包在 .card-columns 中，就會讓卡片呈現瀑布式排列。 範例套用 Bootstrap 4 的 class Code12345678910HTML&lt;div class=&quot;box2 bg-danger m-5&quot;&gt;&lt;/div&gt;CSS.box2&#123; width: 100px; height: 100px;&#125; 長寬各 100px 的 #dc3545 色正方型，然後四邊各有 48px 的外距。 參考：https://medium.com/@weilihmen/bootstrap-初學介紹-靜態篇-f20500235b33https://bootstrap.hexschool.comhttps://getbootstrap.comhttps://cythilya.github.io/2015/04/07/bootstrap-grid-system/https://5xruby.tw/posts/bootstrap-4/https://ithelp.ithome.com.tw/articles/10228808?sc=iThomeRhttps://pjchender.blogspot.com/2017/06/bootstrap4-grid-system.html]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RWD 基本知識]]></title>
    <url>%2F2019%2F12%2F13%2FRWD-base%2F</url>
    <content type="text"><![CDATA[響應式網頁(RWD)Responsive web design，縮寫為 RWD。是一種設計方式，利用操控 CSS 的方法來改變網頁樣式，網頁內容就可以自由的縮放、移動，好因應各種不同瀏覽器解析度，讓使用者在瀏覽網頁時都可以有最好的瀏覽體驗。在 HTML 上沒有甚麼不同，其實也只有在 &lt;head&gt; 標籤裡加上 Viewport Meta Tag。&lt;meta name=&quot;viewport&quot; content=&quot;&quot;&gt; content 的值有 Width // 寬度Width-device-width // 寬度為裝置的寬度Initial-scale // 文檔的初始比例(單位是 %)Maximum-scale // 設定縮放大小 Code1234// 指定螢幕寬度為裝置寬度，畫面載入初始縮放比例 100%&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; &gt;// 以下設定可以防止使用者做畫面縮放，將畫面鎖在縮放比例 100%&lt;meta name=”viewport” content=”width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 主要是在 CSS 的撰寫，以下進行簡單的介紹：撰寫方式是用 media query @media 來定義套用的媒體類型和特性。 媒體類型（Media Type）：可用的類型包含 all (default), print, screen 和 speech。媒體特性（Media Feature）：常用的類型包含 width, height, aspect-ratio, orientation, resolution，這些類型常常需要給定一個區間，像是 min, max, min-width, max-width, min-aspect-ratio, max-aspect-ratio。 定義媒體類型及同時定義媒體類型和媒體特性Code1234567891011// 定義媒體類型@media screen, print &#123; /* Styles for screen and print devices */&#125;// 同時定義媒體類型和媒體特性，中間需用 and 連接@media screen and (max-width: 650px) &#123; body &#123; background: rebeccapurple; &#125;&#125; 或是直接寫特性Code1234567891011121314151617181920212223242526272829// max-width 以電腦瀏覽比較為主通常用 max-width 開始寫// 當解析度小於768px@media (max-width: 768px) &#123; body&#123; background: yellow; color:black; &#125; &#125;// 當解析度小於375px@media(max-width: 375px)&#123; body&#123; background: blue; color:white; &#125;// min-width 以行動瀏覽為主的網頁通常會用 min-width 開始寫// 當解析度大於376px@media(min-width:376px)&#123; body&#123; background: yellow; color:black; &#125;&#125;// 當解析度大於769px@media(min-width:769px)&#123; body&#123; background: green; color:yellow; &#125; 簡單範例Code123456789101112131415161718192021222324252627//HTML&lt;meta name=”viewport” content=”width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;body&gt; &lt;h1&gt;請縮放螢幕使網頁內容產生變化&lt;/h1&gt; &lt;p&gt;test&lt;/p&gt;&lt;/body&gt;//CSSbody&#123; background: green; color:yellow;&#125;@media (max-width: 768px) &#123; body&#123; background: yellow; color:black; &#125; &#125;@media(max-width: 375px)&#123; body&#123; background: blue; color:white; &#125;&#125; 寫 RWD 時注意的事子元素寬度設定盡量使用 % ，避免縮放網頁時產生出 X 軸。Code1234567891011121314151617// 限定網頁最大寬度，避免產生 X 軸.wrap &#123; max-width: 1024px; margin: 0 auto;&#125;// 子元素寬度單位用 % .box1&#123; width: 100%; height: 200px; background: green;&#125;.box2&#123; width: 35%; height: 100px; background: pink; float:left;&#125; 瀏覽器尺寸範例：Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546@media screen and (min-width:1024px)&#123; /*STYLES*/&#125;@media screen and (min-width: 1200px) &#123; // 如果使用者之視窗寬度 &gt;= 1200px，將會再載入這裡的 CSS。&#125;@media screen and (min-width: 768px) and (max-width: 979px) &#123; // 如果使用者之視窗寬度介於 768px ~ 979px，將會再載入這裡的 CSS。&#125;@media screen and (max-width: 767px) &#123; // 如果使用者之視窗寬度 &lt;= 768px，將會再載入這裡的 CSS。&#125;@media screen and (max-device-width: 480px) &#123; // 如果使用者之裝置寬度 &lt;= 480px，將會再載入這裡的 CSS。&#125;瀏覽器直立或橫放@media screen and (orientation:portrait)&#123; // 直立時套用&#125;@media screen and (orientation:landscape)&#123; // 橫放時套用&#125;retina 顯示器我們可以透過 min-resolution: 192dpi 和 -webkit-min-device-pixel-ratio: 2 來定義 retina 顯示器：// 120dpi - 720px,// 192dpi - 1200px@media screen and (min-resolution: 192dpi), (-webkit-min-device-pixel-ratio: 2) &#123; /* ... */&#125;@media screen and (min-resolution: 120dpi) and (min-width: 720px) &#123; // ...&#125; 參考：[CSS] Media Query響應式網頁(RWD)環境與 Media Query使用 Bootstrap 建立一個 RWD Template（Twitter Bootstrap in Responsive Web Design）]]></content>
      <categories>
        <category>RWD</category>
      </categories>
      <tags>
        <tag>RWD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基本介紹]]></title>
    <url>%2F2019%2F12%2F13%2F2019-12-13-css-base%2F</url>
    <content type="text"><![CDATA[#CSS 基本介紹 CSS是什麼 樣式：將規則與 HTML 元素連結，來規定特定元素應呈現的樣子。 有範圍性，不用下重複設定在多個標籤元素上。直接在最外圍的標籤上設定，例如 body、header。 盡量不要用 id 來設計樣式。 不要習慣寫死高度，利用 max-width、margin、padding 來做出空間。 Bootstrap 格線設計好用。 加入到 HTML 三種方式1.外部載入 CSS 檔案這是一個比較常用的方式，通常會將所有的 CSS 檔案集中寫在一起，然後另存為一個附檔名為 css 的檔案，然後在 HTML 文件中的 head 標籤內添加一個 link 標籤並且在 href 屬性內，指向到該 CSS 檔案的存放位置。 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/all.css&quot;/&gt; 2.將 CSS 內容寫在 style 標籤裡，並放在 head 標籤裡。 Code12345&lt;style&gt; .red&#123; color: red; &#125;&lt;/style&gt; 3.或是將 CSS 內容單獨的寫在每一個指定的網頁標籤 &lt;p style=”color:green”&gt;&lt;/p&gt; 規則包含兩個部分：選取器(選取元素)和宣告p { color: red; }選取器 宣告 h1, h2, h3 { color: red; } 選取多元素 * { } 選取頁面上所有的元素 #introduction {} 選取 id=”introduction” 的元素 .introduction {} 選取屬性 class=”introduction” 的元素 p.a {} 選取 class 屬性值為 a 的 &lt;p&gt; 元素 li&gt;a {} 選取 &lt;li&gt; 元素內的 &lt;a&gt; 元素，但排除頁面上其他的 &lt;a&gt; 元素 p a {} 選取任何在 &lt;p&gt; 元素之內的 &lt;a&gt; 元素，即使兩者之間還有堆疊其他元素 階層規範(若兩個規則同時套用到同一個元素上) 後來先贏：以最後一個的規則為主 指定程度：若一個選取器較其他的更具指定性，以較具指定性的為主 Code123h1 比 * 更具指定性p b 比 p 更具指定性p#intro 比 p 更具指定性 重要：可在任何屬性值後面加上 !important ，來表示此規則比套用到相同元素的其他規定更重要。 Code123p b &#123; color: blue !important; &#125; 繼承父元素的某些屬性會套用到大部分的子元素上。或在屬性中使用 inherit 值來強迫許多屬性從父元素來繼承屬性值。 Code12345678910body &#123; font-family: Arial ; color: #665544; padding: 10px; &#125;.page &#123; border: 1px solid #665544; background-color: #efefef; padding: inherit; &#125; &lt;body&gt; 元素的 font-family 或 color 屬性會繼承給子元素 class=”page” 的 元素，從套用到 &lt;body&gt; 元素的 CSS 規則中繼承了內距尺寸。 屬性種類顏色color: DarkCyan; 前景色 三種表示方式：1.color: DarkCyan; // name2.color: #ee3e80; // hex3.color: rgb(100,100,90); // rgb background-color: white; 背景 opacity: 0,5;background-color: rgba(100,100,90,0.5); 不透明度(CSS3 值介於 0.0 到 1.0 or rgba 表示) background-image: url(位置); 元素背景影像 文字font-family: Arial, Helvetica, Georgia 指定字型 font-size: 12px; 字體大小 表示方式：1.font-size: 12px;2.font-size: 200%; // 瀏覽器預設文字大小是 16px3.font-size: 1.3em; // ㄧ個 em 等於 m 字母的寬度 font-weight: normal or bold; 粗體 font-style: normal or italic or oblique; 斜體 text-transform: uppercase(大) or lowercase(小) or capitalize(每個字的第一個字變大寫); 大小寫 text-decoration: none or underline(底線) or overline(文字上方加線) or line-through(刪節線) or blink(動態閃爍); 底線和刪節線 line-height: 1.5em; 行距 direction: 靠左 ‘ltr’ 及靠右 ‘rtl’; 設定文字的方向 text-align: left or right or center or justify; (段落除了最後一行外，每一行都應該佔據容器方框的整個寬度) 對齊 text-shadow: 1px 2px #111111;(左右多遠,上下多遠,模糊量) 陰影(CSS3) 盒子模型(box model)由四個部分組合：margin(外距)、border(邊框)、padding(內距)、content(內容)。它控制著頁面各元素的寬與高，比如當我們設定了一個元素的寬高時，所設定的數值還要再加上 padding 和 border，最後才會是這個元素的實際尺寸。如果一個區塊層級的元素位在另一個區塊層級元素內，那麼外面的方框就被稱為 容器 元素或 父 元素。 width: 200px; 元素寬度：單位有：px, em, %，css 3 多了 vw(可視視窗高) vh(可視視窗寬)。 min-width max-width 限制寬度 height: 200px; 元素高度：同上。 min-height max-height 限制高度 ps.使用px：網頁上設定一個 100px*100px 的正方形，當我們縮放螢幕的時候，這個元素並不會隨著變動寬高。使用 %：使用 % 的時候，如果我們的元素內並沒有任何內容，即使設定為 100%，是不會顯示出任何東西。使用vh、vw：使用上和百分比很像，當填入 30vh 和 30vw 時，意思就是這個元素要占整個螢幕可視範圍的30%，很重要的是，這個區塊範圍會隨著瀏覽器的縮放而改變。設計 RWD 時，圖片大小可利用此單位。 margin: auto(瀏覽器自行設定) or %(與邊界元素有關) or px or em; 外距(兩個相連元素之間的間距)。 設定方式：1.margin:上 右 下 左; // 填入數值2.margin:上下 左右;3.margin:上 左右 下;4.margin:四邊同値;獨立設定：margin-top：與上方元素的距離margin-right：與右方元素的距離margin-bottom：與下方元素的距離margin-left：與左方元素的距離 padding: 同上，margin 改成 padding 即可。 內距(邊框跟內容之間的空間)，加入可提高閱讀性。 設定方式跟獨立設定同上。 border: 10px solid #000; //四邊(大小 樣式 顏色) 邊框 設定方式：1.border-width: 2px 1px 1px 2px; // 對應 上 右 下 左2.border-style: solid 單實線 dotted 方格點 dashed 短線 double 兩條實線 groove 刻入頁面 ridge 突出頁面 inset 嵌入頁面 hidden/none 無邊框3.border-color: red red red red; // 對應 上 右 下 左4.border-image: url(“圖片位置”) 11 11 11 11 stretch; stretch 延伸影像 repeat 重複影像 round 重複影像5.border-radius: 5px, 10px, px, 10px; // 圓角若 border-radius 設定跟方框高度一樣，就可以做出圓形。獨立設定：同 padding。 若要準確控制版面不破版，原本所設定的尺寸還需要再扣掉 border/padding，但是這樣每次設尺寸都要做計算，這時可以使用 box-sizing 此屬性，方便我們在設定 width、height 上更直觀。 box-sizing: content-box or border-box or inherit; content-box：預設值，元素實際寬高＝所設定的數值＋border＋padding。border-box：元素實際寬高＝所設定的數值(已包含border和padding)。inherit：繼承至父層的 broder-sizing 設定値。 Code123456789&#123; width: 300px; // 設定寬度 height: 100px; // 設定高度 border: 1px solid black; //設定框線樣式 background-color: pink; //設定背景 margin:20px; //設定外距 padding:20px; //設定內距 box-sizing: border-box; //設定border及padding值包含在長寬內&#125; display: inline 區塊轉為行內元素，與鄰近元素保持在同一行 block 行內元素轉為區塊，另起一行 inlien-block; 區塊元素像行內元素一樣流動，但保持區塊元素其他特性 none; 隱藏元素，頁面上看不到 更改行內/區塊狀態，將行內元素轉成區塊元素。 visibility: hidden 隱藏 隱藏元素，不顯示內容，但將原有位置空下(產生空白)。若不要有空白，用 display 屬性。 位置position: top right bottom left(長度、百分比、或是 auto) static 預設 absolute 絕對 relative 相對 fixed 元素在網頁上的定位。 ps.absolute(絕對): 放在瀏覽器內的某個位置 (依 top、bottom、left、和 right 的值而定)。當使用者將網頁往下拉時，元素也會跟著改變位置。ps: 網頁的四個邊界開始起算。relative(相對): 元素擺在相對於另一個元素的任何地方。要定位的元素加上 position:absolute 還有(top,left,right,bottom)及對應的值，並且在他的父元素加上 position:relative，那個元素就可在在它的父元素範圍內任意定位。fixed: 這代表元素會被放在瀏覽器內的某個位置 (依 top、bottom、left、和 right 的值而定)。當使用者將網頁往下拉時，元素的位置不會改變。 z-index: auto 預設值 數字 inherit 繼承自父層順序 用來決定元素重疊的順序，當兩個元素有重疊的情況時。z-index 值比較大個元素會被放在上面。 float: left、right、none; 定義 box 的浮動，常見是將文字繞著一個圖案顯現或區塊排版。最後記得要使用清除浮動，避免跑版。 clear: left、right、both、none; 清除用來抵銷 float 屬性的作用 某元素置中Code12345&#123; margin: 0 auto; // 元素置中 width: 200px; text-align: center; // 內容也置中&#125; overflow: auto 自動使用捲軸 visible 直接超出範圍，不使用捲軸 hidden 隱藏 scroll 捲軸 inherit 繼承自父元素 當 content 超出 box 時的處理。 游標樣式cursor: auto or crosshair pointer help wait url(“位置”);元素定位處理(排版)還有其他方便的作法，例如 Flex、Grid …FlexFlex 中分為外容器與內元件 flex 外容器屬性display: flex | inlien-flex; 一開始就要宣告為 flex 才開始用 flex-direction: row | row-reverse | column | column-reverse 決定內元件排序方向，改變主軸線方向 — or |，預設狀態： row; //水平由軸線左至右排row-reverse //水平由軸線右至左排column //垂直由軸線上至下排column-reverse //垂直由軸線下至上排 flex-wrap: nowrap | wrap | wrap-reverse 超出範圍時是否換行動的屬性 nowrap; //不換行wrap; //換行wrap-reverse; //換行時反轉 flex-flow: flex-direction 與 flex-wrap 的縮寫，在其前後帶上相對應的值即可 flex-flow: row nowrap; justify-content: flex-start; … 內元件的元素主軸對齊(間隔)，看是 flex-direction 是 row or column flex-start; //靠左對齊flex-end; //靠右對齊center; //水平置中對齊space-between; //平均分配內元件，分開對齊(左右不留空)space-around; //平均分配內元件，分開對齊(左右留空) 以 flex-direction: row 為例： align-items: stretch; … 相對於上面的屬性，交錯軸對齊設定 | flex-start; //靠軸線上端對齊flex-end; //靠軸線下端對齊center; //置軸線中心對齊stretch; //預設值，延伸內元件全部撐開至 Flexbox 高度baseline; //以所有內元件的基線作為對齊標準(左右留空) align-content: flex-start; … align-items 的多行版本，排列方式多一些 flex-start; //靠軸線上端對齊flex-end; //靠軸線下端對齊center; //置軸線中心對齊stretch; //預設值，延伸內元件全部撐開至 Flexbox 的高度space-between; //平均分配內元件，分開對齊(上下不留空)space-around; //平均分配內元件，分開對齊(上下留空) flex 內元件屬性flex-grow: 數字; 元件的伸展性，預設值為 0。 flex-shrink: 數字; 元件的收縮性，當空間分配還不足時的當前元件的收縮性，預設值為 0。 flex-basis: 單位值(px) | auto; 元件的基準值，以自己的基本小大為單位。 align-self：center | flex-start | flex-end | stretch | baseline; 調整內元件交錯軸的對齊設定(主軸不能另外設定)，也可以個別設定單一元件。 order: 數字; 重新定義元件的排列順序，依據數值的大小 Grid一樣分成內外容器。Grid 和 flex 最大不同之處，透過 grid template 來定義版型的結構，分別由 column 及 row 定義出直排與橫列的格線，內容再依隔線作安排。外容器display: grid | inline-grid | subgrid; 定義容器的顯示類型 grid-template-columns: … | …; 橫列 track-size: 可使用彈性的長度、百分比或分數 (分數的部分需使用 fr 單位)line-name: 可自行命名的名稱 grid-template-rows: … | …; 直行 track-size: 可使用彈性的長度、百分比或分數 (分數的部分需使用 fr 單位)line-name: 可自行命名的名稱 範例 Code12345678.wrap &#123; display: grid; grid-template-columns: 200px 50px auto 50px 200px; grid-template-rows: 25% 100px auto; height: 100vh; width: 940px; margin: 0 auto;&#125; grid-template-columns: repeat(2, 1fr 2fr) 100px; repeat({次數}, {格線…} | {格線…}) | {格線…} fr：空間單位repeat：重複隔線 grid-template-areas: 透過 area 定義區塊在 template 上的位置，配合 gird-area 內元素 grid-area：定義空間的名稱外元素 grid-template-areas：定義空間的位置 範例 Code12345678910111213141516171819202122232425262728.wrap &#123; display: grid; grid-template-columns: 200px 50px auto 50px 200px; grid-template-rows: 25% 100px auto; grid-template-areas: &quot;header header header header header&quot; &quot;side main main main main&quot; &quot;side footer footer footer footer&quot;; height: 100vh; width: 940px; margin: 0 auto;&#125;.item-a &#123; grid-area: header; background-color: purple;&#125;.item-b &#123; grid-area: main; background-color: orange;&#125;.item-c &#123; grid-area: side; background-color: green;&#125;.item-d &#123; grid-area: footer; background-color: gray;&#125; ps.空間不能分離且是唯一的，錯誤範例: “side main side” 其他更詳細說明，請參考以下網站。 補充說明：###CSS RESET各瀏覽器其實都有預設一些 CSS，我們稱之為瀏覽器默認樣式(User Agent Stylesheet)，為了增進瀏覽體驗，但是各家瀏覽器的默認樣式並不相同。因此寫一個網頁的時候，我們另外寫了 CSS 檔，而網頁顯示出來的畫面，實際上是瀏覽器默認樣式加上我們的 CSS 。也因而造成同一個網頁在不同的瀏覽器看到的畫面有點不一樣。為了處理這個問題，就有了 CSS RESET，它可以幫我們清除瀏覽器默認樣式，依照我們撰寫的 CSS 檔來顯示。這樣就可以統一樣式了。 目前公認是 meyerweb 的版本。 /* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: &apos;&apos;; content: none; } table { border-collapse: collapse; border-spacing: 0; } 參考：https://w3bits.com/css-box-model/https://wcc723.github.io/css/2017/07/21/css-flex/https://wcc723.github.io/css/2017/03/22/css-grid-layout/https://pjchender.blogspot.com/2015/04/css-3vh-vw.htmlhttps://blog.techbridge.cc/2017/02/03/css-grid-intro/https://gridbyexample.com/https://css-tricks.com/snippets/css/complete-guide-grid/https://developer.mozilla.org/zh-TW/docs/Web/CSShttps://ithelp.ithome.com.tw/articles/10214957https://medium.com/change-or-die/css-%E5%85%A5%E9%96%80%E7%AD%86%E8%A8%98-%E4%B8%80-box-model-box-sizing-56ddc49ac89e]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 操作 DOM]]></title>
    <url>%2F2019%2F12%2F12%2F2019-12-12-DOM%2F</url>
    <content type="text"><![CDATA[HTMLHypertext Markup Language），中文為「超文字標示語言」，是一種用來組織架構並呈現網頁內容的程式語言。網頁內容的組成，可能包含了段落、清單、圖片或表格…等。 JavaScript 操作 DOM 的一些方法DOM：文件物件模型(Document Object Model)， 瀏覽器幫 HTML 的元素節點轉換成 JavaScript 可以操作的物件。 選取元素Code1let element = document.querySelector(&apos;&lt;element-name&gt;&apos;); 新增元素節點Code1document.createElement(&quot;div&quot;); 在某元素後面加入元素Code1.appendChild() 移除該元素Code1.removeChild() 改變元素裡面的文字內容Code1.innerText() 改變元素文字及標籤內容Code1.innerHTML() 新增元素節點樣式Code1.classList.add(&apos;樣式&apos;); 刪除元素節點樣式Code1.classList.delete(&apos;樣式&apos;) 監聽元素事件Code1234element.addEventLister(&apos;事件名稱&apos;, function(e)&#123; // do something&#125;,&lt;boolean&gt;)true =&gt; 捕獲 ; false =&gt; 冒泡，不加參數的話，預設值是 false e.g. click 事件(e.target 點擊到的元素)Code12345678&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script&gt;document.getElementById(&quot;test&quot;).addEventListener(&quot;click&quot;, function( event ) &#123; // 在 “clicked div”顯示點擊次數 event.target.innerHTML = &quot;click count: &quot; + event.detail; &#125;, false);&lt;/script&gt; DOM 事件傳遞機制捕獲 根節點開始往下傳遞子節點然後到 target 冒泡 從 target 往上到子節點一路逆向傳回去根節點 DOM 事件傳遞的順序，先捕獲 -&gt; 自身 -&gt; 冒泡。 取消事件傳遞 Code1*加在哪邊，事件傳遞就停在那，不向上(或下)級傳遞*el.addEventListener(‘click’, (e) =&gt; { // e.eventPhase 回傳一個整數值以代表目前事件於事件流中的傳遞階段 console.log(‘el’, e.eventPhase); e.stopPropagation();}, true)Code1#### 取消預設行為 ```e.preventDefault() 取消瀏覽器的預設行為 Code123456// 超連結使用(不會新開分頁或是跳轉）el_link.addEventListener(&apos;click&apos;, (e) =&gt; &#123; e.preventDefault();&#125;, false)// &lt;form&gt; 的 submit - 阻止送出表單// &lt;input&gt; 的 keypress 事件 - 阻止輸入按鍵 事件傳遞應用事件代理(Delegation)利用 DOM 事件的冒泡特性，將子層元素的監聽事件綁定在父層元素上，好處有：1.如果有很多子元素，就不用一一綁定監聽事件。2.動態新增進來的子元素，因為也是會冒泡到上層，就不怕沒綁定到監聽。 元素操作範例印出 9*9Code1234567891011121314151617181920(function() &#123; const chart = document.querySelector(&apos;#chart&apos;); for (let i = 2; i &lt;= 9; i++) &#123; const DIV = document.createElement(&apos;div&apos;); // 新增 DIV 節點 DIV.classList.add(&apos;col-md-4&apos;); // 新增 DIV 樣式 chart.appendChild(DIV); // id=chart 的元素增加子節點 DIV // chart.append 將字串插入到網頁元素 const UL = document.createElement(&apos;ul&apos;); UL.classList.add(&apos;chart-list&apos;, &apos;list-unstyled&apos;, &apos;bg-light&apos;); DIV.appendChild(UL); let str = `&lt;li class=&quot;chart-num&quot;&gt;$&#123; i &#125;&lt;/li&gt;`;// 2 ~ 9 // 組開頭數字 2~9 字串 //console.log(&apos;外層for&apos;, str); for (let j = 1; j &lt;= 9; j++) &#123; str += `&lt;li class=&quot;h4&quot;&gt;$&#123; i &#125; x $&#123; j &#125; = $&#123; i*j &#125;&lt;/li&gt;`; // 2 x 1 ~ 9 x 9 //console.log(&apos;內層for&apos;, str); &#125; //console.log(&apos;結果&apos;, str); UL.innerHTML = str; // 將字串插入到網頁元素 &#125; &#125;()); //立即呼叫函式 IIFE 印出正方形Code1234567891011121314function square(size)&#123; const chart = document.querySelector(&apos;#chart1&apos;); for (let i = 1; i &lt;= size; i++) &#123; // 印出第i列 for (let j = 1; j &lt;= size; j++) &#123; // 第i列有size個* const sp = document.createElement(&apos;span&apos;); sp.classList.add(&apos;col-md-4&apos;) chart.appendChild(sp); // 增加 span 元素 let str = `*`; sp.innerHTML = str; // 新增元素內容 &#125; const Br = document.createElement(&apos;br&apos;); chart.appendChild(Br); // 增加斷行元素 &#125; &#125;; 印出斜一邊的三角形Code1234567891011121314function sidetriangle(size) &#123; const chart = document.querySelector(&apos;#chart2&apos;); for (let i = 1; i &lt;= size; i++) &#123; // 印出第i列 for (let j = 1; j &lt;= i; j++) &#123; // 第i列有i個* const sp = document.createElement(&apos;span&apos;); sp.classList.add(&apos;col-md-4&apos;) chart.appendChild(sp); // 增加 span 元素 let str = `*`; sp.innerHTML = str; // 新增元素內容 &#125; const Br = document.createElement(&apos;br&apos;); chart.appendChild(Br); // 增加斷行元素 &#125;&#125;; 參考：MDNDOM 的事件傳遞機制：捕獲與冒泡https://yakimhsu.com/project/project_w10_review_DOM&amp;EventListener.html]]></content>
      <categories>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 基本介紹]]></title>
    <url>%2F2019%2F12%2F11%2F2019-12-12-Git%2F</url>
    <content type="text"><![CDATA[簡單記錄一下 Git 學習過程 Git Git 是一個分散式版本控制軟體，可藉由它產生一個儲存庫( git Repository)。 可在自己本機電腦跟遠端伺服器儲存及管理檔案，並做同步處理。 紀錄管理有使用 Git 的目錄內的檔案增刪、檔案內容的修改。 有圖形化介面可以使用，例如：SourceTree。 終端機指令介紹在操作 Git 之前，先來介紹一下終端機的基本指令 ls 查看目錄中的檔案列表 ls -la 列出隱藏文件 cd ~ 前往主目錄 pwd 查看目前所在目錄位置 mkdir test 建立 test 的子目錄 cd test 切換到 test 目錄 cd .. 回到上層目錄 touch index.html 新增 html 檔,若目錄內已有檔案時,會修改檔案時間 cp 複製文件 mv 移動檔案 rm index.html 刪除檔案 rm -R 刪除資料夾與其內所有檔案 安裝Git到官方網站根據自己的作業系統下載https://git-scm.com/downloads 或是透過 Homebrew 來下載https://brew.sh/index_zh-tw.html Code1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 複製以上內容，到終端機視窗貼上並執行。安裝完後，再複製以下內容， Code1$ brew install git 到終端機視窗貼上並執行。 使用者設定剛開始使用時 Git ，首先要設定名稱跟 e-mail 信箱 Code12$ git config --global user.name &quot;your_name&quot;$ git config --global user.email &quot;your_email&quot; Git 區塊Git 有三個檔案存放區塊 如圖所示，分為工作目錄 (未 add )，初始狀態。暫存區 (已 add ，未 commit )儲存區 (已 commit ) Git 指令(終端機)git init “要板控的專案目錄” 初始化專案，開始版控 git add .要放入存放區的檔案 (ex. git add .gitignore ) git add . 當前目錄所新增及修改的檔案加到暫放區(若是在根目錄執行，大致上等於 git add -A) git add -A 整個專案目錄所有的修改都加入到暫放區 git status 看暫放區狀態 git commit -m “提交訊息(註解)” 加入註解後，將專案目錄儲存到儲存庫 git log —oneline 看訊息 git blame index.html 查看檔案內容是誰修改(e.g. index.html) Git 分支git branch ‘分支名稱’ 新增分支 dog(分支可當成貼上標籤) git branch -d ‘分支名或id’ 刪除分支，若參數為 -D ，則是強制刪除 git branch 查看分支 名稱前有 * 的是 head 所在 git branch -f master 版本號碼 將 master 移至該版本號碼 git checkout ‘分支名稱或版本id’ 切換到該分支或該版本 git checkout -b dog 建立 dog 分支並切換過去 git merga ‘分支名稱’ 合併該分支 git rebase ‘分支名稱’(另一種合併方式 ) 改變 base (不會產生合併節點) git reset commit_id(變回該版本) 回到某個版本，原本內容會回到工作目錄–mixed 檔案丟回工作目錄–soft 檔案丟回暫存區–hard 直接刪掉 git reflog 看 log git reset commit_id^ 回到該版本的前一個狀態 幾個 ^ 等於回前幾個 git reset HEAD~2 回到 HEAD 的前2個狀態 git tag 1.0.0 commit_id 貼上標籤 git revert 撤消一個commit 同時建立一個新的 遠端資料庫操作(e.g. GitHub)ps.先到 GitHub 新增一個儲存庫 git remote add origin “遠端 git 網址” 連接遠端儲存庫。origin 代表遠端節點，名稱可修改。 git remote -v 查看遠端 Git 的目的地 git push origin master 把本地的 master 分支推送到 origin 這個遠端節點並在遠端形成一個 master 分支 git pull origin master 到 origin 這個遠端節點, 抓 master 分支的內容,並在本地電腦建立一個 origin/master 分支,同時與本地的 master 分支進行合併 git fetch origin master 到 origin 這個遠端節點, 抓 master 分支的內容,並在本地電腦建立一個 origin/master 分支 git clone “遠端 Git 網址” 把遠端 Git 網址的內容複製ㄧ份到本地端電腦 Git 情況處理1.遠端內容比本機上的新Git push 時發生以下錯誤： error: failed to push some refs to ‘https://github.com/xxxx/xxx.git&#39;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 這段訊息的意思是線上版本的內容比你電腦裡這份還要新，所以 Git 不讓你推上去。可用 git pull origin master —rebase (內容抓下來之後請使用 Rebase 方式合併。)盡量不要用 git push -f origin master 會把自己的檔推上去蓋掉他人的,並以自己的為主。ps.多人的話,盡量開自己的分支來做 2.不想在 Git 內放機密檔案$ touch .gitignore (建立Git 忽略檔案, 然後去編輯 gitignore. 已經存在的黨無效) 內容可放nom-debug.log npm除錯紀錄node_modules 專案依賴關係.DS_Store OSX資料夾屬性.tmp 暫時性檔案 ~ 不想再用版控把 .git 目錄刪除就可以 參考為你自己學 GitGit: 如何從特定 commit 切新的分支？]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本陣列操作]]></title>
    <url>%2F2019%2F12%2F10%2F2019-12-10-%E5%9F%BA%E6%9C%AC%E9%99%A3%E5%88%97%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[介紹一下陣列基本操作的幾個方法建立陣列javascript123const arr = [1,2,3,4,5]; const arr = new Array(1, 2, 3, 4, 5); const arr = Array(1,2,3,4,5); 陣列長度javascript1console.log(arr.length); // 5 設定長度javascript1const arr = new Array(5); 空陣列javascript1const arr = []; 讀取其中一個元素，索引從零開始，對應第一個元素javascript1console.log(arr[0]); // 1 設定陣列長度可以操作陣列內元素，長度若為零。則輸入空陣列javascript12arr.length = 0;console.log(arr); // [] Array.from() 可建立一個新的 Array 實體1.從字串 javascript1Array.from('Hi'); // ["h", "i"] 2.從集合：集合會將集合內重複的元素剔除，可作分類使用 javascript123var s = new Set(['hi', 1, 1, 2]); Array.from(s);console.log(s); // &#123;"hi", 1, 2&#125; 迭代(讀取每一個值，然後用同樣的方式處理每一個值)for 迴圈取陣列元素javascript123456789const arr = [1,2,3,4,5];for (let i = 0; i &lt; arr.length; i++) &#123;console.log(arr[i]); // 依序輸出 1 2 3 4 5 &#125;// 另一種寫法let arr = [1, 2, 3, 4, 5];for (let index in arr) &#123; console.log(arr[index]); 依序輸出 1 2 3 4 5&#125; foreach：將陣列內每個元素，都傳入並執行指定函式一次。javascript123456789// 取陣列中大於 3 的數字const arr = [1, 2, 3, 4, 5];let arr1 = [];arr.forEach((value) =&gt; &#123;if (value &gt; 3)&#123; arr1.push(value);&#125;&#125;);console.log(arr3); // [4,5] 方法push()：新增元素javascript12const arr = [1,2,3,4,5] arr.push(6); // [1, 2, 3, 4, 5, 6] pop()：取出陣列最後一個元素並從陣列移除javascript123const arr = [1,2,3,4,5];let el = arr.pop(); // el = 5console.log(arr); // [1,2,3,4] concat()：合併兩個陣列，並把新的陣列返回javascript123var a1 = [1, 2];var a2 = a1.concat(['a', 'b']);console.log(a2); // 1,2,a,b join()：把所有的陣列元素合併成字串javascript123var a = ['Hello', 'world'];console.log(a.join('-')); // "Hello-world"console.log(a.join('')); // "Helloworld" reverse()：反轉陣列元素的順序至適當的位置javascript123const arr = [1,2,3,4,5];arr.reverse();console.log(arr); // [5, 4, 3, 2, 1] ps.反轉字串應用javascript1234const str = 'Hello';// split 將字串以指定的分隔符號來分割 str1 = str.split('').reverse().join('');console.log(str1); // olleH shift()：取回陣列的第一個元素並移除javascript1234const arr = [1,2,3,4,5];let a = arr.shift();console.log(a) // 1console.log(arr); // [2, 3, 4, 5] unshift()：在陣列的開頭處加入一個以上的元素javascript123const arr = [1,2,3,4,5];arr.unshift(6) console.log(arr); // [6, 1, 2, 3, 4, 5] slice(start_index, upto_index)：回傳部分陣列javascript123const arr = [1,2,3,4,5];arr.slice(1,4) // arr[1] 到 arr[3] 之間的元素console.log(arr); // [2, 3, 4] splice(start, deleteCount, item1, … )：刪除既有元素／或加入新元素來改變一個陣列的內容start：開始位置deleteCount：刪除幾個元素(0 就是不刪除)item1：要加入的元素 javascript12345678const arr = [1,2,3,4,5];let removed = arr.splice(1, 0, 3)console.log(removed); // []console.log(arr); // [1, 3, 2, 3, 4, 5]let removed2 = arr.splice(1, 2, 3)console.log(removed2); // [3, 2]console.log(arr); // [1, 3, 3, 4, 5] sort()：排序陣列的元素，預設的排序順序是根據字串的 Unicode 編碼位置javascript123const arr = ['bob', 'alice', 'jack'];arr.sort(); console.log(arr); // ["alice", "bob", "jack"] ps.也可以用函式來決定如何排序(陣列數字排列要用這種方式)javascript1234567891011const arra = [2,6,1,8,10,32];// 數字排列小到大 arra.sort(function(a, b)&#123; return a - b; &#125;);console.log(arra); // [1, 2, 6, 8, 10, 32]// 數字排列大到小 arra.sort(function(a, b)&#123; return b - a; &#125;);console.log(arra); // [32, 10, 8, 6, 2, 1] ps.陣列數字找大小：用展開運算子將陣列展開成個別值就可以用函式快速找出javascript12345// 陣列數字找大小const arra = [2,6,1,8,10,32];let max = Math.max(...arra);let min = Math.min(...arra);console.log(max, min); // 32, 1 indexOf()：尋找陣列中是否有符合的元素，回傳 -1，表示沒有，回傳正整數表示在那個位置javascript12const arr = [1,2,3,4,5];console.log(arr.indexOf(3)); // 2 ps.jQuery 用法javascript12const arr = [1,2,3,4,5];console.log($.inArray(2, arr)); // 1 includes：陣列中尋找指定元素，回傳 true(找到)或 false(沒找到)javascript12const arr = [1,2,3,4,5];console.log(arr.includes(2)); // true filter()：回傳符合條件的元素，得到一個新陣列javascript12345const arr = [1,2,3,4,5];let arr1 = arr.filter((value) =&gt; &#123; return value &gt; 3; &#125;);console.log(arr1); // [4,5] indexOf 與 $.map 使用，尋找是否有符合的物件javascript12345678910const people = [ &#123; name: 'Peter', age: 10 &#125;, &#123; name: 'John', age: 3 &#125;, &#123; name: 'Nina', age: 15 &#125;];//find object in listlet result = $.map(people, function(item, index) &#123; return item.name&#125;).indexOf('Nina');console.log(result); //2 map()：原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合成為一個新陣列，常用對陣列元素做加工javascript12345const arr = ['a', 'b', 'c'];let arr1 = arr.map((value) =&gt; &#123; return value.toUpperCase() ; &#125;);console.log(arr1); // ["A", "B", "C"] every()：檢查陣列是否全部符合條件，僅會回傳一個值 true or falsejavascript12345const arr = [1,2,3,4,5];let arr1 = arr.every((value) =&gt; &#123; return value &gt;= 1; &#125;);console.log(arr1); // true some()：檢查陣列元素其中是否有符合條件，僅會回傳一個值 true or falsejavascript12345const arr = [1,2,3,4,5];let arr1 = arr.some((value) =&gt; &#123; return value === 3; &#125;);console.log(arr1); // true reduce()：陣列變成個別值，傳入函式內處理。數值加總是常見做法javascript1234567const arr = [1,2,3,4,5];// 處理每個元素後等待回傳結果，第一次處理時代入初始值 0let result = arr.reduce((prev, value) =&gt; &#123;// 與之前的數值加總，回傳後代入下一輪的處理 return prev + value; &#125;, 0); // 初始值為零console.log(result); // 15 ps.陣列扁平化，將複雜的陣列變成一維javascript123456789101112131415const myArr = [ [ 1, 2 ], [ 3, 4, 5 ], [ 6, 7, 8 ]];// 將所有元素都與之前代入的陣列相接起來，第一次處理時代入初始值空陣列let newArr = myArr.reduce(function(arr, element) &#123; // ex: [ 1, 2 ].concat([ 3, 4, 5 ]) return arr.concat(element);&#125;, []);console.log(newArr); // [ 1, 2, 3, 4, 5, 6, 7, 8 ]// 1.將空陣列與 [ 1, 2 ] 相接起來後回傳// 2.將被代入的 [ 1, 2 ] 與 [ 3, 4, 5 ] 相接起來後回傳// 3.將被代入的 [ 1, 2, 3, 4, 5 ] 與 [ 6, 7, 8 ] 相接起來後回傳 ps.對陣列的內容進行統計javascript1234567891011121314151617181920212223const myArr = [ 'C/C++', 'JavaScript', 'Ruby', 'Java', 'Objective-C', 'JavaScript', 'PHP'];// 計算出每種語言出現過幾次let langStatistics = myArr.reduce(function(langs, langName) &#123; // hasOwnProperty() 回傳物件是否有該屬性的布林值。 if (langs.hasOwnProperty(langName)) &#123; langs[langName]++ &#125; else &#123; langs[langName] = 1; &#125; return langs;&#125;, &#123;&#125;);console.log(langStatistics);// &#123; 'C/C++': 1, 'JavaScript': 2, 'Ruby': 1, 'Java': 1, 'Objective-C': 1, 'PHP': 1 &#125; ps. Object 的形式的處理javascript12345678910111213141516171819const data = &#123; 'Fred': 1, 'Leon': 2, 'Wesley': 3, 'Chuck': 4, 'Denny': 5&#125;;// 使用 Object.keys() 取得包含所有 key 的陣列let result = Object.keys(data).reduce(function(prev, name) &#123; // 利用 key 取得原始物件中的值，然後加總 return data[name] + prev;&#125;, 0);console.log(result); // 15// Object.keys()：回傳一個由指定物件所有可列舉之屬性(key)組成的陣列Object.keys(data) // ["Fred", "Leon", "Wesley", "Chuck", "Denny"]data[Fred] // 1 ps. map() 和 reduce() 結合使用javascript1234567891011const arr = [1,2,3,4,5,6,7,8,9,10];let result = arr.map((value) =&gt; &#123; if (value &gt; 5) &#123; return 5; &#125; return value; &#125;).reduce((prev, value) =&gt; &#123; return prev + value; &#125;, 0); // 初始值為零console.log(result); // 40 參考資料https://www.hexschool.com/2017/09/01/2017-09-01-javascript-for/http://fred-zone.blogspot.com/2017/01/javascript-mapreduce.htmlhttps://cythilya.github.io/2017/05/08/javascript-find-item-in-an-array/https://developer.mozilla.org/zh-TW/]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS偽類與偽元素]]></title>
    <url>%2F2019%2F06%2F05%2F2019-06-05-CSS%2F</url>
    <content type="text"><![CDATA[偽元素 (pseudo element) 和偽類 (pseudo class) 差在哪有時候 CSS 裡會出現單冒號 : 跟雙冒號 :: 的符號，單冒號開頭的是偽類 (pseudo class) ，雙冒號開頭的是偽元素 (pseudo element) 。 一般常見的偽類有: 動態：:link、:hover、:active、:focus、:visited 元素狀態：:disabled、:enabled、:checked 結構：:root、:nth-child、:nth-last-child、:nth-of-type、:nth-last-of-type、:first-child、:last-child、:first-of-type、:last-of-type、:only-child、:only-of-type、:empty 偽元素有: ::first-line：選取第一行 ::first-letter：選取第一個字 ::before：從選取元素的前面加入元素 ::after：從選取元素的後面加入元素 ::selection：選取文字反白後 ps.現在單一冒號 : 也可以代表偽元素，但要注意瀏覽器是否支援。 補充SCSS 的 &amp; 符號是scss的语法，代表上一層選擇器(元素) 有時會看到類似寫法 Code12345678.bordered &#123; &amp;.float &#123; float: left; &#125; .top &#123; margin: 5px; &#125;&#125; 其實上面寫法等同於 Code123456.bordered.float &#123; float: left; &#125;.bordered .top &#123; margin: 5px;&#125; .bordered.float 是串聯選擇器，作用在同一標籤上.bordered .top 是後代選擇器，作用在不同標籤上 有時 CSS 中有定義一些 pseudo-classes (或稱偽類、準類別)，被使用來為元素增加一些特效，如 :hover, :link, :visited, :before, :after 等這些以冒號(:)開頭的類別名稱。例如把滑鼠移到某個網頁連結時，連結會變色的 CSS 語法： Code1234567a &#123; font-weight: bold; text-decoration: none;&#125;a :hover &#123; color:#FF00FF;&#125; 上述其實還是一種巢狀的結構，只是都作用到同一個元素(例如範例的 a 元素)上。這樣情況就能夠用對 :hover 使用 ＆ 符號來代表其作用的父選取器，所以上述的 CSS 範例的 Sass 就可以寫成： Code1234567a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; color:#FF00FF; &#125;&#125; 參考來源：oxxostudioCSS 偽類 child 和 of-type]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown語法]]></title>
    <url>%2F2019%2F05%2F29%2F2019-05-29-Markdown%E8%AA%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown Markdown 是一種輕量級標記式語言它有純文字標記的特性，讓編寫的可讀性提升不少。目前已有不少網站都使用 Markdown 來撰寫文件或是在網站上發表文章。 現在來介紹幾個常用的語法: 粗體語法***bold***顯示畫面bold 標題字語法# This is an tag顯示畫面 This is an tag列表語法顯示畫面 item 1 item 2 item 2a item 2b 編號列表語法顯示畫面 Item 1 Item 2 Item 3 Item 3a Item 3b CheckBox括號中的 x 就代表此項目是有勾選的，它並不會主動紀錄勾選過的內容，所以使用時要注意確認。 - [x] This is a complete item- [ ] This is an incomplete item 顯示畫面 This is a complete item This is an incomplete item 區塊區塊分為小區塊跟大區塊，通常用於一段相關內容的撰寫，一小段文字或是註釋可用小區塊來表示，內容較多又不想跟一般段落內容混在一起的話，則會用大區塊來表示。小區塊語法：Code1`Format one word or one line` 大區塊語法：Code1code (4 spaces indent) 顯示畫面： Format one word or one line code (4 spaces indent) 程式碼只要使用三個反引號加上語言簡稱就可以了。高亮程式碼顯示語法 Javascript123var n=1;var b=2,c=3;eval('a'+n+'=b*c'); 圖片插入圖片語法![GITHUB](_圖片網址 &quot;圖片名稱&quot;_)Code1&#123;% asset_img Steve.jpg This is an image %&#125; 階層式區塊階層式區塊在表現結構或功能關係上是相當好用的呈現形式語法： > Quote one sentences>&gt;Quote two sentences>&gt;Quote two sentences>&gt;&gt;Quote three sentences 顯示結果： Quote one sentences Quote two sentencesQuote two sentences Quote three sentences ImagesFormat: Links語法http://github.com - automatic![GitHub](http://github.com) 顯示http://github.com - automatic!GitHub Inline codeI think you should use an&lt;addr&gt; element here instead. Tables語法 First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column 顯示 First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column 參考來源：Markdown - 易編易讀，優雅的寫文吧！ - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天Mastering Markdown · GitHub GuidesMarkdown文件]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript eval()的用法]]></title>
    <url>%2F2019%2F05%2F29%2F2019-05-29-JavaScript-eval%2F</url>
    <content type="text"><![CDATA[eval() 是個滿好用的函式，用途也多種，常常會使用到。 eval 是 evaluates 。例如：Javascript123var n=1;var b=2,c=3;eval('a'+n+'=b*c'); 上面結果會變成 a1=b*c ，就是變數 a1 的結果為 6。 由以上可知，eval() 是把一組字串，當作指令來執行，並得出結果。實作時，在訂單處理上應用較廣，例如以下是份簡單訂單： 數量 單價 小計 Q1 P1 T1 Q2 P2 T2 Q3 P3 T3 用編號來進行不同筆數訂單欄位命名，而不是每個欄位獨立命名，顯示，在輸入數量及單價後，小計要能自動計算。 假設這份表單名為 order，所以： document.order.T1.value=document.order.Q1.value*document.order.P1.value;document.order.T2.value=document.order.Q2.value*document.order.P2.value;document.order.T3.value=document.order.Q3.value*document.order.P3.value; 你是不是會想用 for 來跑迴圈？可是，T1、;Q1 這些欄位名稱一直在變，怎麼跑迴圈呢？這時，eval() 就派上用場了，eval() 把「唸的內容」當結果執行，這個例子怎麼唸呢？ 「第一個 T 的值等於第一個 Q 的值乘以第一個 P 的值」，換成 Javascript12345eval()：var form=document.order;for (var i=1;i&lt;=3;i++)&#123; eval('form.T'+i+'value=form.Q'+i+'value(form.P'+i+'value');&#125; 把 eval() 裡的字串，i 的值分別用 1,2,3 套入，結果和前面寫一大串三行的效果一模一樣。 參考來源：icodding愛程式: JavaScript 的 eval() 用法介紹]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new postbash1$ hexo new "My New Post" More info: Writing Run serverbash1$ hexo server More info: Server Generate static filesbash1$ hexo generate More info: Generating Deploy to remote sitesbash1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
